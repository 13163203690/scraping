{"title": "微信小程序开发中常见的设计败笔 ", "author": "Rolan", "pub_time": "2021-3-11 00:36", "content": "虽然微信小程序的开发难度要低于网页开发和APP开发，再者，微信小程序开发可以使用很多微信提供的设计组建和资源库。如上两个原因都降低了微信小程序开发中出现重大“错误”和“败笔”的概率。但是，我们仍然发现一些在我们看来比较失败的微信小程序设计，我们将其指出，以供大家商榷。败笔：微信小程序中嵌入APP下载模块不少品牌都拥有自己的APP，它们也非常看重APP的运营工作，利用一切渠道推广APP，提升下载量，包括利用微信小程序。例如，打开它们的微信小程序，重点位置就是提供下载APP的引导和提醒。例如，哈罗单车的小程序，在顶部是下载APP的提示。这里存在一个逻辑错误——当用户打开微信小程序，是因为手机中没有APP，或者是为了便利化，因为小程序更快捷和简洁。此时，让用户下载APP，用户显然是不愿意的，心理也是抵触的。所以，我们观察到，一些品牌虽然也有APP，但是却不借助微信小程序进行推广，他们更倾向于引导用户添加小程序的“快捷方式”。例如，麦当劳的小程序，提示用户添加小程序图标到桌面或者微信首页。败笔：页面过多或者页面元素过多为什么微信小程序页面不能过多?因为页面的“组织者”就是导航。微信小程序由于使用的手机屏幕较小，不可能放太多的导航按钮。所以，在微信小程序开发指南中，微信建议底部导航不超过5个，以3个或者4个为宜。为什么微信小程序页面元素而不能过多呢?同样是因为屏幕小，用户的视觉焦点更难以聚焦，需要减少元素，以让用户能够关注到重点。另外，一个页面元素太多，也影响页面加载速度。再者，一个页面元素太多，元素之间互相干扰，也影响用户体验。败笔：导致用户迷茫的设计导致用户迷茫的设计有两个方面，其一，用户不知道自己身处何地;其二，用户不知道如何做出决策。这也是微信小程序设计中容易出现的败笔。以按钮设计为例，两个平行设计的按钮，一样的颜色、一样的形状、一样的排列，很容易导致用户“迷茫”。一来在选择的时候可能会停顿;二来，容易造成误操作。这就是让用户不知道如何决策的败笔设计。还例如，用户选择的状态与未选择的状态，没有形成较为强烈的对比。这会让用户产生“我现在在哪里?”的迷茫。所以，微信小程序中设计中，选中的与为选中的，应该形成足够强烈的对比，包括文字的对比、颜色的对比等。如上，我们总结了三种在微信小程序设计中容易犯下的错误，可供商榷。"}
{"title": "微信小程序用户拒绝授权的官方推荐处理方法 ", "author": "Rolan", "pub_time": "2021-2-25 16:31", "content": "小程序开发中,现在一般都需要获取微信用户信息,如头像/名字等.这样在用户第一次进入小程序时,微信端会弹出一个是否同意授权的消息提示框.但是如果用户第一时间点击了拒绝,或者用户手误点击了拒绝,如果没有了后续的操作,可能你的小程序就不能使用了,也就会失去这样一位用户.所以,微信官方推荐了一个方法,就是在用户第一次拒绝授权的时候,再给用户一个选择的机会.这样能很好的解决上诉问题.下面以用户需要授权两个权限为例,方法如下:在 APP.JS 先设置两个全局变量 .用作记录用户是否授权//判断地理位置是否请求成功var locationBool;//判断用户信息是否请求成功var userInfoBool;的 APP({})中1.获取用户当前位置信息(获取成功后将数据存入缓存,方便后面使用)2.获取用户资料信息:这里需要注意的是:  现在一般开发小程序都需要做服务器登录.由于后端的解密方式的选择问题,后端可以只用用户code 解密,也有可能需要用到 encryptedData/iv 这两个参数拿去后台解密,换取用户token 来做更多的操作. 如需获取encryptedData/iv 这两个参数, 必须在微信wx.login({})之后再去获取 否则这两个参数可能会出现问题    //获取用户信息(获取之前必须login)    wxGetUserInfo: function() {        console.log('微信获取用户信息')        wx.getUserInfo({            //请求成功            withCredentials: true,            success: function(data) {                userInfoBool = true;                wx.setStorage({                    key: 'UserInfoWx',                    data: data                })            },            fail: function() {                userInfoBool = false;            }        })    },    logInWx: function() {        var _this = this;        wx.login({            success: res => {                console.log('微信登录')                console.log(res)                //如果登录成功                var usercode = res.code; //用户code                if (res.code) {                    wx.setStorage({                        key: 'usercode',                        data: usercode                    })                                        //请求用户信息设置缓存(获得nickname/avatarurl/gender/iv/encryptedData)                    _this.wxGetUserInfo();                }            }        })    }在小程序中,微信提供了这样一个方法wx.openSetting({}) 他可以弹出小程序设置授权的页面.下面即是 用户拒绝授权之后的处理方法.    getPromission: function() {        var _this = this;        // 位置信息,用户信息中其中一个数据没有获取到(--->弹出设置界面)        if (locationBool == false || userInfoBool == false) {            // 显示提示弹窗（重新授权）            wx.showModal({                title: '用户未授权',                content: '请开启相应的权限哦~',                showCancel: false,                success: res => {                    if (res.confirm) {                        //点击取消，重新获取授权                        wx.openSetting({                            success: data => {                                console.log(data)                                if (data) {                                    if (data.authSetting[\"scope.userInfo\"] == true && data.authSetting[\"scope.userLocation\"] == false) {                                        //再次获取用户信息                                        console.log('只获取用户信息')                                        _this.wxGetUserInfo()                                    } else if (data.authSetting[\"scope.userInfo\"] == false && data.authSetting[\"scope.userLocation\"] == true) {                                        //再次获取位置信息                                        _this.wxGetlocation()                                        console.log('只获取位置信息')                                    } else if (data.authSetting[\"scope.userInfo\"] == true && data.authSetting[\"scope.userLocation\"] == true) {                                        //再次获取用户和位置信息                                        _this.wxGetUserInfo()                                        _this.wxGetlocation()                                        console.log('获取全部信息')                                    }                                }                            },                            fail: function() {                                console.info(\"设置页面失败\");                            }                        });                    }                }            });        }    },然后在app.js onlaunch中    onLaunch: function(e) {        var _this = this        _this.wxGetlocation();        //微信登录        //如果没有获取数据成功.        var timer = setInterval(function() {            if (locationBool != undefined && userInfoBool != undefined) {                clearInterval(timer)                _this.getPromission();            }        }, 200)       },"}
{"title": "微信小程序设备信息和版本更新 ", "author": "Rolan", "pub_time": "2021-2-25 16:45", "content": "封装until.js// 获取小程序以及设备信息\r\nfunction get(success, fail=undefined) {\r\n\r\n  // 设备信息\r\n  const info = {\r\n    // 系统设备信息原对象\r\n    info: {},\r\n    // 是否为iOS\r\n    isIOS: false,\r\n    // 是否为iphoneX XR XS...等iOS系统全面屏手机\r\n    isIphoneX: false,\r\n    // 是否为安卓\r\n    isAndroid: false,\r\n    // 是否为Mac\r\n    isMac: false,\r\n    // 是否为Windows\r\n    isWindows: false,\r\n    // 设备像素比 (px 与 rpx 的转换比例, 公式：px * pixelRatio = rpx)\r\n    pixelRatio: 1,\r\n    // 屏幕宽度\r\n    screenWidth: 0,\r\n    screenWidthRPX: 0,\r\n    // 屏幕高度\r\n    screenHeight: 0,\r\n    screenHeightRPX: 0,\r\n    // 状态栏高度\r\n    statusBarHeight: 0,\r\n    statusBarHeightRPX: 0,\r\n    // 导航栏高度(不包括状态栏，单纯的导航栏高度)\r\n    navigationBarHeight: 0,\r\n    navigationBarHeightRPX: 0,\r\n    // 导航栏高度(包括状态栏，整个导航栏高度)\r\n    navigationHeight: 0,\r\n    navigationHeightRPX: 0,\r\n    // 底部TabBar菜单栏高度\r\n    tabBarHeight: 0,\r\n    tabBarHeightRPX: 0\r\n  }\r\n\r\n  // 加载系统信息进行更换\r\n  wx.getSystemInfo({\r\n    // 获取成功\r\n    success: (res) => {\r\n      // 右上角菜单胶囊范围\r\n      let menuButtonRect = wx.getMenuButtonBoundingClientRect()\r\n\r\n      // 状态栏默认高度\r\n      const statusBarHeight = 20\r\n      // 导航栏默认高度\r\n      const navigationBarHeight = 44\r\n      // TabBar默认高度\r\n      const tabBarHeight = 48\r\n\r\n      // 记录原始数据\r\n      info.info = res\r\n\r\n      // 是否为iOS\r\n      info.isIOS = (res.system.indexOf('iOS') !== -1)\r\n      // 是否为iOS系统全面屏手机\r\n      if (info.isIOS) {\r\n        // 如果为 iOS 且安全区域上面超过 默认状态栏高度 则为 X 系列\r\n        info.isIphoneX = (res.safeArea.top > statusBarHeight)\r\n      }\r\n\r\n      // 是否为安卓\r\n      info.isAndroid = (res.system.indexOf('Android') !== -1)\r\n\r\n      // 是否为Mac\r\n      info.isMac = (res.system.indexOf('macOS') !== -1)\r\n\r\n      // 是否为Windows\r\n      info.isWindows = (res.system.indexOf('Windows') !== -1)\r\n\r\n      // 设备像素比(750 / 屏幕宽度)\r\n      // 系统给成的 res.pixelRatio 值不对，所以使用自己换算出来的比例\r\n      info.pixelRatio = 750 / res.windowWidth\r\n      \r\n\r\n      // 屏幕宽度\r\n      info.screenWidth = res.screenWidth\r\n      // 屏幕宽度 - RPX\r\n      info.screenWidthRPX = info.screenWidth * info.pixelRatio\r\n\r\n      // 屏幕高度\r\n      info.screenHeight = res.screenHeight\r\n      // 屏幕高度 - RPX\r\n      info.screenHeightRPX = info.screenHeight * info.pixelRatio\r\n\r\n      // 状态栏高度\r\n      info.statusBarHeight = Math.max(res.statusBarHeight, statusBarHeight)\r\n      // 状态栏高度 - RPX\r\n      info.statusBarHeightRPX = info.statusBarHeight * info.pixelRatio\r\n      \r\n      // 导航栏高度\r\n      const menuBarHeight = (menuButtonRect.top - info.statusBarHeight) * 2 + menuButtonRect.height\r\n      info.navigationBarHeight = Math.max(menuBarHeight, navigationBarHeight)\r\n      // 导航栏高度 - 如果为奇数则转成偶数\r\n      if (info.navigationBarHeight % 2) { info.navigationBarHeight += 1 }\r\n      // 导航栏高度 - RPX\r\n      info.navigationBarHeightRPX = info.navigationBarHeight * info.pixelRatio\r\n\r\n      // 导航栏高度\r\n      info.navigationHeight = (info.statusBarHeight + info.navigationBarHeight)\r\n      // 导航栏高度 - RPX\r\n      info.navigationHeightRPX = info.navigationHeight * info.pixelRatio\r\n\r\n      // 底部TabBar菜单栏高度\r\n      info.tabBarHeight = Math.max(info.screenHeight - info.navigationHeight - res.windowHeight, tabBarHeight)\r\n      // 底部TabBar菜单栏高度 - 如果为奇数则转成偶数\r\n      if (info.tabBarHeight % 2) { info.tabBarHeight += 1 }\r\n      // 底部TabBar菜单栏高度 - RPX\r\n      info.tabBarHeightRPX = info.tabBarHeight * info.pixelRatio\r\n      console.log(info)\r\n      // 返回\r\n      if (success) { success(info) }\r\n    },\r\n    // 获取失败\r\n    fail: (err) => {\r\n      if (fail) { fail(err) }\r\n    }\r\n  })\r\n}\r\n\r\n// 检查小程序版本并更新\r\nfunction update(success=undefined, fail=undefined) {\r\n  // 检查是否支持版本更新\r\n  if (wx.canIUse('getUpdateManager')) {\r\n    // 获取版本更新对象\r\n    var updateManager = wx.getUpdateManager()\r\n    // 检测是否有新版本\r\n    updateManager.onCheckForUpdate((res) => {\r\n      // 有新版本\r\n      if (res.hasUpdate) {\r\n        // 更新成功回调\r\n        updateManager.onUpdateReady((res) => {\r\n          // 有回调实现\r\n          if (success) {\r\n            // 自己写提示，返回版本更新对象，方便外部使用\r\n            success(updateManager, res)\r\n          } else {\r\n            // 使用内部更新提示\r\n            wx.showModal({\r\n              title: '更新提示',\r\n              content: '新版本已经准备好，是否重启应用？',\r\n              success: (res) => {\r\n                // 确定重启，在 onUpdateReady 回调中使用 applyUpdate 强制小程序重启使用新版本。\r\n                if (res.confirm) { updateManager.applyUpdate() }\r\n              }\r\n            })\r\n          }\r\n        })\r\n        // 更新失败回调\r\n        updateManager.onUpdateFailed((err) => {\r\n          // 有回调实现\r\n          if (fail) {\r\n            // 自己写提示\r\n            fail(err)\r\n          } else {\r\n            // 使用内部更新提示\r\n            wx.showModal({\r\n              title: '更新提示',\r\n              content: '新版本下载失败，请检查网络！',\r\n              showCancel: false\r\n            })\r\n          }\r\n        })\r\n      } else {\r\n        // 无新版本\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\n// 导出使用\r\nmodule.exports = {\r\n  // 获取小程序以及设备信息\r\n  get,\r\n  // 检查小程序版本并更新\r\n  update\r\n}\r\napp.js引用// 导入 until.js\r\nconst system = require(\"./utils.js\")\r\n// 小程序主入口\r\nApp({\r\n  // 设备信息存放，设备信息推荐存放到 app.js 文件中作为全局参数使用\r\n  // 然后到每个页面通过 const app = getApp() 获取使用即可 app.systemInfo\r\n  systemInfo: {},\r\n  // 启动函数\r\n  onLaunch: function (options) {\r\n    // 检查版本更新，推荐放这里，也可以放到手动触发的地方调用\r\n    system.update()\r\n    // 获取设备信息\r\n    system.get((info) => {\r\n      // 记录设备信息\r\n      this.systemInfo = info\r\n    })\r\n  }\r\n})"}
{"title": "小程序静默登录方案设计 ", "author": "Rolan", "pub_time": "2021-3-1 09:36", "content": "1. 背景\r\n首先谈谈在小程序的开发中，如何借助微信的能力标识一个用户?\r\n微信官方提供了两种标识：\r\n\r\nOpenId 是一个用户对于一个小程序／公众号的标识，开发者可以通过这个标识识别出用户。\r\nUnionId 是一个用户对于同主体微信小程序／公众号／APP 的标识，开发者需要在微信开放平台下绑定相同账号的主体。开发者可通过UnionId，实现多个小程序、公众号、甚至 APP 之间的数据互通。\r\n\r\n同一个用户的这两个 ID 对于同一个小程序来说是永久不变的，就算用户删了小程序，下次用户进入小程序，开发者依旧可以通过后台的记录标识出来。那么如何获取OpenId和UnionId呢？\r\n早期(2018 年 4 月之前)的小程序设计使用 wx.getUserInfo 接口，来获取用户信息。设计这个接口的初衷是希望开发者在真正需要用户信息（如头像、昵称、手机号等）的情况下才去调取这个接口。但很多开发者为了拿到UnionId，会在小程序启动时直接调用这个接口，导致用户在使用小程序的时候产生困扰，归结起来有几点：\r\n\r\n开发者在小程序首页直接调用 wx.getUserInfo 进行授权，弹框获取用户信息，会使得一部分用户点击“拒绝”按钮。\r\n在开发者没有处理用户拒绝弹框的情况下，用户必须授权头像昵称等信息才能继续使用小程序，会导致某些用户放弃使用该小程序。\r\n用户没有很好的方式重新授权，尽管微信官方增加了设置页面，可以让用户选择重新授权，但很多用户并不知道可以这么操作。\r\n\r\n微信官方也意识到了这个问题，针对获取用户信息更新了三个能力：\r\n\r\n使用组件来获取用户信息。\r\n若用户满足一定条件，则可以用wx.login 获取到的 code 直接换到unionId。\r\nwx.getUserInfo 不需要依赖 wx.login 就能调用得到数据。\r\n\r\n本文主要讲述的是第二点能力，微信官方鼓励开发者在不骚扰用户的情况下合理获得unionid，而仅在必要时才向用户弹窗申请使用昵称头像，从而衍生出「静默登录」和「用户登录」两种概念。2. 什么是静默登录？\r\n小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。\r\n很多开发者会把 wx.login 和 wx.getUserInfo 捆绑调用当成登录使用，其实 wx.login 已经可以完成登录，wx.getUserInfo 只是获取额外的用户信息。\r\n在 wx.login 获取到 code 后，会发送到开发者后端，开发者后端通过接口去微信后端换取到 openid 和 sessionKey（现在会将 unionid 也一并返回）后，把自定义登录态 3rd_session(本业务命名为auth-token) 返回给前端，就已经完成登录行为了。wx.login 行为是静默，不必授权的，用户不会察觉。\r\nwx.getUserInfo 只是为了提供更优质的服务而存在，比如获取用户的手机号注册会员，或者展示头像昵称，判断性别，开发者可通过 unionId 和其他公众号上已有的用户画像结合来提供历史数据。因此开发者不必在用户刚刚进入小程序的时候就强制要求授权。2.1 静默登录流程时序\r\n官方给出了 wx.login 的最佳实践如下：\r\n静默登录英文简称为silentLogin，代码如下所示：\r\n  private async silentLogin(): Promise<void> {\r\n    try {\r\n      this.status.silentLogin.ing();\r\n\r\n      // 获取临时登录凭证code\r\n      const code = await getWxLoginCode();\r\n      // 将code发送给服务端\r\n      const res = await API.login(code);\r\n      // 保存登录信息，如auth-token\r\n      storage.setSync(constant.STORAGE_SESSION_KEY, res.data);\r\n\r\n      this.status.silentLogin.success();\r\n    } catch (error) {\r\n      logger.error('静默登录失败', error);\r\n      this.status.silentLogin.fail(error);\r\n      throw error;\r\n    }\r\n  }\r\n复制代码\r\n总结为以下三步：\r\n\r\n小程序端调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。\r\n服务器端调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 和 会话密钥 session_key。\r\n开发者服务器可以根据用户标识来生成自定义登录态(例如：auth-token)，用于后续业务逻辑中前后端交互时识别用户身份。\r\n2.2 开发者后台校验与解密开放数据静默登录成功后，微信服务器端会下发一个session_key给服务端，而这个会在需要获取微信开放数据的时候会用到。\r\n为了确保开放接口返回用户数据的安全性，微信会对明文数据进行签名。开发者可以根据业务需要对数据包进行签名校验，确保数据的完整性。\r\n\r\n小程序通过调用接口（如 wx.getUserInfo）获取数据时，如果用户已经授权，接口会同时返回以下几个字段。如用户未授权，会先弹出用户弹窗，用户点击同意授权，接口会同时返回以下几个字段。相反如果用户拒绝授权，将调用失败。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n属性类型说明userInfoUserInfo用户信息对象，不包含 openid 等敏感信息rawDatastring不包括敏感信息的原始数据字符串，用于计算签名signaturestring使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息encryptedDatastring包括敏感数据在内的完整用户信息的加密数据ivstring加密算法的初始向量cloudIDstring敏感数据对应的云 ID，开通云开发的小程序才会返回，可通过云调用直接获取开放数据\r\n\r\n开发者将 signature、rawData 发送到开发者服务器进行校验。服务器利用用户对应的 session_key 使用相同的算法计算出签名 signature2 ，比对 signature 与 signature2 即可校验数据的完整性。开发者服务器告诉前端开发者数据可信，即可安全使用用户信息数据。\r\n如果开发者想要获取敏感数据（如openid,unionID），则将encryptedData和iv发送到开发者服务器，由服务器使用session_key（对称解密密钥）进行对称解密，获取敏感数据进行存储并返回给前端开发者。\r\n\r\n注意： 因为需要用户主动触发才能发起获取手机号接口，所以该功能不由 API 来调用(即上述提到的wx.getUserInfo是无法获取手机号的)，需用 button 组件的点击来触发。获得encryptedData和iv，同样发送给开发者服务器，由服务器使用session_key（对称解密密钥）进行对称解密，获得对应的手机号。\r\n需要关注的是，2021年2月23日，微信团队发布了《小程序登录、用户信息相关接口调整说明》，进行了如下调整：\r\n\r\n2021年2月23日起，通过wx.login接口获取的登录凭证可直接换取unionID。\r\n2021年4月13日后发布新版本的小程序，无法通过wx.getUserInfo接口获取用户个人信息（头像、昵称、性别与地区），将直接获取匿名数据。getUserInfo接口获取加密后的openID与unionID数据的能力不做调整。\r\n新增getUserProfile接口（基础库2.10.4版本开始支持），可获取用户头像、昵称、性别及地区信息，开发者每次通过该接口获取用户个人信息均需用户确认。\r\n\r\n即开发者通过组件调用wx.getUserInfo将不再弹出弹窗，直接返回匿名的用户个人信息。如果要获取用户头像、昵称、性别及地区信息，需要改造成wx.getUserProfile接口。2.3 session_key 的有效期\r\n开发者如果遇到因为 session_key 不正确而校验签名失败或解密失败，请关注下面几个与 session_key 有关的注意事项。\r\n\r\nwx.login 调用时，用户的 session_key 可能会被更新而致使旧 session_key 失效（刷新机制存在最短周期，如果同一个用户短时间内多次调用 wx.login，并非每次调用都导致 session_key 刷新）。开发者应该在明确需要重新登录时才调用 wx.login，及时通过 auth.code2Session 接口更新服务器存储的 session_key。\r\n微信不会把 session_key 的有效期告知开发者。我们会根据用户使用小程序的行为对 session_key 进行续期。用户越频繁使用小程序，session_key 有效期越长。\r\n开发者在 session_key 失效时，可以通过重新执行登录流程获取有效的 session_key。使用接口wx.checkSession可以校验 session_key 是否有效，从而避免小程序反复执行登录流程。\r\n当开发者在实现自定义登录态时，可以考虑以 session_key 有效期作为自身登录态有效期，也可以实现自定义的时效性策略。\r\n3. 静默登录的调用时机3.1 小程序启动时调用由于大部分情况都需要依赖登录态，在小程序启动的时候（app.onLaunch()）调用静默登录是最常见的手段。这里我们封装一个login函数如下所示，首先调用wx.checkSession判断session_key是否过期，如果session_key未过期且本地存在auth_token自定义登录态，表示当前的静默登录态仍然有效，无需进行其它操作。否则，表示静默登录态失效或者新用户从未发起过静默登录，那么发起静默登录流程。\r\npublic async login(): Promise<void> {\r\n    // 调用wx.checkSession判断session_key是否过期\r\n    const hasSession = await checkSession();\r\n\r\n    // 本地已有可用登录态且session_key未过期，resolve。\r\n    if (this.getAuthToken() && hasSession) return Promise.resolve();\r\n\r\n    // 否则，发起静默登录\r\n    await this.silentLogin();\r\n}\r\n复制代码\r\n但是由于原生的小程序启动流程中， App，Page，Component 的生命周期钩子函数，都不支持异步阻塞。所以很有可能出现小程序页面加载完成后，静默登录过程还没有执行完毕的情况，这会导致后续一些依赖登录态的操作（比如请求发起）出错。3.2 接口请求发起时调用\r\n保险起见，如果某些接口需要携带自定义登录态进行鉴权，则需要在请求发起时进行拦截，校验登录态。整个流程如下图所示：\r\n\r\n拦截 request：\r\n\r\n判断是否需要鉴权：请求发起时，拦截请求，判断请求是否需要添加auth-token，如若不需要，直接发起请求。如若需要，执行第二步。\r\n判断是否需要发起静默登录：判断 storage 中是否存在auth-token，如若不存在，发起静默登录，静默登录过程上文时序图已经阐述过了，总结就是获取auth-token并存入本地storage。\r\n请求头部添加auth-token：添加auth-token，发起请求。\r\n\r\n\r\n与服务端通信：发起请求，服务端处理请求返回结果。\r\n拦截 response: 解析状态码\r\n\r\n状态码为AUTH_FAIL：服务端返回code为“鉴权失败”，触发这种情景的原因有两个，一是接口需要鉴权，但是发起请求时未携带auth-token，二是auth-token过期。“鉴权失败”会重新发起静默登录，拿到新的auth-token后发起请求，这个动作对用户来说是无感知的。\r\n状态码为USER_WX_SESSIONKEY_EXPIRE：服务器返回code为“用户登录态过期”，这是针对用户授权手机号登录失败定制的状态码，如果登录态已过期，表示存储在服务端的session_key也是过期的，那么点击授权手机号获取的加密数据发送到服务端进行对称解密，由于session_key失效，无法解密出真正的手机号。因此需要重新发起静默登录，等待用户重新点击授权按钮获取新的加密数据，然后发起新的解密请求\r\n状态码为其它：比如Success或者其他业务请求错误的情况，不进行拦截，返回 response 让业务代码解析。\r\n3.3 wx.checkSession 罢工之谜基于上述接口请求发起时调用的流程，很多人会有疑问，既然服务端会返回auth-token过期的状态码，为啥不在请求发送前进行拦截，使用wx.checkSession接口校验登录态是否过期（如下图所示，增加红框内的步骤）？\r\n这是因为，我们通过实验发现，在 session_key 已过期的情况下，wx.checkSession 有一定的几率返回true。即增加wx.checkSession步骤并不能百分百保证登录态不会过期，后续仍然需要对不同的状态码进行处理。\r\n所以结论是：wx.checkSession可靠性是不达 100% 的。\r\n基于以上，我们需要对 session_key 的过期做一些容错处理：\r\n\r\n发起需要使用 session_key 的请求前，做一次 wx.checkSession 操作，如果失败了刷新登录态。\r\n后端使用session_key解密开放数据失败之后，返回特定错误码（如：USER_WX_SESSIONKEY_EXPIRE），前端刷新登录态。\r\n3.4 并发处理假设一个新用户进入一个业务复杂的页面，同时发起五个不同的业务请求，恰巧这五个请求都需要鉴权，那么五个请求都会被拦截并发起静默登录。显然，这样的并发是不合理的。\r\n基于此，我们设计了如下方案：\r\n\r\n\r\n单队列模式：\r\n\r\n请求锁：同一时间，只允许一个正在过程中的网络请求。\r\n等待队列：请求被锁定之后，同样的请求都会被推入队列，等待进行中的请求返回后，消费同一个结果。\r\n\r\n\r\n\r\n熔断机制：如果短时间内多次调用，则停止响应一段时间，类似于 TCP 慢启动。\r\n\r\n\r\n\r\n如上图所示，首先refreshLogin请求入队，队列中只有一个请求，发送该请求，同时保险丝计入次数 1，服务端返回请求结果，消费结果。接着又发起一个refreshLogin请求，队列中只有一个请求，发送该请求，同时保险丝计入次数 2。然后又连续发起三个请求，由于上一个请求还没有执行完成，将这三个请求入队，等待上一个请求结果返回，队列中的四个请求消费同一个结果。由于触发熔断，保险丝重置，停止响应一段时间。\r\n以上两种方案通过装饰器模式引入，代码如下所示，refreshLogin函数其实是slientLogin函数的一层封装，用于接口发起时调用。而前面提到的login函数也是slientLogin函数的一层封装，用户小程序启动时调用。\r\n  @singleQueue({ name: 'refreshLogin' })\r\n  @fuseLine({ name: 'refreshLogin' })\r\n  public async refreshLogin(): Promise<void> {\r\n    try {\r\n      // 清除 Session\r\n      this.clearSession();\r\n      await this.silentLogin();\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  }\r\n复制代码\r\n4. 最后\r\n读到这里，相信你已经了解「静默登录」和「用户登录」的区别。「静默登录」是获取微信登录态的过程，通过获取微信提供的用户身份标识，快速建立小程序内的用户体系。「用户登录」是用户授权个人开放数据成为会员的过程，是指从游客态转换成会员态的，拥有购买等操作权限。"}
{"title": "微信小程序异步请求封装方案 ", "author": "Rolan", "pub_time": "2021-3-1 09:38", "content": "1.使用callback1.config.js 定义配置信息请求的通用信息2.在utils包中定义http.jsimport { config } from '../config/config'\r\n\r\nclass Http {\r\n    static request({url, data, callback, method='GET'}){\r\n        wx.request({\r\n            url:`${config.apiBaseUrl}${url}`,\r\n            data,\r\n            header:{\r\n                appkey:config.appkey\r\n            },\r\n            success:res=>{\r\n                callback(res.data) //使用回调函数将数据传出去\r\n            }\r\n        })\r\n    }\r\n}\r\n3.在model包中定义theme.js (业务对象)\r\nimport { Http } from '../utils/http';\r\n\r\nclass Theme{\r\n    //获取首页LocationA\r\n    static getHomeLocationA(callback){\r\n        Http.request({\r\n            url:`/theme`,\r\n            data:{\r\n                name:'t-1',//请求的参数\r\n            },\r\n            callback:data=>{\r\n                callback(data) //回调函数中嵌套回调函数\r\n            }\r\n        })\r\n    }\r\n}\r\n4.在home.js 调用import { Theme } from '../../model/theme'\r\n\r\nonLoad: function (options) {\r\n    Theme.getHomeLocationA(data=>{\r\n      this.setData({\r\n        topTheme:data[0]\r\n      })\r\n    })\r\n  },\r\n  \r\n  \r\n分析可知 使用callback函数会出现函数嵌套2.使用Promise1.使用Promise封装Http.jsimport { config } from '../config/config'\r\n\r\nclass Http{\r\n    static request({url, data, method='GRT'}){\r\n        return new Promise((resolve,reject)=>{\r\n            wx.request({\r\n                url: `${config.apiBaseUrl}${url}`,\r\n                data,\r\n                method,\r\n                header: {\r\n                  appkey: config.appkey\r\n                },\r\n                success:res=>{\r\n                  resolve(res.data);\r\n                },\r\n                fail:err=>{\r\n                  reject(err)\r\n                }\r\n            })\r\n        })\r\n    }\r\n}\r\n2.改写theme.jsimport { Http } from '../utils/http';\r\n\r\nclass Theme {\r\n  static  getHomeLocationA(params) {\r\n    return Http.request({\r\n       url: `/themes`,\r\n       data: {\r\n         names: params\r\n       }\r\n     })\r\n   }\r\n}\r\n3.home.jsonLoad: function (options) {\r\n    Theme.getHomeLocationA('t-1').then((data)=>{\r\n      this.setData({\r\n        topTheme:data[0]\r\n      })\r\n    })\r\n}3.终级解决方案 async await为了解决大量复杂不易读的Promise异步的问题，才出现的改良版async必须声明的是一个functionasync声明的函数的返回本质上是一个Promise。await是在等待一个Promise的异步返回1.将小程序内置非promise API转化为Promise请求const promisic = function(func) {\r\n    \r\n    return function(params= {}) { \r\n        \r\n        return new Promise((resolve,reject)=> {\r\n            \r\n            const args = Object.assign(params,{\r\n                success:res=>{\r\n                    resolve(res)\r\n                },\r\n                fail:err=>{\r\n                    reject(err)\r\n                }\r\n            })\r\n            func(args);\r\n        })\r\n    }\r\n    \r\n}\r\n\r\nexport {\r\n    promisic\r\n}\r\n2.改写http.jsimport { config } from '../config/config'\r\nimport { promisic } from './util'\r\n\r\nclass Http {\r\n    static async request({url, data,  method = 'GET'}){\r\n        return await promisic(wx.request)({\r\n            url: `${config.apiBaseUrl}${url}`,\r\n            data,\r\n            method,\r\n            header: {\r\n                appkey: config.appkey\r\n            },\r\n        })\r\n    }\r\n}\r\n\r\nexport {\r\n  Http\r\n}\r\n3.theme.jsimport { Http } from '../utils/http';\r\n\r\nclass Theme {\r\n  static async getHomeLocationA() {\r\n   const res =  await Http.request({\r\n      url: `/themes`,\r\n      data: {\r\n        names: 't-1'\r\n      }\r\n    })\r\n    return res.data\r\n  }\r\n  \r\n}\r\n\r\nexport {\r\n  Theme\r\n}\r\n4.home.jsonLoad: async function (options) {\r\n    const data =  await Theme.getHomeLocationA();\r\n    this.setData({\r\n      topTheme:data[0]\r\n    })\r\n},\r\n使用了 async await 异步函数 变成了同步函数调用"}
{"title": "小程序录音功能实现 ", "author": "Rolan", "pub_time": "2021-3-8 09:27", "content": "前言在开发小程序过程中，有一个实现录音功能并播放录音，将录音上传至服务器的需求。开发过程中使用了Taro框架，录音功能通过 Taro.getRecorderManager() 接口实现，上传录音至服务器通过 Taro.uploadFile 接口实现，播放录音使用 Taro.createInnerAudioContext() 接口实现。下面就详细介绍整个流程是如何实现的。小程序录音首先获取录音管理器模块：const recorderManager = Taro.getRecorderManager();\r\n复制代码在组件挂载完毕时注册录音监听事件：useEffect(() => {\r\n\t// 监听录音开始\r\n    recorderManager.onStart(() => {\r\n      console.log('开始录音');\r\n    });\r\n\t// 监听录音暂停\r\n    recorderManager.onPause(() => {\r\n      console.log('暂停录音');\r\n    });\r\n\t// 监听录音继续\r\n    recorderManager.onResume(() => {\r\n      console.log('继续录音');\r\n    });\r\n\t// 监听录音停止\r\n    recorderManager.onStop((res) => {\r\n      if (res.duration < 1000) {\r\n        Taro.showToast({\r\n          title: '录音时间太短',\r\n          duration: 1000,\r\n          icon: 'none',\r\n        });\r\n      } else {\r\n        console.log('停止录音');\r\n        fileUpload(res.tempFilePath);\r\n      }\r\n    });\r\n\r\n    recorderManager.onError(() => {\r\n      Taro.showToast({\r\n        title: '录音失败！',\r\n        duration: 1000,\r\n        icon: 'none',\r\n      });\r\n    });\r\n  }, []);\r\n复制代码在录音 onStop 的回调函数中，我们可以获取到录音的临时地址 res.tempFilePath ，但这个地址是有有效期限的，所以我们需要将这个录音上传至服务器后台，进行保存，后续才能正常使用。onStop 回调函数中我们调用了 fileUpload 函数实现文件上传， fileUpload 函数的实现如下：const fileUpload = (tempFilePath) => {\r\n    Taro.uploadFile({\r\n      url: 'http://127.0.0.1:7001/record', // 服务器地址\r\n      filePath: tempFilePath,\r\n      name: 'file', // 这个随便填\r\n      header: {\r\n        'content-type': 'multipart/form-data', // 格式必须是这个\r\n        Authorization: Taro.getStorageSync('token'),\r\n      },\r\n      // formData用于传输除文件以外的一些信息\r\n      formData: {\r\n        record_name: '朗诵作品',\r\n        poem_id: poemInfo.id,\r\n        category: poemInfo.category,\r\n      },\r\n      success: (res) => {\r\n        console.log(res);\r\n        const url = res.data;\r\n        playAudio(url); // 播放录音\r\n      },\r\n      fail: (error) => {\r\n        console.log('failed!');\r\n        console.error(error);\r\n      },\r\n    });\r\n  };\r\n复制代码需要注意的点是： header 中的 content-type 必须是 multipart/form-data 。录音事件的处理第一次点击 handleClick 就会触发开始录音，之后会通过当前状态判断是暂停录音还是继续录音。 handleComplete 用于停止录音。const handleClick = () => {\r\n    const curPause = pause;\r\n    setPause(!curPause);\r\n\r\n    if (firstRecord) {\r\n      setfirstRecord(false);\r\n\r\n      recorderManager.start({\r\n        duration: 60000,\r\n        sampleRate: 44100,\r\n        numberOfChannels: 1,\r\n        encodeBitRate: 192000,\r\n        format: 'mp3',\r\n        frameSize: 50,\r\n      });\r\n\r\n      Taro.showToast({\r\n        title: '开始录音',\r\n        duration: 1000,\r\n        icon: 'none',\r\n      });\r\n\r\n    } else {\r\n      if (curPause) {\r\n        recorderManager.pause(); // 暂停录音\r\n      } else {\r\n        recorderManager.resume(); // 继续录音\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleComplete = () => {\r\n    recorderManager.stop(); // 停止录音\r\n  };\r\n复制代码后台实现录音存储并返回录音地址网上大多数博客都没有涉及这块内容，下面就介绍一下如何实现，后台框架我用的是阿里的 egg.js 。文件上传需要配置的东西可见官方文档： egg.js文件上传 。我们这里使用它的第一种 File 模式来实现。因为 egg.js 框架内置了 Multipart 插件，可以解析上传的 multipart/form-data 类型的数据。首先，现在配置文件 config.default.js 中写入 multipart 配置：module.exports = (app) => {\r\n  const config = (exports = {});\r\n  \r\n  ...\r\n\r\n  config.multipart = {\r\n    mode: 'file',\r\n    fileSize: '50mb',\r\n  }\r\n  ...\r\n\r\n  return {\r\n    ...config,\r\n    ...userConfig,\r\n  };\r\n};\r\n复制代码然后，在 router.js 中定义路由：// 提交录音\r\nrouter.post('/record', auth, controller.record.postRecord);\r\n复制代码在 controller 目录下定义 record.js 文件写入如下内容：const Controller = require('egg').Controller;\r\n\r\nclass RecordController extends Controller {\r\n  async postRecord() {\r\n    const { ctx } = this;\r\n    const file = ctx.request.files[0];\r\n    const { record_name, poem_id, category } = ctx.request.body;\r\n    \r\n    const res = await ctx.service.record.postRecord(file, record_name, poem_id, category);\r\n\r\n    ctx.body = res;\r\n  }\r\n}\r\n\r\nmodule.exports = RecordController;\r\n复制代码在 service 目录下定义 record.js 写入具体实现：const Service = require('egg').Service;\r\nlet OSS = require('ali-oss');\r\n\r\nlet aliInfo = {\r\n  // https://help.aliyun.com/document_detail/31837.html\r\n  region: 'oss-cn-guangzhou',\r\n  bucket: 'poem-mini-program',\r\n  accessKeyId: 'xxx', // 填入阿里云的accessKeyId\r\n  accessKeySecret: 'xxx', // 填入阿里云的accessKeySecret\r\n};\r\n\r\nlet client = new OSS(aliInfo);\r\n\r\nclass RecordService extends Service {\r\n  async postRecord(file, record_name, poem_id, category) {\r\n    const url = await this.uploadOSS(file);\r\n    await this.updateRecord(url, record_name, poem_id, category);\r\n\r\n    return url;\r\n  }\r\n\r\n  async uploadOSS(file) {\r\n    const { ctx } = this;\r\n\r\n    let result;\r\n    try {\r\n      // 处理文件，比如上传到云端\r\n      result = await client.put(file.filename, file.filepath);\r\n    } finally {\r\n      // 需要删除临时文件\r\n      await ctx.cleanupRequestFiles();\r\n    }\r\n    return result.url;\r\n  }\r\n\r\n  async updateRecord(url, record_name, poem_id, category) {\r\n    const { ctx } = this;\r\n\r\n    console.log('从ctx.locals中取openid');\r\n    console.log(ctx.locals.openid);\r\n    const openid = ctx.locals.openid;\r\n\r\n    // 将用户信息记录到数据库中\r\n    const res = await ctx.model.Record.create({\r\n      record_name: record_name,\r\n      record_url: url,\r\n      poem_id: poem_id,\r\n      category: category,\r\n      openid: openid,\r\n    });\r\n  }\r\n}\r\nmodule.exports = RecordService;\r\n\r\n复制代码这里需要注意的是：需要注册阿里云账号，并在对象存储那里新建一个存储桶用于存放音频，也就是云存储的实现。需要安装 ali-oss npm包，用于连接阿里云对象存储。在后台接收到前端上传的临时文件后，就会将音频上传至阿里云对象存储中（ client.put ）。播放录音细心的小伙伴可以注意到在使用 Taro.uploadFile 接口上传录音后，在 success 回调中调用了 playAudio 函数用于播放音频，接下来讲一下播放音频是如何实现的。首先，使用 Taro.createInnerAudioContext 获取 audio 的上下文对象：const innerAudioText = Taro.createInnerAudioContext();\r\n复制代码和录音一样，在组件挂载完成时，注册监听事件：useEffect(() => {\r\n    innerAudioText.onPlay(() => {\r\n      console.log('开始播放');\r\n    });\r\n\r\n    innerAudioText.onError((e) => {\r\n      console.log('播放异常');\r\n      console.log(e);\r\n    });\r\n  }, []);\r\n复制代码在录音文件上传成功后，调用 playAudio 方法用于播放录音：const playAudio = (url) => {\r\n  innerAudioText.autoplay = true;\r\n  innerAudioText.src = url;\r\n};\r\n复制代码在 src 被赋予值的时候，录音就会开始播放。总结以上就是整个录音功能和录音播放功能实现的整个流程，如有疑问欢迎大家一起交流。"}
{"title": "如何在微信小程序中使用多色icon ", "author": "Rolan", "pub_time": "2021-3-8 18:12", "content": "背景在微信小程序开发过程中难免会遇到需要使用多色icon的场景，项目中的icon一般存放在iconfont上。iconfont有三种引用方式(参考 https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d8cf4382a&helptype=code )unicode引用：因为是字体，所以不支持多色font-class引用：本质上还是使用的字体，所以多色图标还是不支持的symbol引用：支持多色，使用svg渲染但是微信小程序iconfont并不支持  标签，只支持以background形式渲染.svg文件。基于此，可以使用Node编写脚本，将iconfont项目里的多色icon下载到项目中，生成.arrow-down--colorful {\r\n    background: url('./arrow-down.[hash].svg');\r\n}\r\n\r\n// 或者有CDN的可以\r\n.arrow-down--colorful {\r\n    background: url('//[cdn]/imgs/arrow-down.[hash].svg');\r\n}步骤步骤一、 上传icon至iconfont注意在上传时，带颜色的图标需要有固定后缀来区分。例如普通icon为icon-name，则带颜色的icon需要为icon-name--colorful步骤二、脚本下载icon_**.css使用Node下载项目对应的css脚本，格式为：@font-face {font-family: \"iconfont\";\r\n  src: url('//at.alicdn.com/t/font_**.eot?t=1571134856668');\r\n  src: url('//at.alicdn.com/t/font_385238_**.eot?t=1571134856668#iefix') format('embedded-opentype'),\r\n  url('data:application/x-font-woff2;**') format('woff2'),\r\n  url('//at.alicdn.com/t/font_**.woff?t=**') format('woff'),\r\n  url('//at.alicdn.com/t/font_**.ttf?t=**') format('truetype'),\r\n  url('//at.alicdn.com/t/font_385238_**.svg?t=**#iconfont') format('svg');\r\n}\r\n\r\n.iconfont {\r\n  font-family: \"iconfont\" !important;\r\n  ...\r\n}\r\n\r\n.icon-name:before {\r\n  content: \"\\e600\";\r\n}\r\n\r\n.icon-name--colorful:before {\r\n  content: \"\\e653\";\r\n}删除其中无用的font格式，以及带--colorful的css定义。使用脚本将其格式化为@font-face {font-family: \"iconfont\";\r\n  src: url('data:application/x-font-woff2;**') format('woff2');\r\n}\r\n\r\n.iconfont {\r\n  font-family: \"iconfont\" !important;\r\n  ...\r\n}\r\n\r\n.icon-name:before {\r\n  content: \"\\e600\";\r\n}步骤三、脚本下载icon_**.js使用Node下载项目对应的js脚本，格式为：!function(o){var t,l='<svg><symbol id=\"icon-name” viewBox=\"0 0 1024 1024\"><path …>…path>symbol>symbol id=\"icon-name—colorful” viewBox=\"0 0 1024 1024\"><path …>…path>symbol>svg>’,…}(window);提取出其中带颜色(id以--colorful结尾)的标签，使用xml解析工具，得到\"...\" fill=\"...\" >path><path d=\"...\" fill=\"...\" >path>注意：如果步骤一不能实现按照--colorful区分是否是多色icon，则需要分析各个path的颜色是否一致来区分是否是多色。拼接上  标签function getHash(cont: string) {\r\n  return cryptoNode\r\n    .createHash('md5')\r\n    .update(cont)\r\n    .digest('hex')\r\n    .substr(0, 8);\r\n}步骤四、生成hash值及图片文件最终得到的svgStr的hash值function getHash(cont: string) {\r\n  return cryptoNode\r\n    .createHash('md5')\r\n    .update(cont)\r\n    .digest('hex')\r\n    .substr(0, 8);\r\n}使用hash值是为了避免更换icon但是不换名字的场景生成本地图片文件const hash = getHash(svgStr);\r\nconst fileName = `${iconId}.${hash}.svg`;\r\nconst filePath = `${stylePath}${fileName}`;\r\nfs.writeFileSync(filePath, svgStr);步骤五、将图片上传至CDN并删除本地文件(可选)如果有CDN资源可以将图片上传至CDN，可以节约打包出的项目体积uploadFileToCDN(filePath);\r\n\r\n/** 将pathWithHash文件上传到CDN */\r\nasync function uploadFileToCDN(pathWithHash: string) {\r\n  return new Promise((resolve, reject) => {\r\n    exec(\r\n      `${此处为上传至CDN的命令行}`,\r\n      (error: any, stdout: any, stderr: any) => {\r\n        if (error) {\r\n          console.error(`exec error: ${error}`);\r\n          reject(error);\r\n          return;\r\n        }\r\n        resolve('');\r\n        /** 删除文件 */\r\n        fs.unlinkSync(pathWithHash);\r\n      }\r\n    );\r\n  });\r\n}步骤六、生成完整的css内容并写入本地给步骤二的css文件拼接上带颜色图片的css内容@font-face {font-family: \"iconfont\";\r\n  src: url('data:application/x-font-woff2;**') format('woff2');\r\n}\r\n\r\n.iconfont {\r\n  font-family: \"iconfont\" !important;\r\n  ...\r\n}\r\n\r\n.icon-name:before {\r\n  content: \"\\e600\";\r\n}\r\n\r\n.icon-name--colorful:before {\r\n  background: url('cdnUrl');\r\n}并写入本地fs.writeFileSync(cssPath, fileContent.replace(/\"/g, \"'\"), 'utf8');完整的脚本文件示例const http = require('http');\r\nconst cryptoNode = require('crypto');\r\nconst { exec } = require('child_process');\r\nconst xml2js = require('xml2js');\r\nconst fs = require('fs');\r\nconst config = {\r\n  url: '//at.alicdn.com/t/font_***.js'\r\n};\r\n// 上传至CDN后的前缀\r\nconst cdnPath = '***';\r\n/** 生成的css文件path */\r\nconst cssPath = 'src/styles/iconfont.scss';\r\nconst stylePath = 'src/styles/';\r\n\r\nconst { parseString } = xml2js;\r\n\r\n// 替换iconfont.scss\r\nconst iconfontUrl = config.url.replace(/.*\\/\\//, 'http://');\r\nconst iconfontUrl_css = iconfontUrl.replace('.js', '.css');\r\n\r\nlet fileContent = '';\r\n\r\ntype IPath = {\r\n  $: {\r\n    [key: string]: string;\r\n  };\r\n};\r\n\r\ntype ISymbol = {\r\n  $: {\r\n    id: string;\r\n    viewBox: string;\r\n  };\r\n  path: IPath[];\r\n};\r\n\r\n/** 读取css文件，去掉远程连接 */\r\nasync function generateFile() {\r\n  const cssData = await readRemoteFile(iconfontUrl_css);\r\n  fileContent = cssData.replace(/[^,;]*at.alicdn.com.*\\*\\//g, '');\r\n  // 替换掉woff\r\n  fileContent = fileContent.replace(/[^)]*at.alicdn.com.*\\),/g, ';');\r\n  // 替换掉colorful\r\n  fileContent = fileContent.replace(/[^}]*colorful[^}]*}/g, '');\r\n  // 替换src\r\n  fileContent = fileContent.replace('url(', 'src: url(');\r\n  // 加换行\r\n  fileContent = fileContent.replace('{font-family', '{\\n  font-family');\r\n  // 加换行\r\n  fileContent = fileContent.replace(') format(', ')\\n    format(');\r\n  // 去除最后一个换行\r\n  fileContent = fileContent.replace(/\\n$/, '');\r\n  // 有颜色的图标生成background: url('cdnUrl')\r\n  const fontXml = await fetchXml(iconfontUrl);\r\n  fontXml.svg.symbol.forEach((item: ISymbol) => {\r\n    const iconId = item.$.id;\r\n    if (/colorful/.test(iconId)) {\r\n      let svgStr = '';\r\n      item.path.forEach((path: IPath) => {\r\n        const keys = Object.keys(path.$);\r\n        let attrStr = '';\r\n        keys.forEach(k => {\r\n          attrStr += `${k}=\"${path.$[k]}\" `;\r\n        });\r\n        svgStr = `${svgStr}${attrStr}>`;\r\n      });\r\n      svgStr = `${svgStr}`;\r\n      const hash = getHash(svgStr);\r\n      const fileName = `${iconId}.${hash}.svg`;\r\n      const filePath = `${stylePath}${fileName}`;\r\n      fs.writeFileSync(filePath, svgStr);\r\n      uploadFileToCDN(filePath);\r\n      svgStr = `\\n.${iconId} {\\n  background: url('${cdnPath}${fileName}');\\n}\\n`;\r\n      fileContent += svgStr;\r\n    }\r\n  });\r\n}\r\n\r\nfunction getHash(cont: string) {\r\n  return cryptoNode\r\n    .createHash('md5')\r\n    .update(cont)\r\n    .digest('hex')\r\n    .substr(0, 8);\r\n}\r\n\r\nasync function uploadAndUpdate() {\r\n  // 写文件\r\n  fs.writeFileSync(cssPath, fileContent.replace(/\"/g, \"'\"), 'utf8');\r\n}\r\n\r\ngenerateFile().then(() => {\r\n  uploadAndUpdate();\r\n});\r\n\r\nfunction readRemoteFile(remoteUrl: string): Promise<string> {\r\n  let _data = '';\r\n  return new Promise(resolve => {\r\n    http.get(remoteUrl, (res: any) => {\r\n      //数据\r\n      res.on('data', function(chunk: string) {\r\n        _data += chunk;\r\n      });\r\n\r\n      res.on('end', function() {\r\n        resolve(_data);\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\nasync function fetchXml(\r\n  url: string\r\n): Promise<{\r\n  svg: {\r\n    symbol: ISymbol[];\r\n  };\r\n}> {\r\n  const data = await readRemoteFile(url);\r\n  const matches = String(data).match(/'(.+?)<\\/svg>'/);\r\n  return new Promise((resolve, reject) => {\r\n    parseString(`${matches ? matches[1] : ''}`, (err: any, result: any) => {\r\n      if (err) {\r\n        reject(err);\r\n      } else {\r\n        resolve(result);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/** 将pathWithHash文件上传到CDN */\r\nasync function uploadFileToCDN(pathWithHash: string) {\r\n  return new Promise((resolve, reject) => {\r\n    exec(`${此处为上传至CDN的命令行}`, (error: any, stdout: any, stderr: any) => {\r\n      if (error) {\r\n        console.error(`exec error: ${error}`);\r\n        reject(error);\r\n        return;\r\n      }\r\n      resolve('');\r\n      /** 删除文件 */\r\n      fs.unlinkSync(pathWithHash);\r\n      console.log(`stdout: ${stdout}`);\r\n      console.error(`stderr: ${stderr}`);\r\n    });\r\n  });\r\n}再在 package.json 中的scripts中配置\"icon\": \"ts-node scripts/iconfont.ts\"则每次更新iconfont后，更新对应的url，再运行 npm run icon 即可"}
{"title": "微信小程序----修改data中的数据，页面数据不改变 ", "author": "Rolan", "pub_time": "2021-2-23 18:30", "content": "错误原因由于VUE等框架，我们在逻辑层修改data中的数据后，视图层（页面渲染）会跟着发生变化。当然微信小程序也是实现了相同的功能，那么出现错误的原因是什么？答案：微信小程序的setData()方法。常见赋值方式（习惯）导致的错误Page({\r\n  data: {\r\n    isShow: false\r\n  },\r\n  changeStatus(){\r\n    console.log(this.data.isShow);\r\n    this.data.isShow = true;\r\n    console.log(this.data.isShow);\r\n  }\r\n})\r\n12345678910效果图从上边代码和效果图我们可以看出：1、习惯的赋值方式“=”在逻辑层是起到了作用改变了isShow；2、视图层的并没有发生变化。结论就是常规的“=”赋值方式，在微信小程序中只能改变data中的数据，而不能改变视图层的数据，那么微信小程序怎么解决这个问题的，setData()方法。Page.prototype.setData()setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。setData函数做了哪些事情？将数据从逻辑层发送到视图层----这个刚好解决我们这里出现的错误，视图层数据的改变改变对应的 this.data 的值----同时在逻辑层将data中的值改变Page({\r\n  data: {\r\n    isShow: false,\r\n    isShow1: false\r\n  },\r\n  changeStatus(){\r\n    console.log(this.data.isShow);\r\n    this.data.isShow = true;\r\n    console.log(this.data.isShow);\r\n  },\r\n  changeStatus1() {\r\n    console.log(this.data.isShow);\r\n    this.setData({ isShow:true});\r\n    console.log(this.data.isShow);\r\n  }\r\n})\r\n12345678910111213141516效果图总结：在开发程序的时候，我们要遵循别人的规则来开发，不要被习惯所左右；熟悉开发文档，减少这种习惯错误（不易被发现）；微信小程序开发中，为了减少data和视图层数据表现不一致，全部采用setData方法修改值。setData函数注意事项直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致。单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。请不要把 data 中任何一项的 value 设为 undefined ，否则这一项将不被设置并可能遗留一些潜在问题。"}
{"title": "用uni-app和springboot做出的高效记忆小程序，技术点总结 ", "author": "Rolan", "pub_time": "2021-2-24 09:28", "content": "作为一个和产品经理斗争多年的老后端，终于有一天要考虑产品怎么呈现了，有种苍天饶过谁的感觉。。记得之前吐槽产品最多的话就是：产品逻辑这么复杂，我都理解不了，让用户怎么用。本着这个原则，做出来的东西就是要简单，简单，再简单。看一眼就知道怎么用。所以这个程序本质上就三个点：内容输入艾宾浩斯曲线复习。共有8个阶段，根据笔记创建时间判断是否需要复习。费曼学习法-讲出来开发框架最终选择的开发组合是uni-app + springboot。后端服务就是用自己最熟悉的springboot，同时使用一个非常好用的微信开发包：weixin-java-miniapp在小程序端的框架选择上是费了点时间。由于之前有过一些vue的基础，就想着最好还是用vue来做，那么小程序的vue框架就有个mp-vue。但是这时的想法是，万一之后用户多了，是不是可以搞出ios和android的app呢（梦想是要有的，万一实现了呢）。起码PC页面还是要做一个的。基于这些考虑，就需要一个基于vue开发的多端代码生成框架，最终选择了uni-app。uni-appuni-app官方提供了一个编辑器HBuilderX，但是对于新学一个编辑器感觉没有必要，使用vscode开发也是可以的。这里通过@vue/cli来创建环境，搭建只需要两条命令。创建代码库：vue create -p dcloudio/uni-preset-vue my-project生成微信小程序代码：npm run dev:mp-weixin之后使用微信小程序官方开发工具，打开uni-app生成的代码目录就可以了，dev命令是实时监听修改的，开发体验还不错，上图。登录通过uni-app的统一登录接口，可以获取到微信小程序中的openid等信息，这里发送到后端，用来创建系统用户。后端创建或登录成功后返回一个token，将token缓存到手机中，在之后的每次请求中发送给后端。login() {\r\n    var that = this;\r\n    uni.login({\r\n        provider: 'weixin',\r\n        success: function (res) {\r\n            // 获取用户信息\r\n            uni.getUserInfo({\r\n                provider: 'weixin',\r\n                success: function (infoRes) {\r\n                    that.$request({\r\n                        header: {\r\n                            'X-WX-Code': res.code,\r\n                            'X-WX-Encrypted-Data': infoRes.encryptedData,\r\n                            'X-WX-IV': infoRes.iv,\r\n                        },\r\n                        url: \"/user/wx/login\",\r\n                    }).then(res => {\r\n                        uni.setStorageSync(\"mkey\", res.data.mkey)\r\n                        //保存用户信息\r\n                        uni.setStorageSync('userInfo', res.data.mainUser);\r\n                        that.$goto('/pages/home/home')\r\n                    })\r\n                }\r\n            });\r\n        }\r\n    });\r\n}封装request函数实现加载中效果小程序中请求api会有等待的时间，要在每次请求时加一个等待请求的页面提示，通过封装底层的request，统一加等待效果。export default (params) => {\r\n    //判断用户登录状态\r\n    var mkey = uni.getStorageSync('mkey')\r\n    //加载中页面\r\n    uni.showLoading({\r\n        title: '加载中',\r\n        mask: true\r\n    })\r\n    var loginHeader = {\r\n        'X-MKEY': mkey\r\n    };\r\n\r\n    var header = params.header == undefined ? loginHeader : params.header\r\n    return new Promise((resolve, reject) => {\r\n        uni.request({\r\n            header: header,\r\n            success: ({ data, statusCode, header }) => {\r\n                resolve(data)\r\n            },\r\n            fail: (error) => {\r\n                reject(error)\r\n            },\r\n            complete: () => {\r\n                //关闭加载中\r\n                uni.hideLoading()\r\n            },\r\n            ...params,\r\n            url\r\n        })\r\n    })\r\n}文件上传与存储编辑器中可以通过启用相机或相册，添加图片，需要将图片保存起来。这里使用腾讯云的COS保存图片信息，需要在后端生成cos的带有鉴权信息的上传连接，返回给小程序。然后通过链接直接上传图片到cos，不再通过后端，节省服务器资源。上传成功后，会返回图片的url，这里要注意url是在返回的header里面。useCamera() {\r\n    var that = this;\r\n    uni.chooseImage({\r\n        count: 1, //最多可选图片张数\r\n        success: async function (res) {\r\n            //图片路径\r\n            var filePath = res.tempFilePaths[0];\r\n            //获取腾讯云COS预签名url\r\n            var urlData = await that.request({\r\n                url: \"/resource/cosurl\"\r\n            });\r\n            that.preUrl = urlData.data.preUrl;\r\n            //获取图片信息\r\n            var fileInfo = await uni.getImageInfo({\r\n                src: filePath\r\n            })\r\n            //上传图片\r\n            uni.uploadFile({\r\n                url: that.preUrl,\r\n                filePath: filePath,\r\n                name: \"file\",\r\n                formData: {\r\n                    \"key\": urlData.data.key + \".\" + fileInfo[1].type\r\n                },\r\n                success: (res) => {\r\n                    that.imgUrl = res.header.Location\r\n                }\r\n            });\r\n        }\r\n    });\r\n}没域名没证书怎么提供后端服务？微信小程序中，要求调用后端接口只能使用https，这意味着要购买并备案一个域名，并且要搞到证书才可以提供后端服务。不过现在，腾讯提供了一个云开发的服务，可以在小程序中使用。云开发提供了完整的云函数和云数据库的支持，完全可以满足后端服务的需求。但是看了下文档后，发现代码编写和云数据库操作与我之前常用的springboot+mysql+redis开发体系差距较大，学习成本比较高。但是云函数中调用外部接口却没有https的限制，这就是说完全可以把云函数当成一个网关来使用，通过云函数来调用后端服务。并且云开发现在提供免费额度。云开发的使用步骤注册小程序开发账号后，在开发工具上点击云开发。之后会选择使用哪种方式，直接选择预付费，会提供免费使用的额度。开通后，在开发工具中，创建时选择云开发，也可以在小程序代码同级目录下，新建一个云函数目录。之后在云函数目录中，新建一个云函数：httpApi，写好代码后，直接右键点击就可以上传云函数。云函数只实现一个通用的http请求转发功能，将请求代理到实际的服务器上。代码实现如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n// 这里使用了request-promise\r\nvar rp = require('request-promise');\r\ncloud.init()\r\n// 实际服务的ip地址，可以直接用ip端口\r\nvar host = \"http://xxx.xxx.xxx.xx:8990\";\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  var options = {\r\n    url: host + event.url,\r\n    method: event.method,\r\n    json: true,\r\n    headers: event.header\r\n  }\r\n  // 判断请求类型\r\n  if (event.method != 'post') {\r\n    options.qs = event.data\r\n  } else {\r\n    options.body = event.data\r\n  }\r\n  var res = await rp(options)\r\n    .then(function (res) {\r\n      return res\r\n    })\r\n    .catch(function (err) {\r\n      return err\r\n    });\r\n\r\n  return res;\r\n}小程序代码的改造小程序中，之前的https请求，需要替换为云函数请求。之前已经把请求封装到了request方法中，直接对request方法内部改造就可以。首先在main.js中声明要使用云函数，加入下面的代码。wx.cloud.init({\r\n    // 此处请填入环境 ID, 环境 ID 可打开云控制台查看\r\n    env: '你的环境id',\r\n    traceUser: true,\r\n})修改request为使用云函数export default (params) => {\r\n    //判断用户登录状态\r\n    var mkey = uni.getStorageSync('mkey')\r\n    //加载中页面\r\n    uni.showLoading({\r\n        title: '加载中',\r\n        mask: true\r\n    })\r\n    var loginHeader = {\r\n        'X-MKEY': mkey\r\n    };\r\n\r\n    var header = params.header == undefined ? loginHeader : params.header\r\n    return new Promise((resolve, reject) => {\r\n        //使用云函数\r\n        wx.cloud.callFunction({\r\n            name: 'httpApi',\r\n            data: {\r\n                url: params.url,\r\n                header: header,\r\n                data: params.data,\r\n                method: params.method\r\n            },\r\n            success: function (res) {\r\n                uni.hideLoading();\r\n                var data = res.result\r\n                resolve(data)\r\n            },\r\n            fail: (err) => {\r\n                console.log(\"err\", err)\r\n                uni.hideLoading();\r\n            }\r\n        })\r\n    })\r\n}这样就可以把之前对后端服务的请求，通过云函数代理后，发送给服务器，直接省了域名。通过这篇文章希望可以帮助想要开发小程序的同学少走些弯路。"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "H5跳转小程序，手把手教wx-open-launch-weapp的使用 ", "author": "Rolan", "pub_time": "2021-1-22 13:50", "content": "概述\r\n前段时间来了一个需求，APP分享链接到微信朋友圈，要把用户引流到小程序。所以就需要H5跳到小程序的功能。\r\n\r\n用到的就是微信的开放标签wx-open-launch-weapp，具体的官网文档\r\n\r\n在网上的相关资料实在有点少，而且有些不明不白，下面就是我开发的时候遇到的问题或者的注意事项\r\n\r\n有啥问题大家可以一起讨论，有问题也可以留言~ 希望可以帮助各位可爱的程序员们~~~\r\n前期准备 登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。因为下面配置按钮的时候后端需要返回一个公众号的appid，所以在这个公众号上，需要设置安全域名。然后它会给一个文件，直接放在项目里面\r\n开发 1. 使用微信开放标签 wx-open-launch-weapp\r\n复制代码\r\n//页面中\r\n \"launchBtnHome\"\r\n      class=\"launchBtnHome\"\r\n      style=\"width: 100%; position: fixed; bottom: 45px\"\r\n    >\r\n      <wx-open-launch-weapp\r\n        id=\"launch-btn\"\r\n        ref=\"launchBtn\"\r\n        :username=\"uid\"\r\n        :path=\"`/pages/index/index.html?BId=${BId}\"\r\n      >\r\n        <script type=\"text/wxtag-template\">\r\n          class=\"bottom\" style=\"width:100%;text-align: center;box-sizing: border-box;\">\r\n          <img src=\"https://pic.lian-ou.com/H5/mini/gotoWxIndex.png\" style=\"width:95%\"/>\r\n          \r\n        script>\r\n      wx-open-launch-weapp>\r\n    \r\n复制代码\r\n通过这个标签可以让H5跳转到小程序，只能在微信浏览器上才会有效果，必须是真机才能看到按钮！在浏览器是没有的！但是在微信开发者工具上你可以看到配置（config）时候的输出如果想要实现按钮固定定位，需要在wx-open-launch-weapp外面包一层盒子给上定位（如上），给标签里面的固定定位是没有用的username是每个小程序的原始id 不是appid！ 如：gh_xxxxxxpath是跳转到小程序的哪个路径，在网址后面一定要加上.html 后面再加上小程序需要的参数就好啦  （根据我了解，只能跳转到线上环境的小程序，不能到体验版的小程序）为了方便测试人员测试，我们弄了两个小程序，一个是正式环境，一个是测试环境。按钮的username来控制某一个原始id即可为了让vue解析得到微信的标签 script需要加上这个 type=\"text/wxtag-template\"，里面就是按钮的样式了，必须是行内样式才能有效果\r\n2.js\r\n//引入微信js\r\n mounted() {\r\n    const oScript = document.createElement('script')\r\n    oScript.type = 'text/javascript'\r\n    oScript.src = 'https://res2.wx.qq.com/open/js/jweixin-1.6.0.js'\r\n    oScript.onload = this.wxmini()\r\n    document.body.appendChild(oScript)\r\n },\r\n methods:{\r\n // 获取签名，配置按钮\r\n  wxmini() {\r\n    //openWxmini是调用接口来获取签名等等，都是后端生成的（参数一般都有url也就是页面路径）\r\n      openWxmini({ Url: location.href}).then((res) => {\r\n        const resobj = JSON.parse(res.data)\r\n        wx.config({\r\n          debug: false, // 开启调试模式,调用的所有api的返回值会在客户端console.log出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印\r\n          appId: resobj.appid, // 必填，公众号的唯一标识！！！！公众号的appid\r\n          timestamp: resobj.timestamp, // 必填，生成签名的时间戳\r\n          nonceStr: resobj.noncestr, // 必填，生成签名的随机串\r\n          signature: resobj.signature, // 必填，签名\r\n          jsApiList: [\r\n            'checkJsApi',\r\n            'openLocation',\r\n            'getLocation',\r\n            'closeWindow',\r\n            'scanQRCode',\r\n            'chooseWXPay',\r\n            'chooseImage',\r\n            'uploadImage',\r\n            'previewImage',\r\n            'getLocalImgData'\r\n          ], // 必填，需要使用的JS接口列表\r\n          openTagList: ['wx-open-launch-weapp'] // 可选，需要使用的开放标签列表，例如['wx-open-launch-app']\r\n        })\r\n        //配置成功之后的函数，按钮生成成功\r\n        wx.ready(() => {\r\n          console.log(\"ready\");\r\n        });\r\n        wx.error(function (res) {\r\n        // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名\r\n     \t });\r\n      });\r\n    },\r\n }\r\n \r\n复制代码总结\r\n\r\n虽然配置的时候需要公众号的id，刚开始我以为跳转的小程序需要关联到这个公众号，结果发现根本不需要。\r\n\r\n只要你有一个公众号后端能获取到签名这些，还有一个小程序的原始id，你就能跳到任何的小程序（开放能力确实很强，但是感觉貌似有点不安全呢，也不知道后续微信会不会变）"}
{"title": "小程序父子组件之间的通信以及实时触发子组件数据更新 ", "author": "Rolan", "pub_time": "2021-1-26 09:31", "content": "前言 小程序父子组件直接的通信以及实时触发子组件数据更新\r\nWXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据事件：用于子组件向父组件传递数据，可以传递任意数据。如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。子组件使用observers做数据监听，可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本 2.6.1 开始支持。一、父组件传递给子组件传值\r\n一般情况下如果中的变量没有涉及到更改view试图，不建议使用this.setData()赋值，直接使用this.data.xx = xx；有利于小程序性能，但是和页面有交互的变量必须使用this.setData()，包括给子组件传值二、子组件传值给父组件\r\n三、父组件直接获取子组件数据\r\n这里我们需要给子组件设置一个id，使用this.selectComponent，这里我们只讨论该方法，自定义组件使用方法还有很多，熟读文档还是很有必要的。\r\nthis.selectComponent('#launch')  // 获取的值可以参看下图\r\n复制代码\r\n 这样父组件就拿到了子组件的所有属性，和方法了。想获取子组件什么直接用。看起来很方便四、子组件使用observers做数据监听，根据父组件动态数据实时更新子组件UI\r\n\r\n\r\n// 写法一：可以监听多个属性\r\nobservers: {\r\n    'canvasUrl'(data){  // canvasUrl: 父组件传递过来的值\r\n      console.log('路径变化了')\r\n    }\r\n  },\r\ndata: {\r\n    name: \"partake\",\r\n},\r\n\r\n// 写法二：只监听单个属性\r\nproperties: {\r\n    canvasUrl: {\r\n      type: String,\r\n      value: '',\r\n      observer(nv, ov, path) {\r\n        if (nv) {\r\n          this.setData({\r\n            img: nv\r\n          })\r\n        }\r\n      }\r\n    },\r\n},\r\n复制代码\r\n这种模式下，父组件数据更新，子组件也跟着变化作者：JSBin著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "凹凸技术揭秘 · Taro · 从跨端到开放式跨端跨框架 ", "author": "Rolan", "pub_time": "2021-1-28 09:38", "content": "2017 年 1 月 9 \r\n日凌晨，微信正式推出小程序，为移动端家族增加了新的业务形态和玩法，当大家还在探讨这一新兴平台能做什么的时候，京东率先上线了「京东购物」小程序，随后，更多的电商行业执牛耳者纷纷入驻小程序，从此，承载电商的主战场逐渐从需要自建流量的移动端\r\n APP 向小程序倾斜。小程序的出现，为电商行业的研发带来了巨大的挑战。继微信之后越来越多的头部流量互联网公司纷纷盯上小程序这一蛋糕，相继推出了各自的小程序平台，比如京东、阿里、百度、字节跳动、360\r\n 等等，为了让我们的电商业务能快速移植到这些小程序平台，帮助我们的业务快速拓展渠道，我们开始了新的尝试。我们开始尝试使用技术的手段，探索一种能够统一所有平台的新技术。披荆斩棘——初代架构诞生—用 React 写小程序？前面有提到，为了解决各大小程序平台带来的多端开发的痛点问题，社区先涌现出了 WePy和 mpvue，那我们为什么不直接采用，而要选择“造轮子”呢？在当时的前端界言及前端框架，必离不开依然保持着统治地位的 React[3] 与 Vue[4]，这两个都是非常优秀的前端 UI 框架，而且在网上也经常能看到两个框架的粉丝之间热情交流，碰撞出一些思想火花，让社区异常活跃。而我们团队也在\r\n 2017 年勇敢地抛弃了历史包袱，非常荣幸的引入了 React \r\n技术栈。这让我们团队丢掉了煤油灯，开始通上了电，远离了刀耕火种的前端开发方式。为了解决当时业务环境对极致性能以及低版本 IE \r\n浏览器兼容性的要求，我们还研发出了一款优秀的类 React 框架 Nerv ，并因此对 React 开发思想以及技术栈理解更加深刻。遗憾的是，当时社区并没有一款使用 React 开发小程序的框架。与小程序的开发方式相比，React 明显显得更加现代化、规范化，而且 React 天生组件化更适合我们的业务开发，JSX 也比字符串模板有更强的表现力。那时候我们开始思考，我们能不能用 React 来写小程序？理性地探索通过对比体验 小程序和 React ，我们还是能发现两者之间相似的地方，比如生命周期、数据更新方式以及事件绑定，都具有非常多相似的地方，这为我们使用 React 来小程序提供了非常良好的基础。但是，我们也应该看到小程序和\r\n React \r\n之间的巨大的差异，那就是模板。在 React 中，是使用 JSX 来作为组件的模板的，而小程序则与 Vue 一样，是使用字符串模板的。这是两种完全不一样的东西，也是我们方案探索上的巨大障碍。所以，为了实现使用\r\n React 来写小程序这一目标，我们必须解决两者之间巨大差异的问题。解决差异既然微信不支持 JSX，那我们只需要将 JSX 编译成小程序模板不久可以在微信上运行了吗，这一步可以通过 Babel[7] 来实现。Babel 作为一个 代码编译器 ，能够将 ES6/7/8 的代码编译成 ES5 的代码，其的编译过程主要包含三个阶段：解析过程，在这个过程中进行词法、语法分析，以及语义分析，生成符合 ESTree 标准 [8] 虚拟语法树(AST)转换过程，针对 AST 做出已定义好的操作， babel 的配置文件 .babelrc 中定义的 preset 、 plugin 就是在这一步中执行并改变 AST 的生成过程，将前一步转换好的 AST 生成目标代码的字符串再次回到我们的需求，将 JSX 编译成小程序模板，非常幸运的是 babel 的核心编译器 babylon 是支持对 JSX 语法的解析的，我们可以直接利用它来帮我们构造 AST，而我们需要专注的远程桌面核心就是如何对 AST 进行转换操作，得出我们需要的新 AST，再将新 AST 进行递归遍历，生成小程序的模板。以上仅仅是我们转换规则的冰山一角，JSX 的写法极其灵活多变，我们只能通过穷举的方式，将常用的、React 官方推荐的写法作为转换规则加以支持。初代架构诞生经过我们一次次的探索，我们已经可以将类 React 代码转成可以在小程序环境运行的代码了。但是我们激动之余，冷静下来继续思考，我们还能不能干点别的有意思的事情呢。我们发现，在平常的工作中，我们业务通常有一些“多端”的需求。就是同一个业务或页面，需要同时适配 小程序、H5 、甚至 React Native 。这个时候，你就会发现，差不多的界面和逻辑，你可能需要重复写上好几轮。因此，我们希望希望在解决使用 React 开发微信小程序的同时，还能同时是适配到 H5 端、移动端、以及各平台的小程序。Write once, run anywhere，相信是所有工程师的梦想。但是仔细思考我们又会发现，仅仅将代码按照对应语法规则转换过去后，还远远不够，因为不同端会有自己的原生组件，端能力\r\n API 等等，代码直接转换过去后，并不能直接执行，还需要运行时的适配。因此，我们按照微信小程序的组件库与 API \r\n的标准，在其他端（H5、RN）分别实现了组件库和 API 库。Taro 从立项之初到架构稳定差不多用了三个月左右的时间，从最初的激烈讨论方案，各种思想的碰撞，到方案逐渐成型，进入火热的开发迭代，再到现在的多个平台小程序端、H5 端和 RN 端的顺利支持，Taro 的未来已来。初露锋芒——GitHub 开源—2018 年 6 月 7 日，多端统一开发框架 - Taro 正式开源。作为首个支持以\r\n React 语法写微信小程序并适配到多端的开发框架，Taro 一鸣惊人。开源不到两个月，在 GitHub 上有 6600 多个 \r\nStar，连续数周霸榜 Github Trending；同时已经处理近 300 个 Issue ，还有 100 \r\n多个在等待反馈与优化；在公司内、外主动反馈的使用 Taro 的项目已有十多个。截至 2019 年 12 月 18 日，Taro 已拥有 22254 Stars 和 250 名 Contributors，社区主动提交的开发案例 150+：taro-user-cases[9]，其中不乏多端案例。"}
{"title": "小程序入口构造工具&二维码测试工具 ", "author": "Rolan", "pub_time": "2021-1-29 15:48", "content": "本文将介绍我们小程序中隐藏的两个工具页面。原理虽不复杂，收益却实实在在，或许也能给诸君带来启发。入口构造工具 痛点\r\n\r\nPM&运营 投放链接\r\nPM&运营每次投放新入口时，都需要找FE要页面链接。投放多少链接就要找FE多少次，一方面相互之间的沟通等待会耗掉不少时间，另一方面询问/回复过程会打断对方手头的工作，影响状态。\r\n关键是大多时候这些链接只是需要改个渠道参数，并不涉及结构上的调整，完全可以由PM/运营自行修改。\r\n然而要向所有PM&运营全面科普url构造规则，并没有想象中容易；各种链接构造需求就这样在无形中不断消耗双方的精力。\r\n\r\nFE&QA 开发/测试线下功能\r\n开发/测试没有线上入口的新功能时，经常需要构造一个临时入口供以访问。\r\n可以修改线下接口配置运营位作为访问入口，但是一则运营位有限，二则不能一站式操作；也可以修改代码加个临时入口，但是会污染代码，难保不会带到线上。\r\n这样的情形反复出现也是挺麻烦的。\r\nidea\r\n开发一个专门的入口构造页面，直接提供给PM、运营、FE、QA等各方使用。需要什么链接需要什么入口，直接自助生成，无需一次次反复沟通/构造。效果\r\n通用入口构造：\r\n\r\n如图所示，在入口构造页面中，用户可以直接输入FE提供的url模板并自助修改链接参数，从而获得所需链接。同时支持：\r\n直接打开该链接，进行查看、自测；生成以该链接作为落地链接的分享卡片，从而以落地页的形式打开查看；将该链接复制到剪贴板，供以投放；生成以该链接作为落地链接的二维码，供以投放。\r\n内嵌M页入口构造：\r\n如图所示，内嵌M页的小程序链接构造同样支持类似功能。实现\r\n需求转译\r\n将链接参数以普通用户能理解的形式展现出来，并允许其直接修改，再配以说明文案。以此抹平url构造规则造成的技术门槛。入口构造\r\n页内入口 直接以按钮跳转实现，外部入口 以分享卡片进行模拟。链接输出\r\n使用wx.setClipboardData接口经由剪贴板粘贴使用。初始入口\r\n生成二维码作为入口构造页面自身的初始入口；将工具页面分享出去，保留分享卡片作为初始入口。意义\r\n\r\n效率\r\n入口构造工具使得PM、运营、FE、QA等各方可以自助、高效地构造所需链接/入口，有效节省了重复沟通成本，并在一定程度上提高了开发、测试、投放效率。\r\n\r\n质量\r\n入口构造工具提供的链接生成功能和预览功能可以在一定程度上避免/发现链接拼接失误等人工疏漏，提高整体交付质量。\r\n二维码测试工具痛点\r\n扫描二维码时会直接进入线上版小程序，导致在开发/测试阶段难以对二维码相关功能进行有效的检测和把控。\r\n早期只能先冒险上线，然后进行线上验证，万一有问题再修复再重新上线，导致二维码相关功能调试效率低、上线风险高。\r\n后来开发者工具支持通过二维码编译，管理后台也支持回滚，相对来说，二维码相关功能可控性强了很多；但是对于QA、PM、运营、第三方接入业务等小伙伴来说，二维码的检查、测试还是很无力。idea\r\n开发一个专门的二维码测试页面，支持在当前开发版/体验版/线上版小程序中对二维码进行查看和预览。效果\r\n\r\n\r\n如图所示，在二维码测试页面中，用户可以：\r\n直接查看二维码的编码信息，包括落地链接、参数等；在当前开发版/体验版/线上版小程序中打开二维码落地链接；生成与二维码拥有相同落地链接的当前开发版/体验版/线上版小程序的分享卡片。\r\n实现\r\n\r\n查看二维码信息\r\n使用wx.scanCode接口可以读取二维码信息，包括落地页、参数等。\r\n\r\n在当前开发版/体验版/线上版中打开二维码\r\n使用wx.scanCode接口获取落地链接，使用wx.navigateTo等接口在当前开发版/体验版/线上版小程序中打开目标页面。\r\n\r\n在当前开发版/体验版/线上版中以落地页的形式打开二维码\r\n使用wx.scanCode接口获取落地链接，生成相同落地链接的分享卡片，访问分享卡片以模拟开发版/体验版下扫码打开小程序。\r\n意义\r\n\r\n效率\r\n查看二维码信息可以有效提高相关功能调试效率；\r\n直接在当前开发版/体验版中打开二维码可以有效提高相关功能测试效率，特别是对于QA等非前端人员。\r\n质量\r\n二维码测试工具便于QA在稳定环境充分测试二维码相关功能，从而提高小程序交付质量。\r\n\r\n值得一提的是，这两个工具都是FE自发思考自发实现的，产出时小伙伴们表示“很惊喜”。很多时候，主动去思考、发现、分析、解决痛点，能让你贡献出意料之外的价值，共勉。"}
{"title": "从零开始的微信小程序入门教程(四)，理解小程序事件与冒泡机制 ... ", "author": "Rolan", "pub_time": "2021-2-5 09:27", "content": "我在之前初识WXML与数据绑定两篇文章中，介绍了小程序静态模板与样式相关概念，以及小程序几种常用数据绑定方式，在知道这些知识后，我们可以写一些不算复杂的小程序页面，并能将一些自定义的数据渲染到视图层，这非常棒。那么本文我们将继续介绍小程序中比较重要的事件概念，在学习完事件后，我们可以让小程序具备一定的交互性，那么本文开始。初识小程序事件在小程序中，事件是视图层到逻辑层的通讯方式。比如，我们可以将事件绑定在组件上，当用户操作该组件并触发事件时，事件会将用户行为反馈到逻辑层做处理，也就是对应的执行逻辑层中的事件处理函数。当然，有时候行为反馈不一定是由用户来主动触发，举个生活中的例子，我们在腾讯视频看龙岭迷窟时，当播放到一集结尾，视频会自动播放下一集。将这个例子拿到小程序中来说，video组件便自带了bindended事件，只要视频播放到末尾便会触发该事件，小程序中存在很多由组件自身提供的事件，所以综合来说，小程序中的事件由用户行为反馈事件和组件状态反馈事件两部分组成。微信小程序除了WXML，WXSS文件之外，还提供了WXS脚本语言，为什么突然扯到这个呢，因为从基础库版本2.4.4开始，支持使用WXS响应事件。针对于IOS环境，WXS脚本执行速度是JavaScript的2-20倍，安卓环境没啥差别，大体上来理解，用WXS解决事件问题具备一定优势。由于我们目前暂未了解WXS脚本，所以这里先不做探讨，后面会专门另起一篇文章介绍WXS脚本以及事件相关说明。学习总不能一口吃成胖子，我们一步步来。所以本文还是主要围绕用户行为反馈事件展开讨论，让大家对于事件先有个基本概念。还记得上篇文章中我们接触的第一个点击事件tap吗？我们来重现它，并以此加深对于事件的理解、首先，我们在index.wxml中与index.js中添加如下代码：<button bindtap=\"alert\">bindtap</button>\r\nPage({\r\n  data: {},\r\n  alert: function (event) {\r\n    wx.showToast({\r\n      title: '触发成功', // 标题\r\n      icon: 'success', // 图标类型，默认success\r\n      duration: 1500 // 提示窗停留时间，默认1500ms\r\n    })\r\n  }\r\n})\r\n有上述例子可知，实现一个事件绑定主要分为两步，第一步我们通过bindtap绑定了一个函数alert，第二我们在Page构造器中定义对应的事件处理函数alert。当户点击button组件时，该组件就会在Page中找到对应的事件函数并执行，这便是一次视图到逻辑的通讯过程。需要注意的是，此时我们使用的事件是tap，bind只是一个事件前缀，这就像我们用原生JS事件时所有事件前都得加一个on，比如onclick，onchange，这是同一个道理。除此之外，小程序中的事件支持bindtap与bind:tap两种写法，怎么用都行。<button bindtap=\"alert\">bindtap</button>\r\n<button bind:tap=\"alert\">bindtap</button>\r\n好了，在了解了事件基本概念后，我们来一一介绍小程序中提供的用户交互事件。由于大部分事件均与手指触碰有关，所以为了大家更好的感受各个事件的作用，这里我推荐大家开启小程序调试器的自动预览，如下点击编译并预览后，登陆的微信账号即可预览我们的小程序项目，如果你修改了代码，记得手动点一次编译并预览按钮。常见事件类型注意，这里的事件类型均为用户行为反馈事件，相关说明直接引用官网，有个小规律，小程序中所有事件名均为小写单词拼接，无驼峰拼接情况，这点大家记住。事件类型触发条件touchstart手指触摸动作开始触发touchmove手指触摸后移动触发touchcancel手指触摸动作被打断，如来电提醒，弹窗touchend手指触摸动作结束tap手指触摸后马上离开longpress手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发（与tap同时定义，优先级更高）longtap手指触摸后，超过350ms再离开（推荐使用longpress事件代替）transitionend会在 WXSS transition 或 wx.createAnimation 动画结束后触发animationstart会在一个 WXSS animation 动画开始时触发animationiteration会在一个 WXSS animation 一次迭代结束时触发animationend会在一个 WXSS animation 动画完成时触发现在，我们通过例子一一加深印象，还是使用上文提供的tap事件例子，JS代码不变，我们只需要切换事件名即可：touchstart事件<button bindtouchstart=\"alert\">bindtap</button>\r\n模拟器可能还不是很明显，大家如果通过手机预览可以发现，由于button组件按下去有个背景变灰的渐变，而touchstart事件即是手指触碰到组件的一瞬间方法就被执行，此时按钮还没完全按下去，大家多体验几次。touchmove事件<button bindtouchmove=\"alert\">bindtap</button>\r\n这个就非常明显了，手指按下按钮完全变灰后没执行，一定要我们按住手指并拖动才会触发。touchcancel事件<button bindtouchcancel=\"alert\">bindtap</button>\r\n这个我交大家怎么模拟，在手机上用左手点击button组件不要放开，用右手点击小程序更多功能按钮，此时会弹窗，由于触碰被打断，可以发现事件被顺利触发。其次，左手按钮button，点击关闭小程序，也就是这个按钮，此时小程序会暂时退出并保存在手机后台中，通过后台直接再进入小程序，我们会发现touchcancel事件也会触发。touchend事件<button bindtouchend=\"alert\">bindtap</button>\r\n点击按钮，长按拖动都不会触发，直到手指离开屏幕便会触发。tap事件<button bindtap=\"alert\">bindtap</button>\r\n上文中给了例子，虽然官方说手指触碰后马上离开触发，事实证明我按住按钮十几秒后离开，也会触发，我默认理解为click事件。longpress事件<button bindlongpress=\"alert\">bindtap</button>\r\n快速点击快速松开并不会触发该事件，只有点击超过350ms时才会触发。与动画相关的API，由于涉及到了小程序动画，这里先通过官方动画例子展示API作用，动画怎么玩后面再做介绍（留个坑...）。<view class=\"box {{extraClasses}}\"\r\n  bindtransitionend=\"transitionEnd\"\r\n  bindanimationstart=\"animationStart\"\r\n  bindanimationiteration=\"animationIteration\"\r\n></view>\r\n\r\n<button class=\"btn\" bindtap=\"triggerTransition\">触发CSS渐变</button>\r\n<button class=\"btn\" bindtap=\"triggerAnimation\">触发CSS动画</button>\r\n.box {\r\n  width: 100rpx;\r\n  height: 100rpx;\r\n  margin: 60rpx;\r\n  background: red;\r\n}\r\n.btn {\r\n  margin: 30rpx 60rpx 0;\r\n}\r\n\r\n.box-transition {\r\n  transition: all 0.5s;\r\n}\r\n.box-moved {\r\n  margin-left: 590rpx;\r\n}\r\n\r\n@keyframes box-ani {\r\n  from {margin-left: 60rpx}\r\n  to {margin-left: 590rpx}\r\n}\r\n.box-animation {\r\n  animation: box-ani 1s alternate infinite;\r\n}\r\n\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    extraClasses: '',\r\n  },\r\n  triggerTransition: function () {\r\n    if (this.data.extraClasses == 'box-transition box-moved') {\r\n      this.setData({\r\n        extraClasses: 'box-transition'\r\n      })\r\n    } else {\r\n      this.setData({\r\n        extraClasses: 'box-transition box-moved'\r\n      })\r\n    }\r\n  },\r\n  triggerAnimation: function () {\r\n    this.setData({\r\n      extraClasses: 'box-animation'\r\n    })\r\n  },\r\n  transitionEnd: function () {\r\n    console.log('渐变已结束')\r\n  },\r\n  animationStart: function () {\r\n    console.log('动画已开始')\r\n  },\r\n  animationIteration: function () {\r\n    console.log('动画进行中')\r\n  },\r\n  animationend:function () {\r\n    console.log(\"动画结束\")\r\n  }\r\n})\r\n\r\n事件对象在事件处理函数中，我们能接受到一个event对象参数，该参数包含了当前事件类型，以及当前组件相关信息，具体属性如下：属性类型说明typeString当前绑定的事件类型timeStampInteger页面打开到触发事件所经过的毫秒数targetObject触发事件的组件的一些属性值集合currentTargetObject当前组件的一些属性值集合detailObject额外的信息touchesArray触摸事件，当前停留在屏幕中的触摸点信息的数组changedTouchesArray触摸事件，当前变化的触摸点信息的数组我们来看个例子：<button bindtap=\"alert\" id=\"btn\" data-name=\"听风是风\" data-age=\"27\">bindtap</button>\r\nPage({\r\n  data: {},\r\n  alert: function (event) {\r\n    console.log(event);\r\n  }\r\n})\r\n通过点击按钮任意区域，可以看到控制台输出如下数据：可以看到组件上自定义的data-**数据，组件X轴Y轴偏移量，鼠标点击时的坐标等等信息均有记录。复习事件冒泡与理解小程序事件捕获/冒泡我们知道，在JavaScript事件监听中，分为捕获阶段--目标阶段--冒泡阶段三个部分。考虑到有同学对于该部分知识有遗忘，这里做个简单补充。我们先来看个JavaScript的例子：<div class=\"parent\">\r\n    父\r\n    <div class=\"child\">\r\n        子\r\n    </div>\r\n</div>\r\n.parent{\r\n    width: 200px;\r\n    height: 200px;\r\n    background-color: #bbded6;\r\n}\r\n.child{\r\n    width: 100px;\r\n    height: 100px;\r\n    background-color: rgba(255,80,47,1);\r\n}\r\nvar parent = document.querySelector(\".parent\"),\r\n    child = document.querySelector(\".child\");\r\n\r\nparent.addEventListener(\"click\", function () {\r\n    console.log(\"A\");\r\n}, true);\r\nparent.addEventListener(\"click\", function () {\r\n    console.log(\"B\");\r\n});\r\nchild.addEventListener(\"click\", function () {\r\n    console.log(\"D\");\r\n}, true);\r\nchild.addEventListener(\"click\", function () {\r\n    console.log(\"C\");\r\n}, false);\r\n现在，让我们用鼠标点击红色区域，猜猜会一次输出什么呢？在说答案之前，我们先复习下addEventListener事件监听参数以及含义：element.addEventListener(event,function,useCapture)；\r\n其中event与function为必填，event表示事件类型，function为事件处理函数，而useCapture为选填，它的值为Boolean值。用于指定事件是否在捕获或者冒泡阶段执行，默认为false，即在冒泡阶段执行，反之在捕获阶段执行。而上文的例子中，我们用了一个父盒子包裹了一个子盒子，抛开根元素以及body，捕获与冒泡如下：捕获阶段：parent--child冒泡阶段：child--parent再观察上述例子关于useCapture的值，所以答案是ADCB。OK，花了点时间用于解释JS事件监听的冒泡概念。小程序中事件同样存在捕获与冒泡阶段。比如我们前面所说的bind前缀就表示事件在冒泡阶段执行，而如果我们想事件在捕获阶段执行，可以在bind前面加上capture，即capture-bind表示捕获阶段执行。微信小程序中的捕获与冒泡执行与JS事件监听保持一致，这里引用官方一张图解就一目了然了：<view\r\n  id=\"parent\"\r\n  bind:tap=\"tap1\"\r\n  capture-bind:tap=\"tap2\"\r\n>\r\n  outer view\r\n  <view\r\n    id=\"child\"\r\n    bind:tap=\"tap3\"\r\n    capture-bind:tap=\"tap4\"\r\n  >\r\n    inner view\r\n  </view>\r\n</view>\r\n#parent {\r\n  display: block;\r\n  background-color: #bbded6;\r\n  color: #fff;\r\n}\r\n#child{\r\n  background-color: rgba(255,80,47,1);\r\n}\r\nPage({\r\n  data: {},\r\n  tap1: function (event) {\r\n    console.log('tap1');\r\n  },\r\n  tap2: function (event) {\r\n    console.log('tap2');\r\n  },\r\n  tap3: function (event) {\r\n    console.log('tap3');\r\n  },\r\n  tap4: function (event) {\r\n    console.log('tap4');\r\n  },\r\n})\r\n当我们点击inner view区域，可以看到依次输出如下：为了防止大家疑惑，这里我们先做个知识小结，首先我们前面说了事件支持bind与bind:两种写法，这两种写法都不会阻止冒泡，所以如果大家分别给父子绑定bind事件，点子区域，会先执行子的bind再执行父的bind，毕竟我们没使用capture定义捕获阶段，所以全程就只有冒泡。记住了，bind不会阻止冒泡，添加capture前缀可以响应捕获阶段。那么问题来了，假设我们想阻止冒泡呢？这时候就得将bind替换为catch事件了，catch也支持两种写法catch与catch:，我们来试试下面这个例子：<view\r\n  id=\"parent\"\r\n  catch:tap=\"tap1\"\r\n>\r\n  outer view\r\n  <view\r\n    id=\"child\"\r\n    catch:tap=\"tap3\"\r\n  >\r\n    inner view\r\n  </view>\r\n</view>\r\n现在点击inner view区域，可以发现只输出了tap3，因为冒泡被阻止了。那有同学又要问了，如果我在catch前添加capture前缀会怎么样？怎么样咱们修改例子试试不就知道了，看下方例子：<view\r\n  id=\"parent\"\r\n  bind:tap=\"tap1\"\r\n  capture-catch:tap=\"tap2\"\r\n>\r\n  outer view\r\n  <view\r\n    id=\"child\"\r\n    bind:tap=\"tap3\"\r\n    capture-catch:tap=\"tap4\"\r\n  >\r\n    inner view\r\n  </view>\r\n</view>\r\n我们将capture-bind都改为capture-catch，可以发现不管点击父区域还是子区域，都只会输出一个tap2，这是因为capture-catch会中断捕获阶段和取消冒泡阶段。所以不管点击哪，都是从捕获阶段开始，先捕获到父，然后中断捕获，也不会存在冒泡了，就这么个意思。OK，来个小总结。bind不会阻止冒泡，但如果想抓捕获阶段，可以添加前缀capture，也就是capture-bind。catch会阻止冒泡，如果添加capture前缀，捕获阶段会中断的同时，也会阻止冒泡。最后的最后，官方给了个贴心说明，除了上文中我们列举的用户交互反馈事件之外的其它任意组件状态反馈事件，除非有特殊声明，否则都是非冒泡事件。也就是说，上文给的用户交互反馈事件都是冒泡事件。好了，关于小程序冒泡机制就聊到这。陆 ❀ 总结又花了一天事件整理了小程序事件相关概念，通过本文学习，我想大家对于小程序事件应该有了一个清晰的概念。小程序中的事件分为用户交互反馈事件与组件状态反馈事件（也就是组件自带的事件）。但总体来说，事件就是视图层到逻辑层的通讯方式。除此之外，我们粗略的给出了各个事件的使用区别，帮助大家在特定的需求下能快速定位应该使用哪个事件。最后，我们复习了JS事件监听中捕获与冒泡的基础概念，以此为基础来了解了小程序中的冒泡机制。知道了原来除了bind还有catch事件，以及我们还能使用capture前缀来决定是否阻止捕获与冒泡，这对于日后开发非常有帮助。"}
{"title": "uniapp 开发小程序压缩图片 ", "author": "Rolan", "pub_time": "2021-2-2 15:53", "content": "小程序压缩图片和普通 html 压缩图片思路一致。步骤为：获取图片信息获取canvas 节点创建图片对象压缩图片详细代码/**\r\n * 获取图片信息\r\n * @param {string} imgObj 图片对象path\r\n * @param {function} fn 回调函数\r\n * @returns {ojbect} cbParams \r\n * {\r\n *  height: 722,\r\n *  width: 1366,\r\n *  type: 'png',\r\n *  path: '',\r\n *  orientation: 'up',\r\n *  errMsg: ''\r\n * }\r\n */\r\nfunction getImageObject (src, fn) {\r\n  uni.getImageInfo({\r\n    src: src,\r\n    success (res) {\r\n      fn(res)\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * 压缩图片\r\n * @param {object} img 图片\r\n * @param {function} fn 回调函数\r\n */\r\nfunction compressImg (img, fn) {\r\n  const selectorQuery = uni.createSelectorQuery()\r\n  selectorQuery.select('#canvas')\r\n    .fields({node: true, size: true})\r\n    .exec(res => {\r\n      const canvas = res[0].node\r\n      const ctx = canvas.getContext('2d')\r\n      canvas.height = img.height\r\n      canvas.width = img.width\r\n\r\n      let seal = canvas.createImage();\r\n      seal.src = img.path;\r\n      seal.onload = () => {\r\n        ctx.drawImage(seal, 0, 0, img.width, img.height)\r\n        const url = canvas.toDataURL('image/jpeg', .1)\r\n        fn(url)\r\n      }\r\n    })\r\n}\r\n使用方法getImageObject(list[0].file.path, img => {\r\n  compressImg(img, res => {\r\n    console.log(res);\r\n  })\r\n})\r\n新发现base64字符的长度就是文件尺寸 /**\r\n * 返回图片尺寸\r\n * @param {string} url base64 url\r\n * @param {functino} fn 返回图片尺寸\r\n */\r\nfunction getSize(url, fn) {\r\n  let arr = url.split(',')[1],\r\n    bstr = atob(arr),\r\n    n = bstr.length;\r\n  fn(n)\r\n}\r\n普通压缩图片处理这里假设压缩上传的文件。步骤为：获取 File 文件File && filereader.readAsDataURL(file) 生成 base64 编码创建 Image 对象 && Image.src = base64 url创建 canvas && ctx.drawImage() && canvas.toDataURL(type, encoderOptions)生成 base64 url详细代码  function Compress(obj) {\r\n    this.file = obj.file\r\n    this.fileType = this.file.type // mime type\r\n    this.filename = this.file.name // 文件名\r\n    this.beforeSize = this.file.size\r\n    this.factor = obj.factor // 压缩比例（取值范围：0-1）\r\n  }\r\n\r\n  /**\r\n  * 生成 base64 url\r\n  * @params { File } file 文件\r\n  * @params { function } fn 回调函数\r\n  * */\r\n  function toDataurl(file, fn) {\r\n    const filereader = new FileReader()\r\n    filereader.readAsDataURL(file)\r\n    \r\n    filereader.onload = () => {\r\n      const url = filereader.result\r\n      if (url) {\r\n        // ---------vvvvvvvv 测试句 vvvvvvvv---------\r\n        addImg(url)\r\n        // ---------^^^^^^^ 测试句 ^^^^^^^----------\r\n        fn(url)\r\n        console.info('before: ' + file.size)\r\n      } else {\r\n        console.error('filereader error');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * 创建 image 对象\r\n  * @params { string } base64 url\r\n  * @params { string } filename 文件名\r\n  * @params { function } fn 回调函数\r\n  * */\r\n  function dataurl2File (url, filename, fn) {\r\n    let type = url.split(',')[0].replace(/^.*:(.*);.*$/, '$1'), \r\n          arr = url.split(',')[1], \r\n          bstr = atob(arr), \r\n          n = bstr.length;\r\n    let u8arr = new Uint8Array(n); \r\n  \r\n    while(n --) {\r\n      u8arr[n] = bstr.charCodeAt(n)\r\n    }\r\n\r\n    const file = new File([u8arr], filename, {type: type})\r\n    fn(file)\r\n  }\r\n\r\n  /**\r\n  * 创建 image 对象\r\n  * @params { string } base64 编码\r\n  * @params { function } fn 回调函数\r\n  * */\r\n  function createImg(dataurl, fn) {\r\n    const img = new Image()\r\n    img.src = dataurl\r\n    img.onload = () => {\r\n      fn(img)\r\n    }\r\n  }\r\n\r\n  Compress.prototype = {\r\n    /**\r\n    * 文件生成 base64 url => 创建 image 对象\r\n    * */\r\n    init() {\r\n      toDataurl(this.file, url => {\r\n        createImg(url, img => {\r\n          this.run(img)\r\n        })\r\n      })\r\n    },\r\n    /**\r\n    * 创建 canvas 对象 => 压缩并转化为图片\r\n    * */\r\n    run(img) {\r\n      const canvas = document.createElement('canvas')\r\n      const ctx = canvas.getContext('2d')\r\n      canvas.width = img.width\r\n      canvas.height = img.height\r\n      ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\r\n\r\n      // 此句为实现压缩关键句\r\n      this.newDataurl = canvas.toDataURL('image/jpeg', this.factor)\r\n      // ---------vvvvvvvv 测试句 vvvvvvvv---------\r\n      addImg(this.newDataurl)\r\n      // ---------^^^^^^^ 测试句 ^^^^^^^----------\r\n\r\n      dataurl2File(this.newDataurl, this.filename, (file) => {\r\n        console.info('after: ' + file.size);\r\n\r\n        if (this.beforeSize > file.size) {\r\n          console.info('压缩成功');\r\n        } else {\r\n          console.error('压缩失败');\r\n        }\r\n      })\r\n    }\r\n  }\r\n  /**\r\n  * 对比压缩前后的两个图片\r\n  * */\r\n  function addImg (url) {\r\n    const img = new Image()\r\n    img.src = url\r\n\r\n    document.body.appendChild(img)\r\n  }\r\n使用方法  /**\r\n  * 获取上传文件，创建压缩图片实例，压缩图片\r\n  * */\r\n  function compressFile() {\r\n    const dom = document.querySelector('[name=file]')\r\n\r\n    dom.addEventListener('change', () => {\r\n      const file = dom.files[0]\r\n      const cp = new Compress({\r\n        file: file,\r\n        factor: 0.1\r\n      })\r\n      cp.init()\r\n    })\r\n  }\r\n\r\n  window.onload = function () {\r\n    compressFile()\r\n  }\r\n报错处理1、 小程序 canvas drawImage 报错：TypeError: Failed to execute 'drawImage' 报错解决办法let seal = canvas.createImage();\r\nseal.src = img.path;\r\nseal.onload = () => {\r\n  ctx.drawImage(seal, 0, 0, img.width, img.height)\r\n  // 压缩图片\r\n  const url = canvas.toDataURL('image/jpeg', .1)\r\n}\r\n⚠️：压缩图片时要注意 canvas.toDataURL 的第一个参数是 image/jpeg 或 image/webp 时可以压缩。"}
{"title": "H5跳转微信小程序--踩过的那些坑 ", "author": "Rolan", "pub_time": "2021-2-22 22:17", "content": "需求场景：通过微信官方提供的开放标签，开发者可以使用此标签进行h5网页跳转到微信小程序页面。\r\n步骤\r\n1、绑定域名\r\n\r\n登录微信公众平台,设置JS接口安全域名。\r\n\r\n2、引入JS文件（1.6.0版本）\r\n\r\nres.wx.qq.com/open/js/jwe…\r\n\r\n3、通过config接口注入权限验证配置并申请所需开放标签\r\nwx.config({\r\n  debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印\r\n  appId: '', // 必填，公众号的唯一标识\r\n  timestamp: , // 必填，生成签名的时间戳\r\n  nonceStr: '', // 必填，生成签名的随机串\r\n  signature: '',// 必填，签名\r\n  jsApiList: [], // 必填，需要使用的JS接口列表\r\n  openTagList: ['wx-open-launch-app'] // 可选，需要使用的开放标签列表，例如['wx-open-launch-app']\r\n});\r\n复制代码\r\n4、开放标签\r\n官方demo\r\n<wx-open-launch-weapp\r\n  id=\"launch-btn\"\r\n  username=\"gh_xxxxxxxx\"\r\n  path=\"pages/home/index?user=123&action=abc\"\r\n>\r\n  <template>\r\n    <style>.btn { padding: 12px }</style>\r\n    <button class=\"btn\">打开小程序</button>\r\n  </template>\r\n</wx-open-launch-weapp>\r\n复制代码\r\n注意\r\n\r\npath路径必须带.html(官方没有说明)\r\n官方解释，对于Vue等视图框架，为了避免template标签冲突的问题，可使用<script type=\"text/wxtag-template\"><script>进行代替，来包裹插槽模版和样式。\r\n\r\n改写demo\r\n<wx-open-launch-weapp id=\"launch-btn\"\r\n  username=\"gh_xxxxxxxx\"\r\n  path=\"pages/home/index.html?user=123&action=abc\">\r\n  <script type=\"text/wxtag-template\">\r\n    <div class=\"btn\">\r\n        打开小程序\r\n    </div>\r\n  </script>\r\n</wx-open-launch-weapp>\r\n})\r\n复制代码\r\n自定义样式问题\r\n\r\n在开放标签里引入样式，发现不生效，于是想到了定位的方式，透明度设为0。\r\n\r\n#launch-btn{\r\n  width: 8.9333rem;\r\n  height: 4.56rem;\r\n  position: absolute;\r\n  top:0;\r\n  left:0;\r\n  right:0;\r\n  bottom:0;\r\n  opacity: 0;\r\n}\r\n复制代码\r\n\r\n即使用了定位的方式，发现样式无法撑开,最后用了最老土的方式，用文字撑开。\r\n\r\n<wx-open-launch-weapp id=\"launch-btn\"\r\n  username=\"gh_xxxxxxxx\"\r\n  path=\"pages/home/index.html?user=123&action=abc\">\r\n  <script type=\"text/wxtag-template\">\r\n    <div class=\"btn\">\r\n        打开小程序 打开小程序 打开小程序 打开小程序 打开小程序\r\n    </div>\r\n  </script>\r\n</wx-open-launch-weapp>\r\n})\r\n复制代码\r\n总结\r\n\r\n需要配置JS接口安全域名\r\njssdk的版本1.6.0\r\npath需要加.html\r\n自定义样式问题，这里使用定位的方式，并用文字撑开了高度"}
{"title": "微信的appid、openid、unionid使用总结 ", "author": "Rolan", "pub_time": "2021-2-22 22:24", "content": "最近在开发中涉及到了微信账户绑定的openid变化问题，遇有不解，所以自己想梳理一下这几个id的概念以及他们之间的关系。首先确认openid是会变化的！appid定义：小程序唯一凭证，即 AppID，每个小程序都有自己的一个appid获取途径：可在「微信公众平台 - 设置 - 开发设置」页中获得。（需要已经成为开发者，且帐号没有异常状态）用途：小程序的 AppID 相当于小程序平台的一个身份证，会在很多场景中使用，比如小程序的登录、授权等openid定义：用户在同一个小程序下的唯一表示，即同一个用户在不同的小程序下的openid是不同的获取途径：调用 auth.code2Session 接口，通过code（登录凭证，调用wx.login获取）+appid+appsecret（小程序密钥，获取方式和appid一样）可以换取openid用途：用于在开发者系统中标识用户信息unionid定义：如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。获取途径：1、调用接口 wx.getUserInfo，从解密数据中获取 UnionID2、如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号。开发者可以直接通过 wx.login + code2Session 获取到该用户 UnionID，无须用户再次授权。3、如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。开发者也可以直接通过 wx.login + code2Session 获取到该用户 UnionID ，无须用户再次授权。4、用户在小程序（暂不支持小游戏）中支付完成后，开发者可以直接通过getPaidUnionId接口获取该用户的 UnionID，无需用户授权。注意：本接口仅在用户支付完成后的5分钟内有效，请开发者妥善处理。5、小程序端调用云函数时，如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号，可在云函数中通过 cloud.getWXContext 获取 UnionID。6、小程序端调用云函数时，如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用，也可在云函数中通过 cloud.getWXContext 获取 UnionID。用途：标识同一个微信开放平台下的用户，可用于去重判断openid的变化根据openid的定义，openid是用户在同一个小程序下的唯一表示，即同一个用户在不同的小程序下的openid是不同的，所以当你的appid变化之后，用户的openid就会发生变化，但当你的aapid不变AppSecret时openid是不会变的。如果的appid改变了openid想继续使用的话，可以迁移替换用户的openid，根据新的appid批量将旧的openid替换成新的openid然后再导入数据库，这种方法我只是看到了，并没有实际了解怎么操作，如果有需求的话可以去网上查资料。"}
{"title": "微信小程序swiper实现 句子控app首页滑动卡片 ", "author": "Rolan", "pub_time": "2021-2-9 23:38", "content": "最近看到句子控APP首页的效果很清新，可是发现他的微信小程序端没有实现这个功能，我看了一下难度不大，于是尝试着去实现。实现效果如下：1、定义一个yiyancard自定义组件，在根目录下新建一个components文件夹并在其内部新建一个yiyancard文件夹。 2、在pages文件夹下新建一个home页面3、在home页面的json引入yiyancard组件，并在wxml中使用index.json{\r\n  \"usingComponents\": {\r\n    \"s-yiyancard\": \"../../components/yiyancard/index\"\r\n\r\n  }\r\n}index.wxml<view class=\"container\">\r\n  <s-yiyancard style=\"width:100vw\"> </s-yiyancard>\r\n</view>4、编写yiyancard相关代码index.jsPage({\r\n  lifetimes: {\r\n    attached: function () {\r\n      this.setData({\r\n        cardCur: 0\r\n      })\r\n    },\r\n    detached: function () {\r\n      // 在组件实例被从页面节点树移除时执行\r\n    },\r\n  },\r\n  pageLifetimes: {\r\n    show: function () {\r\n      this.setData({\r\n        cardCur: 0\r\n      })\r\n    },\r\n  },\r\n  data: {\r\n\r\n    cardCur: 0,\r\n    swiperList: [ {id: 0,\r\n      type: 'image',\r\n      yiyan: '没有无聊的人生，只有无聊的人生态度',\r\n      form: '刘瑜',\r\n      tag: \"励志鸡汤句子\",\r\n      liuyannum: \"36\",\r\n      likenum: \"2k\",\r\n\r\n      iflike:\"false\"\r\n\r\n    }, {\r\n      id: 1,\r\n      type: 'image',\r\n      url: 'https://7368-shuyuabn-9gke6t6k962d48ca-1304045188.tcb.qcloud.la/image/1.JPG?sign=6a578b89d06a74141a01b35b26684e04&t=1612536951',\r\n      yiyan: '没有任何一种逃避能得到赞赏，喜欢就去追，饿了就吃饭，管他是失败或是发胖',\r\n      form: '',\r\n      likenum: \"17K\",\r\n      liuyannum: \"126\",\r\n      iflike:\"false\"\r\n\r\n    }, {\r\n      id: 2,\r\n      type: 'image',\r\n      url: 'https://7368-shuyuabn-9gke6t6k962d48ca-1304045188.tcb.qcloud.la/image/2.JPG?sign=42c68e97e5fcd277e42bdc476a94cdb4&t=1612536964',\r\n      yiyan: '万物皆有裂痕，那是光进来的地方',\r\n      tag: \"励志\",\r\n      likenum: \"11K\",\r\n      liuyannum: \"31\",\r\n      iflike:\"false\"\r\n\r\n    }, {\r\n      id: 3,\r\n      type: 'image',\r\n      url: 'https://7368-shuyuabn-9gke6t6k962d48ca-1304045188.tcb.qcloud.la/image/3.JPG?sign=d607ee45937f227f8ae5fba4e9f846f4&t=1612536974',\r\n      yiyan: '不听命于自己者，就要受命于他人',\r\n\r\n      form: '尼采',\r\n      likenum: \"1.0K\",\r\n      liuyannum: \"112\",\r\n      iflike:\"false\"\r\n\r\n    }, {\r\n      id: 4,\r\n      type: 'image',\r\n      url: 'https://7368-shuyuabn-9gke6t6k962d48ca-1304045188.tcb.qcloud.la/image/4.JPG?sign=4c986f27559352bb5d9b42a96851ab22&t=1612536983',\r\n      yiyan: '我从不曾崩溃瓦解，因为我从不曾完好无缺',\r\n\r\n      form: '安迪·沃霍尔',\r\n      likenum: \"967\",\r\n      liuyannum: \"30\",\r\n      iflike:\"false\"\r\n\r\n    }, {\r\n      id: 5,\r\n      type: 'image',\r\n      url: 'https://7368-shuyuabn-9gke6t6k962d48ca-1304045188.tcb.qcloud.la/image/5.JPG?sign=22d43fff1c66594770c1c2b10cd8403c&t=1612537004',\r\n      yiyan: '总有人找你这可小星球，了解你的温柔和璀璨，即使旁边的宇宙再浪漫',\r\n      form: '',\r\n      likenum: \"19k\",\r\n      liuyannum: \"1514\",\r\n      iflike:\"false\"\r\n\r\n    }, {\r\n      id: 5,\r\n      type: 'image',\r\n      url: 'https://7368-shuyuabn-9gke6t6k962d48ca-1304045188.tcb.qcloud.la/image/5.JPG?sign=22d43fff1c66594770c1c2b10cd8403c&t=1612537004',\r\n      yiyan: '总有人找你这可小星球，了解你的温柔和璀璨，即使旁边的宇宙再浪漫',\r\n      form: '',\r\n      likenum: \"11k\",\r\n      liuyannum: \"1136\",\r\n      iflike:\"false\"\r\n\r\n    }, {\r\n      id: 5,\r\n      type: 'image',\r\n      url: 'https://7368-shuyuabn-9gke6t6k962d48ca-1304045188.tcb.qcloud.la/image/5.JPG?sign=22d43fff1c66594770c1c2b10cd8403c&t=1612537004',\r\n      yiyan: '总有人找你这可小星球，了解你的温柔和璀璨，即使旁边的宇宙再浪漫',\r\n      form: '',\r\n      likenum: \"12K\",\r\n      liuyannum: \"306\",\r\n      iflike:\"false\"\r\n\r\n    }, {\r\n      id: 6,\r\n      type: 'image',\r\n\r\n      yiyan: '总有人找你这可小星球，了解你的温柔和璀璨，即使旁边的宇宙再浪漫',\r\n      form: '',\r\n      likenum: \"11K\",\r\n      liuyannum: \"391\",\r\n      iflike:\"false\"\r\n\r\n    }, {\r\n      ifend: true\r\n    }],\r\n  },\r\n  onLoad() {\r\n    this.towerSwiper('swiperList');\r\n    // 初始化towerSwiper 传已有的数组名即可\r\n  },\r\n  DotStyle(e) {\r\n    this.setData({\r\n      DotStyle: e.detail.value\r\n    })\r\n  },\r\n  // cardSwiper\r\n  cardSwiper(e) {\r\n    this.setData({\r\n      cardCur: e.detail.current\r\n    })\r\n  },\r\n  // towerSwiper\r\n  // 初始化towerSwiper\r\n  towerSwiper(name) {\r\n    let list = this.data[name];\r\n    for (let i = 0; i < list.length; i++) {\r\n      list[i].zIndex = parseInt(list.length / 2) + 1 - Math.abs(i - parseInt(list.length / 2))\r\n      list[i].mLeft = i - parseInt(list.length / 2)\r\n    }\r\n    this.setData({\r\n      swiperList: list\r\n    })\r\n  },\r\n  // towerSwiper触摸开始\r\n  towerStart(e) {\r\n    this.setData({\r\n      towerStart: e.touches[0].pageX\r\n    })\r\n  },\r\n  // towerSwiper计算方向\r\n  towerMove(e) {\r\n    this.setData({\r\n      direction: e.touches[0].pageX - this.data.towerStart > 0 ? 'right' : 'left'\r\n    })\r\n  },\r\n  // towerSwiper计算滚动\r\n  towerEnd(e) {\r\n    let direction = this.data.direction;\r\n    let list = this.data.swiperList;\r\n    if (direction == 'right') {\r\n      let mLeft = list[0].mLeft;\r\n      let zIndex = list[0].zIndex;\r\n      for (let i = 1; i < list.length; i++) {\r\n        list[i - 1].mLeft = list[i].mLeft\r\n        list[i - 1].zIndex = list[i].zIndex\r\n      }\r\n      list[list.length - 1].mLeft = mLeft;\r\n      list[list.length - 1].zIndex = zIndex;\r\n      this.setData({\r\n        swiperList: list\r\n      })\r\n    } else {\r\n      let mLeft = list[list.length - 1].mLeft;\r\n      let zIndex = list[list.length - 1].zIndex;\r\n      for (let i = list.length - 1; i > 0; i--) {\r\n        list[i].mLeft = list[i - 1].mLeft\r\n        list[i].zIndex = list[i - 1].zIndex\r\n      }\r\n      list[0].mLeft = mLeft;\r\n      list[0].zIndex = zIndex;\r\n      this.setData({\r\n        swiperList: list\r\n      })\r\n    }\r\n  },\r\n  like: function (event) {\r\n    const that = this\r\n    let likeid = event.currentTarget.dataset.likeid\r\n    var a = `swiperList[${likeid}].iflike`\r\n    var b =`that.data.swiperList[${likeid}].iflike`\r\n    console.log(a)\r\n    console.log(b)\r\n\r\n    if (that.data.swiperList[likeid].iflike=== \"false\") {\r\n      that.setData({\r\n      [a] : \"true\",\r\n      })\r\n    } else if (that.data.swiperList[likeid].iflike=== \"true\") {\r\n      that.setData({\r\n        [a]: \"false\",\r\n      })\r\n    }\r\n    \r\n    console.log(that.data.swiperList[likeid].iflike)\r\n  }\r\n}) index.json{\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}\r\nindex.wxss<swiper class=\"card-swiper \" duration=\"500\" bindchange=\"cardSwiper\">\r\n  <swiper-item wx:for=\"{{swiperList}}\" wx:key class=\"{{cardCur==index?'cur':''}}\">\r\n    <block wx:if=\"{{!item.ifend}}\" >\r\n      <view class=\"swiper-item other \">\r\n      <image src=\"{{item.url}}\" mode=\"aspectFill\" class=\"swiper-img\"></image>\r\n      <view class=\"yiyan-body\">{{item.yiyan}}</view>\r\n      <view wx:if=\"{{item.form}}\" class=\"yiyan-form\">- {{item.form}} -</view>\r\n      <view wx:if=\"{{!item.form}}\" class=\"zhanwei\"></view>\r\n      <view class=\"bottom-box\">\r\n        <view class=\"like juzhong\" bindtap=\"like\" data-likeid=\"{{item.id}}\">\r\n          <block wx:if=\"{{item.iflike =='false'}}\">\r\n            <image class=\"icon-img\" src=\"../../images/icon/xihuan.png\"></image>\r\n          </block>\r\n          <block wx:if=\"{{item.iflike =='true'}}\">\r\n            <image class=\"icon-img\" src=\"../../images/icon/xihuan2.png\"></image>\r\n          </block>\r\n          <view class=\"num\">{{item.likenum}}</view>\r\n        </view>\r\n        <view class=\"liuyan\">\r\n          <image class=\"icon-img2\" src=\"../../images/icon/liuyan.png\"></image>\r\n          <view class=\"num\">{{item.liuyannum}}</view>\r\n        </view>\r\n        <view class=\"biaoqian\">\r\n          <image class=\"icon-img\" src=\"../../images/icon/biaoqian.png\"></image>\r\n        </view>\r\n        <view class=\"zhuanfa\">\r\n          <image class=\"icon-img\" src=\"../../images/icon/zhuanfa.png\"></image>\r\n        </view>\r\n      </view>\r\n    </view>\r\n    </block>\r\n    <block wx:if=\"{{item.ifend}}\">\r\n      <view class=\"swiper-item other juzhong\">\r\n        <view class=\"end-title\">每日十句精选投稿</view>\r\n        <view class=\"end-body\">\r\n          感谢支持，每天都有不同的收获。如果意犹未尽，可以点击底部按钮查看更多推荐\r\n        </view>\r\n        <view class=\"end-bottom\"> 去发现页查看更多推荐</view>\r\n      </view>\r\n    </block>\r\n  </swiper-item>\r\n</swiper>\r\n\r\n index.css/* ==================\r\n         轮播\r\n ==================== */\r\n\r\n.swiper-img {\r\n    height: 35% !important;\r\n\r\n}\r\n\r\n.swiper-item image,\r\n.swiper-item video {\r\n    width: 100%;\r\n    display: block;\r\n    height: 100%;\r\n    margin: 0;\r\n    pointer-events: none;\r\n}\r\n\r\n.card-swiper {\r\n\r\n    height: 85vh !important;\r\n}\r\n\r\n.card-swiper swiper-item {\r\n    width: 610rpx !important;\r\n    left: 70rpx;\r\n    box-sizing: border-box;\r\n    padding: 40rpx 0rpx 70rpx;\r\n    overflow: initial;\r\n}\r\n\r\n.card-swiper swiper-item .swiper-item {\r\n    width: 100%;\r\n    display: block;\r\n    height: 100%;\r\n    border-radius: 10rpx;\r\n    transform: scale(0.9);\r\n    transition: all 0.2s ease-in 0s;\r\n    overflow: hidden;\r\n}\r\n\r\n.card-swiper swiper-item.cur .swiper-item {\r\n    transform: none;\r\n    transition: all 0.2s ease-in 0s;\r\n}\r\n\r\nswiper {\r\n    margin-top: 15rpx !important;\r\n}\r\n\r\n.other {\r\n    position: relative;\r\n\r\n    background-color: #ffffff;\r\n    display: flex;\r\n    /*flex布局方法*/\r\n    flex-direction: column;\r\n    /*垂直布局*/\r\n    align-items: center;\r\n    /*水平方向居中*/\r\n\r\n    box-shadow: 0 6rpx 24rpx rgba(0, 0, 0, 0.08);\r\n    position: relative;\r\n\r\n}\r\n\r\n/* 内容 */\r\n.yiyan-body {\r\n    line-height: 46rpx;\r\n    letter-spacing: 5rpx;\r\n    margin-top: 38rpx;\r\n    font-size: 30rpx;\r\n    width: 90%;\r\n    height: 35%;\r\n    margin-left: 5%;\r\n    color: #3e3e3e;\r\n}\r\n\r\n.yiyan-form {\r\n    position: absolute;\r\n    bottom: 55px;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    font-size: 25rpx;\r\n    color: #999999;\r\n    width: 50%;\r\n    margin-top: 20%;\r\n    margin-left: 25%;\r\n\r\n}\r\n\r\n\r\n/* 底部 */\r\n.bottom-box {\r\n    position: absolute;\r\n    bottom: 0px;\r\n    width: 100%;\r\n    height: 80rpx;\r\n    display: flex;\r\n    flex-direction: row;\r\n}\r\n\r\n.juzhong {\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n\r\n}\r\n\r\n.icon-img {\r\n    width: 30rpx !important;\r\n    height: 30rpx !important;\r\n}\r\n\r\n.icon-img2 {\r\n    width: 30rpx !important;\r\n    height: 30rpx !important;\r\n    /* margin-top: 5rpx !important; */\r\n}\r\n\r\n.like {\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    width: 27%;\r\n}\r\n\r\n.num {\r\n    font-size: smaller;\r\n    margin-top: 3rpx;\r\n    margin-left: 6rpx;\r\n    color: #b4b4b4;\r\n}\r\n\r\n.liuyan {\r\n    width: 27%;\r\n    display: flex;\r\n    justify-content: center;\r\n\r\n    align-items: center;\r\n}\r\n\r\n.biaoqian {\r\n    width: 23%;\r\n    display: flex;\r\n    justify-content: center;\r\n\r\n    align-items: center;\r\n}\r\n\r\n.zhuanfa {\r\n    width: 23%;\r\n    display: flex;\r\n    justify-content: center;\r\n\r\n    align-items: center;\r\n}\r\n/* 最后一页 */\r\n.end-title{\r\n    width: 60%;\r\n    margin-left: 20%;\r\n    font-size: 30rpx;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    margin-top: 100rpx;\r\n    margin-bottom: 100rpx;\r\n}\r\n.end-body{\r\n    width: 80%;\r\n    margin-left: 10%;\r\n    font-size: 27rpx;\r\n    color: #a7a7a7;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    margin-bottom: 40rpx;\r\n}\r\n.end-bottom{\r\n    position: absolute;\r\n    width: 70%;\r\n    left: 15%;\r\n    bottom: 60rpx;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    margin-bottom: 40rpx;\r\n    color: #7b9fcb;\r\n    font-size: 28rpx;\r\n} 编写完以上代码，相关功能就实现了。注意：为了方便以上data中的数据是直接在js中自定义好的。关于动态改变喜欢图标详情参见上一篇随笔。"}
{"title": "微信小程序登录（授权）、获取微信登录凭证code、openid ", "author": "Rolan", "pub_time": "2021-2-22 22:27", "content": "微信登录微信登录面对的问题：怎么获取用户在微信的信息怎么获取小程序用户的唯一身份标志获取openid的方法wx.login() 方法可以获取微信登录凭证code使用code 可以向微信服务器换取微信用户的唯一识别标志openid微信服务器提供的接口地址：https://api.weixin.qq.com/sns/jscode2session?appid=<AppId>&secret=<AppSecret>&js_code=<code>&grant_type=authorization_codeAppId和AppSecret 是为了确保用code换openid的人是当前小程序的开发者AppId 是公开信息，泄露AppId不会带来安全风险AppSecret 是小程序秘钥，不能泄露，如果发现泄露需要到小程序管理平台进行重置。login.wxml<view class=\"cont\">\r\n  <view wx:if=\"{{hasUserInfo}}\">\r\n    {{userInfo.nickName}}您好，欢迎{{type}}\r\n  </view>\r\n  <view wx:else>\r\n    <text>您好，请登录</text>\r\n    <button type=\"primary\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">去授权</button>\r\n  </view>\r\n</view>\r\n123456789login.js// index.js\r\n// 获取应用实例\r\nconst app = getApp()\r\nPage({\r\n  data: {\r\n    userInfo: {},\r\n    hasUserInfo: false,\r\n    type:''\r\n  },\r\n  onLoad() {\r\n    if (app.globalData.userInfo) {\r\n      this.setData({\r\n        userInfo: app.globalData.userInfo,\r\n        hasUserInfo: true\r\n      })\r\n    } else if (this.data.canIUse) {\r\n      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\r\n      // 所以此处加入 callback 以防止这种情况\r\n      app.userInfoReadyCallback = res => {\r\n        this.setData({\r\n          userInfo: res.userInfo,\r\n          hasUserInfo: true\r\n        })\r\n      }\r\n    } else {\r\n      // 在没有 open-type=getUserInfo 版本的兼容处理\r\n      wx.getUserInfo({\r\n        success: res => {\r\n          app.globalData.userInfo = res.userInfo\r\n          this.setData({\r\n            userInfo: res.userInfo,\r\n            hasUserInfo: true\r\n          })\r\n        }\r\n      })\r\n    }\r\n  },\r\n  // 获取用户信息  getUserInfo 固定函数\r\n  getUserInfo({detail:{userInfo}}) {\r\n    console.log(userInfo);\r\n    this.setData({\r\n      userInfo,\r\n      hasUserInfo:true\r\n    })\r\n this.getCode().then(code=>this.getOpenId(code)).then(openid=>this.putOpenid(openid)).then(data=>{\r\n      console.log(data);\r\n    });\r\n  },\r\n  // 获取登录凭证code\r\n  getCode(){\r\n    return new Promise((resolve)=>{\r\n      wx.login({\r\n        success:({code})=>{\r\n          console.log(code);\r\n          resolve(code);\r\n        },\r\n      })\r\n    })\r\n  },\r\n  // 发送code到微信后台获取openId\r\n  getOpenId(code){\r\n    const url = `https://api.weixin.qq.com/sns/jscode2session?appid=你的openid&secret=你的密钥&js_code=${code}&grant_type=authorization_code`;\r\n    // 发起网络请求\r\n    return new Promise((resolve)=>{\r\n      wx.request({\r\n        url,\r\n        success:({data:{openid}})=>{\r\n          resolve(openid);\r\n          console.log(openid);\r\n        }\r\n      })\r\n    })\r\n  },\r\n  // openid传给后端\r\n  putOpenid(openid){\r\n    const data = Object.assign({openid},this.data.userInfo)\r\n    return new Promise((resolve)=>{\r\n      wx.request({\r\n        url: 'http://localhost:8080/',\r\n        method:'POST',\r\n        data,\r\n        success({data}){\r\n          resolve(data)\r\n        }\r\n      })\r\n    })\r\n  }\r\n})"}
{"title": "反编译微信小程序插件及遇到的问题 ", "author": "Rolan", "pub_time": "2021-2-22 22:28", "content": "反编译微信小程序wxapkg文件编译命令# node .\\wuWxapkg.js 文件路径\r\n# node wuWxapkg.js 文件路径\r\n\r\n_-452579966_118.wxapkg\r\nnode .\\wuWxapkg.js E:\\dannisi\\源码\\2\\_-452579966_118.wxapkg\r\nnode wuWxapkg.js E:\\dannisi\\源码\\2\\iclub.wxapkg\r\nE:\\dannisi\\源码\\2\\iclub.wxapkg\r\n\r\n12345678下载依赖npm install esprima\r\n \r\nnpm install css-tree\r\n \r\nnpm install cssbeautify\r\n \r\nnpm install vm2\r\n \r\nnpm install uglify-es\r\n123456789遇到问题解决方案1、Module build failed: Error: Cannot find module ‘escodegen’ （我遇到的)npm i --save-dev escodegen2、 Error: Cannot find module ‘cheerio’（我遇到的)npm install uglify-es --savenpm install esprima --savenpm install css-tree --savenpm install cssbeautify --savenpm install vm2 --savenpm install uglify-es --savenpm install js-beautify --savenpm install escodegen --savenpm install cheerio --save3 未识别的包说明拿到的两个.wxapkg文件里，当前反编译的包不是工程文件夹，再去RE文件管理器看下，是不是还有另一个文件呢！这个.wxapkg里面都是微信的基础包，是无需还原的！！！ 很多博客都没说明这块，害我以为没反编译成功！4 SyntaxError: Unexpected end of input 解决wxss缺失问题解决方案一、修改wxappUnpacker中wuWxss.js部分代码，具体如下：\r\nfunction runVM(name,code){\r\n\r\nlet wxAppCode={},handle={cssFile:name};\r\n\r\nlet gg = new GwxCfg();\r\n\r\nlet tsandbox = {$gwx:GwxCfg.prototype[\"$gwx\"],__mainPageFrameReady__:GwxCfg.prototype[\"$gwx\"],__wxAppCode__:wxAppCode,setCssToHead:cssRebuild.bind(handle)};\r\n\r\nlet vm = new VM({sandbox:tsandbox});\r\n\r\nvm.run(code);\r\n\r\nfor(let name in wxAppCode)if(name.endsWith(\".wxss\")){\r\n\r\nhandle.cssFile=path.resolve(frameName,\"..\",name);\r\n\r\nwxAppCode[name]();\r\n\r\n}\r\n\r\n/*\r\n\r\nlet wxAppCode={},handle={cssFile:name};\r\n\r\nlet vm=new VM({sandbox:Object.assign(new GwxCfg(),{__wxAppCode__:wxAppCode,setCssToHead:cssRebuild.bind(handle)})});\r\n\r\nvm.run(code);\r\n\r\nfor(let name in wxAppCode)if(name.endsWith(\".wxss\")){\r\n\r\nhandle.cssFile=path.resolve(frameName,\"..\",name);\r\n\r\nwxAppCode[name]();\r\n\r\n}*/\r\n\r\n}\r\n1234567891011121314151617181920212223242526272829303132333435363738解决方案二、拿取正常的wxappUnpacker中的wuWxss.js文件，覆盖掉出错的文件"}
{"title": "微信小程序实现常规分包、独立分包和分包预下载 ", "author": "Rolan", "pub_time": "2021-2-22 22:30", "content": "在分包功能出来之前，小程序代码体积不能超过2M，无法满足部分业务需求,尤其是图片较多的商城类小程序，经过微信小程序版本的迭代，分包加载应运而生一、为什么要分包？小程序要求压缩包体积不能大于2M，否则无法编译发布；在实际项目中，体积大于2M时就需要通过分包机制进行发布上传；对小程序进行分包，可以优化小程序首次启动的下载时间，因为分包后主包体积小了，有效提高用户体验；将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载，提高了程序性能；二、分包大小限制在微信开发工具的详情->项目配置中可以看到，如果不采用分包，小程序总大小不能超过2M，如果采取分包，总大小可以达到20M,但主包和单个分包的体积不能超过2M。三、分包形式1、常规分包    1）通过在 app.json subpackages 字段声明项目分包结构，配置如下：2）app.json文件分包的文件可以放在page里面，但我为了分包代码和主包代码在目录上有更好的区分，所以在pages同级新建了packages文件夹单独放分包的代码，名称和目录位置可以根据自己的需要确定。3） 跳转至分包页面，注意路径wx.navigateTo({url: '/packages/familyPackage/pages/familyList/familyList'})4）特点     a、加载小程序时，先加载主包，当需要访问分包页面时才加载分包；     b、分包可以访问主包的内容，包括但不限于文件、数据、图片等内容，可以理解为分包不分家； 2、独立分包    独立分包是小程序中一种特殊类型的分包，可以独立于主包和其他分包运行。一个小程序中可以有多个独立分包。常见应用场景为：临时加的广告也或活动页面1）通过在app.json的subpackages字段中对应的分包配置项中定义independent字段声明对应分包为独立分包{ \"subPackages\": [    {      \"root\": \"packages/familyPackage\",      \"pages\": [        \"pages/familyList/familyList\"      ]    },    {      \"root\": \"packages/intelligentPackage\",      \"pages\": [        \"pages/manual/manual\",        \"pages/automatic/automatic\"      ],      \"independent\": true    }  ],}2）特点    a、 从独立分包中页面进入小程序时，不需要先下载主包（常规分包需要先下载主包）；    b、独立分包不能依赖其他包的内容，可以理解为独立的个体，但 是可以从独立分包页面跳转至主包或常规分包页面的；    c、独立分包中不能定义 App，会造成无法预期的行为；同时独立分包中暂时不支持使用插件；3）注意事项   a、 独立分包运行时， 假设用户没有进入过普通分包或主包内页面，这时 App 未被注册，因此 getApp() 无法获得 App 对象，由于这一限制，开发者无法通过 App 对象实现独立分包和小程序其他部分的全局变量共享。为了在独立分包中满足这一需求，基础库 2.2.4 版本开始 getApp支持 [allowDefault]参数，在 App 未定义时返回一个默认实现。当主包加载，App 被注册时，默认实现中定义的属性会被覆盖合并到真正的 App 中。4）低版本兼容  在低于6.7.2版本的微信中运行时，独立分包视为普通分包处理，不具备独立运行的特性。在兼容模式下，主包中的 app.wxss 可能会对独立分包中的页面产生影响，因此应避免在独立分包页面中使用 app.wxss 中的样式。5）关于 App 生命周期    当从独立分包启动小程序时，主包中 App 的 onLaunch 和首次 onShow 会在从独立分包页面首次进入主包或其他普通分包页面时调用。由于独立分包中无法定义 App，小程序生命周期的监听可以使用 wx.onAppShow，wx.onAppHide 完成。App 上的其他事件可以使用 wx.onError，wx.onPageNotFound 监听。四、分包预下载1）通过在 app.json 增加 preloadRule 配置来控制，packages为数组，即可配置多项， 如果配置为  _APP_ 表示预加载主包，需要预加载主包的场景为从独立分包进入 主包或常规分包   2）效果    3）注意事项同一个分包中的页面享有共同的预下载大小限额 2M，限额会在工具中打包时校验。如，页面 A 和 B 都在同一个分包中，A 中预下载总大小 0.5M 的分包，B中最多只能预下载总大小 1.5M 的分包。4）特点   a、在加载当前包的时候可以设置预下载其他的包；   b、缩短用户等待时间，提高用户体验；五，查看各包大小在项目的详情->基本信息 本地代码中可以看到主包及各个包的大小 全文到这里结束啦！ps：学习成长过程的简单记录，如有不严谨之处，欢迎交流！"}
{"title": "uni-app小程序实战经验 ", "author": "Rolan", "pub_time": "2021-2-23 11:14", "content": "小程序开发现在主要分为原生和框架开发。在对比了相关的优劣势之后个人还是比较倾向于使用框架，主要是开发效率真的比原生高出挺多的，而且在实战下来也没有想象中的那么多的大坑，基本上小程序能够实现的东西uni-app也都能够很好地适配了。下面就来讲一下我开发遇到的一些问题，当做一份uni-app开发小程序的经验总结吧。全局问题小程序分包\r\n微信小程序每个分包的大小是2M，总体积一共不能超过16M。\r\n小程序的分包应该是最首先应该考虑的问题，毕竟谁也不知道项目的功能会不会越加越多，而且uni-app打包到小程序的大小会比原生开发更大，会更容易达到2M的上限。到最后因为一开始没有考虑到分包，而重新更改目录结构再去进行分包的话，工作量会比较大。\r\n\r\nuni-app分包说明\r\nuni-app分包具体配置跨平台问题\r\n\r\n\r\n首先在项目方案刚开始的时候就明确最终是要需要打包到哪几个端的时候，得先去官方文档看看vue语法特性支持表，确认一下自己会会用的语法是在相应端支不支持的，有没有替代方案，以免到时候出bug定位不到问题。\r\n\r\n\r\n其次，很多人可能会在开发的时候引用到一些组件库，比如WeUI、vant等，如果只需要考虑到一个端的话，可以放心引入。如果项目未来有需要实现跨端的可能性的话，建议还是全部自己重新写所需要的的组件。如果不知道如何实现，需要参考的代码的话，可以去uni-app的插件市场看看有没有适合的，把核心代码拿下来再进行修改。项目创建\r\nuni-app的官方文档也写清楚用cli创建和可视化界面创界的区别了。实际开发下来两种方法其实都差不多。官方自带的可视化界面很多快捷语法都是挺方便的，特别最喜欢的是image标签能够直接识别出本地的图片路径。但是那个编辑器的部分操作实在是不那么友好，最终还是用vscode比较香。\r\n最最离谱的一个问题是，官方文档虽然写着说用cli创建的是可以直接更新的，说的是升级编译器执行npm update就可以了，后来隔了好几个月之后尝试更新了一下，想要用一个小程序官方新出的特性。更新之后项目直接就报错不能执行了，报错信息较多且难以解决。这是用uni-app的一个风险点。项目打包\r\n小程序打包发到生产版本的时候，记得要将运行build命令的包进行上传，打包后的体积会小很多。\r\nnpm run build:mp-weixin\r\n复制代码\r\n图标问题\r\n小程序的图标和图片尽量都使用网络地址，在真机上出现过偶现无法加载的情况，是小程序官方写出的bug，在近期才进行修复了。并且用网络地址不占用小程序打包的空间。开发经验汇总\r\n以下开发经验有些是小程序本来就有的，只是这里顺带说一下uni-app的实现。总的来说所有在小程序以wx.开头的API，在uni-app的小程序端都是可以直接用wx.进行使用，前提是当前uni-app的框架是支持当前小程序的特性。\r\n小程序自定义标题栏\r\n如果想要实现类似于下面这种样式的标题栏的话，只要在pages.json设置\r\n{\r\n    \"path\": \"test\",\r\n    \"style\": {\r\n        \"navigationStyle\": \"custom\"\r\n    }\r\n}\r\n复制代码\r\n然后页面中自带的标题栏就会被隐藏掉，然后你就可以把自己的标题栏组件放进页面中，值得一提的是，以下方法可以获取到胶囊的高度和当前距离顶端的位置，就可以解决标题栏的适配问题。\r\nonReady () {\r\n    let menuButtonInfo = uni.getMenuButtonBoundingClientRect()\r\n    let menuHeight = menuButtonInfo.height  \r\n    let menuTop = menuButtonInfo.top\r\n}\r\n\r\n复制代码\r\ntextArea层级问题\r\ntextArea由于小程序的bug问题，textarea的文字会永远在最上层无法被遮挡，如果有其他弹出层的会出现在textarea上方时候（比如弹窗），需要把textArea先清空掉，或者直接用v-if来隐藏掉整个textarea，之后再进行恢复。\r\n图片查看控件\r\n小程序中如果想要点击图片将图片进行预览，实现类似于在微信聊天中的图片查看器效果，需要用到以下的方法：\r\nwx.previewImage({\r\n  current: this.baseImgUrl + this.userData.qrCode, //当前图片地址\r\n  urls: [this.baseImgUrl + this.userData.qrCode], //所有要预览的图片的地址集合 数组形式\r\n  success: function(res) {},\r\n  fail: function(res) {},\r\n  complete: function(res) {}\r\n});\r\n复制代码\r\n获取授权\r\n获取微信登录授权是可以用 wx.authorize直接调用获取微信的登录授权的。但是获取用户信息的wx.authorize({scope: \"scope.userInfo\"})，不会弹出授权窗口。必须使用以下的方法进行调用，静默授权在开发者平台和真机测试的时候，不方便区分没有授权和授权的情况。并且微信官方也说明了这个方法之后会被废弃掉，有较高的使用风险。\r\n<button open-type=\"getUserInfo\" ref=\"authorize\" @getuserinfo=\"getuserinfo\">授权登录</button>\r\n复制代码\r\n一般建议页面中不用重复刷新，只在首次加载的时候会显示的数据放在onload中进行获取，会方便之后授权登录之后，再重新调用一遍页面的onload事件，即可重新执行一遍页面初次加载时会执行的方法\r\n    let page = getCurrentPages().pop()\r\n    let option = page.options\r\n    page.onLoad(option)\r\n复制代码\r\nwebview\r\n小程序的webview是会占满整个宽高的，自动铺满整个页面。支持部分小程序的方法。最重要的是网页内 iframe 的域名也需要配置到域名白名单。\r\nv-html\r\n如果需要富文本在uni-app直接使用v-html即可，小程序端也是支持的，会自动转换为小程序中的标签。如果需要对返回的html字符串添加样式的话，建议使用正则进行匹配。\r\n接口的封装方法\r\n如果需要实现axios的拦截器功能，需要手动对接口的请求方法进行封装，具体也可以操作uni-app的插件市场的封装，以下是实现代码\r\nexport default {\r\n  _this: this,\r\n  config: {\r\n    //主URL\r\n    baseUrl: \"https://api.vc.bilibili.com/link_setting/\",   //只是举个例子\r\n    header: {\r\n      'Content-Type': 'application/json;charset=UTF-8'\r\n    },\r\n    data: {},\r\n    method: \"GET\",\r\n    dataType: \"json\",\r\n    /* responseType如设为json，会对返回的数据做一次 JSON.parse */\r\n    responseType: \"text\",\r\n    success() {},\r\n    fail() {},\r\n    complete() {}\r\n  },\r\n  interceptor: {\r\n    request: (config) => {\r\n      let token =  ''\r\n      if (token) {\r\n        config.header.token = token\r\n      }\r\n      return config\r\n    },\r\n    response: (response) => {\r\n      //在调试的时候此处可以将所有返回都打印一下，方便小程序在真机中查看接口返回\r\n      // console.log(response)\r\n    }\r\n  },\r\n  request(options = {}, iterceptor = {\r\n    request: undefined,\r\n    response: undefined\r\n  }) {\r\n    options.baseUrl = options.baseUrl || this.config.baseUrl\r\n    options.dataType = options.dataType || this.config.dataType\r\n    options.url = options.baseUrl + options.url\r\n    options.data = options.data || {}\r\n    options.method = options.method || this.config.method\r\n    options.header = options.header || this.config.header\r\n\r\n    let interceptorRequest = iterceptor.request || this.interceptor.request\r\n    let interceptorResponse = iterceptor.response || this.interceptor.response\r\n\r\n    return new Promise((resolve, reject) => {\r\n      let _config = null\r\n\r\n      options.complete = (response) => {\r\n        let statusCode = response.statusCode\r\n        response.config = _config\r\n        if (interceptorResponse) {\r\n          interceptorResponse(response)\r\n        }\r\n        if (statusCode === 200) { //成功\r\n          resolve(response);\r\n        } else {\r\n          reject(response)\r\n        }\r\n      }\r\n\r\n      _config = Object.assign({}, this.config, options)\r\n      if (interceptorRequest) {\r\n        interceptorRequest(_config)\r\n      }\r\n      uni.request(_config);\r\n    });\r\n  }\r\n}\r\n\r\n复制代码\r\n下面是对上面封装好的js文件的引用方法\r\nimport http from './interface'\r\n\r\nexport const test = (data) => {\r\n    return http.request({\r\n        url: 'ajax/echo/text?name=uni-app',\r\n        dataType: 'json',\r\n        data,\r\n    })\r\n}\r\n复制代码\r\n地图的注意事项\r\n\r\n\r\n地图的相关界面预览必须要在真机进行，千万不要只在微信开发者工具进行预览然后就以为功能制作完成了。尤其是要在ios和安卓的两个平台都分别预览一下。\r\n\r\n\r\n如果需要监听regionchange的事件然后对地图渲染进行操作的话，记得不要将会改变地图位置的方法放在监听的事件里面。不然会造成死循环。而且很多\r\n\r\n\r\n      regionchange(e) {\r\n        if(e.causedBy==='drag'){\r\n          this.updatedMapCenter()\r\n        }\r\n        if (this.firstLoadMap||e.causedBy==='update'||e.causedBy==='drag') {\r\n          return false\r\n        }\r\n        this.getInstanceMapData()\r\n      },\r\n复制代码\r\n分享的页面\r\n小程序的页面默认是不带分享按钮的，如果点击右上角的分享会变成灰色。如果页面需要开启分享的功能的话，加上这个事件即可\r\n onShareAppMessage(ops){\r\n      console.log(this.selectedApartDetail);\r\n      return {\r\n        title: '点击查看营业部',\r\n        path: /pagesHome/home, //点击分享消息是打开的页面\r\n        imageUrl: '../logo.png'\r\n      }\r\n    }\r\n复制代码\r\n如果需要全局设置的话，可以在App.vue中对所有的页面，通过onAppRoute时间动态给每个页面绑定上onShareAppMessage事件。\r\n wx.onAppRoute(function (res) {\r\n    let pages = getCurrentPages(),\r\n    //获取当前页面的对象\r\n    view = pages[pages.length - 1]\r\n    if (view) {\r\n        let rewriteState = true\r\n        for(let item of notRewirte){\r\n            if(view.route.indexOf(item)!==-1){\r\n                rewriteState = false\r\n                break\r\n            }\r\n        }\r\n\r\n        if (rewriteState) {\r\n            view.onShareAppMessage =  (a,b,c)=>{\r\n                let returnPath = ''\r\n              \r\n                return {\r\n                    title: 'test',\r\n                    path: returnPath,\r\n                    imageUrl: '../../../static/login/log.png'\r\n                };\r\n            }\r\n        }\r\n    }\r\n})\r\n复制代码\r\n将页面保存成图片\r\n很经常会遇到的一个需求是将页面整个页面保存成图片，然后方便用户分享图片至朋友圈对小程序进行引流。主要实现思路是将页面保存为canvas\r\n    <canvas canvas-id=\"myCanvas\" class=\"canvasIs\"/>\r\n    //省略部分代码  \r\n    const ctx = wx.createCanvasContext('myCanvas');\r\n    const grd = ctx.createLinearGradient(0, 0, 0, 0); \r\n    grd.addColorStop(0, '#fff');\r\n    grd.addColorStop(0, '#fff');\r\n    ctx.setFillStyle(grd); //为创建的canvans上下文添充颜色  如果没有设置 fillStyle，默认颜色为 black。\r\n    ctx.fillRect(0, 0, 300, 556);\r\n    ctx.drawImage(this.data.img, 0, 0, 300, 556); \r\n    ctx.setFontSize(50); //字大小\r\n    ctx.setTextAlign('center'); //是否居中显示，参考点画布中线\r\n    ctx.setFillStyle(\"#333333\");\r\n    ctx.fillText(\"需要的文字\", 210, 285);\r\n    ctx.draw();\r\n复制代码\r\n导出图片之前需要先获取小程序的保存图片权限wx.openSetting({//进入小程序授权设置页面\r\n    success(settingdata) {\r\n    console.log(settingdata)\r\n    if (settingdata.authSetting['scope.writePhotosAlbum']) {//用户打开了保存图片授权开关\r\n    wx.saveImageToPhotosAlbum({\r\n        filePath: benUrl,\r\n        success: function (data) {\r\n           //然后操作下面的代码\r\n        },\r\n    })\r\n    }\r\n}\r\n})\r\n\r\n复制代码\r\n然后使用canvasToTempFilePath将canvas导出成图片\r\nwx.canvasToTempFilePath({\r\n    x: 0,\r\n    y: 0,\r\n    width: 300, //画布宽高\r\n    height: 556,\r\n    destWidth: 600, \r\n    destHeight: 1112,\r\n    canvasId: 'myCanvas',\r\n    success: function(res) {\r\n        wx.saveImageToPhotosAlbum({\r\n            filePath: res.tempFilePath,\r\n            success: function(res) {\r\n                //console.log(res);\r\n                wx.hideLoading()\r\n                wx.showToast({\r\n                    title: '保存成功',\r\n                })\r\n            },\r\n            fail: function(err) {\r\n               \r\n            }\r\n        })\r\n    }\r\n})\r\n复制代码"}
{"title": "微信小程序之自定义select下拉选项框组件 ", "author": "Rolan", "pub_time": "2021-2-23 11:23", "content": "微信小程序中没有select下拉选项框，所以只有自定义。自定义的话，可以选择模板的方式，也可以选择组件的方式来创建。这次我选择了组件，这样只需引入组件和添加数据，其它的不用管，就能实现多个地方重复使用了。第一步：创建组件所需的文件我喜欢把共用的内容都放在和pages文件同级的地方，所以有了下面的目录结构 （1） 先创建一个自定义名字的文件夹，例如我上面的Componet（2） 再创建一个select文件夹，然后：右键这个文件夹，新建下面的这个Component。然后输入需要创建的名称，我这里为了方便就取了select的名字。然后就会自动创建4个文件，js、json、wxml、wxss。 第二步：开始配置组件注意：如果通过第一步创建的可直接跳过第二步。（1） 通过第一步创建的组件的文件夹中，已经自动配置好了。只需在引入组件的时候，在引入组件的页面的json文件中配置组件的名称和组件的位置。（2） 如果自己手动创建组件的js、json、wxml、wxss这个文件，那么需要在json文件中填入 \"component\": true 表示自定义组件声明。js文件中也需要写成这种格式： Component({\r\n  properties: {\r\n    // 这里定义了innerText属性，属性值可以在组件使用时指定\r\n    innerText: {\r\n      type: String,\r\n      value: 'default value',\r\n    }\r\n  },\r\n  data: {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  },\r\n  methods: {\r\n    // 这里是一个自定义方法\r\n    customMethod: function(){}\r\n  }\r\n}) 第三步：自定义组件样式及js。注意：这里可以在 app.json 的 pages 中把组件所在的页面放到第一位，这样就能在组件的页面编写代码了，比如我上面的目录结构：就需要写成 \"Componet/select/select\", 后面再是其它的页面。这样方便得多。1. 组件的wxml<view class='com-selectBox'>\r\n    <view class='com-sContent' bindtap='selectToggle'>\r\n        <view class='com-sTxt'>{{nowText}}</view>\r\n        <image src='../../public/img/local/down.png'  class='com-sImg'  animation=\"{{animationData}}\"></image>\r\n    </view>\r\n    <view class='com-sList' wx:if=\"{{selectShow}}\">\r\n        <view wx:for=\"{{propArray}}\" data-index=\"{{index}}\" wx:key='' class='com-sItem' bindtap='setText'>{{item.text}}</view>\r\n    </view>\r\n</view>（1）  animation=\"{{animationData}}\" 这个是下箭头的动画效果（2）  data-index=\"{{index}}\" 这个是当前元素被点击时的索引（3） selectToggle是模仿下拉选项框隐藏和显示的事件。（4） setText是模仿下拉选项框选择子项之后，设置内容的事件。（5） selectShow是表示option选项显示与否2. 组件的wxss.com-selectBox{\r\n    width: 200px;\r\n}\r\n.com-sContent{\r\n    border: 1px solid #e2e2e2;\r\n    background: white;\r\n    font-size: 16px;\r\n    position: relative;\r\n    height: 30px;\r\n    line-height: 30px;\r\n}\r\n.com-sImg{\r\n    position: absolute;\r\n    right: 10px;\r\n    top: 11px;\r\n    width: 16px;\r\n    height: 9px;\r\n    transition: all .3s ease;\r\n}\r\n.com-sTxt{\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n    padding:0 20px 0 6px;\r\n    font-size: 14px;\r\n}\r\n.com-sList{\r\n    background: white;\r\n    width: inherit;\r\n    position: absolute;\r\n    border: 1px solid #e2e2e2;\r\n    border-top: none;\r\n    box-sizing: border-box;\r\n    z-index: 3;\r\n    max-height: 120px;\r\n    overflow: auto;\r\n}\r\n.com-sItem{\r\n    height: 30px;\r\n    line-height: 30px;\r\n    border-top: 1px solid #e2e2e2;\r\n    padding: 0 6px;\r\n    text-align: left;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n    font-size: 14px;\r\n}\r\n.com-sItem:first-child{\r\n    border-top: none;\r\n} 3. 组件的 js// Componet/Componet.js\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n    properties: {\r\n        propArray:{\r\n            type:Array,\r\n        }\r\n    },\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n    data: {\r\n        selectShow:false,//初始option不显示\r\n        nowText:\"请选择\",//初始内容\r\n        animationData:{}//右边箭头的动画\r\n    },\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n    methods: {\r\n　　　//option的显示与否\r\n        selectToggle:function(){\r\n            var nowShow=this.data.selectShow;//获取当前option显示的状态\r\n            //创建动画\r\n            var animation = wx.createAnimation({\r\n                timingFunction:\"ease\"\r\n            })\r\n            this.animation=animation;\r\n            if(nowShow){\r\n                animation.rotate(0).step();\r\n                this.setData({\r\n                    animationData: animation.export()\r\n                })\r\n            }else{\r\n                animation.rotate(180).step();                \r\n                this.setData({\r\n                    animationData: animation.export()\r\n                })\r\n            }\r\n            this.setData({\r\n                selectShow: !nowShow\r\n            })\r\n        },\r\n        //设置内容\r\n        setText:function(e){\r\n            var nowData = this.properties.propArray;//当前option的数据是引入组件的页面传过来的，所以这里获取数据只有通过this.properties\r\n            var nowIdx = e.target.dataset.index;//当前点击的索引\r\n            var nowText = nowData[nowIdx].text;//当前点击的内容\r\n            //再次执行动画，注意这里一定，一定，一定是this.animation来使用动画\r\n            this.animation.rotate(0).step();\r\n            this.setData({\r\n                selectShow: false,\r\n                nowText:nowText,\r\n                animationData: this.animation.export()\r\n            })\r\n        }\r\n    }\r\n})（1） 组件的 properties 属性是对外属性，我理解的是可以当做 data 数据来使用，它是一个含有三个属性的对象，分别是 type 表示属性类型、 value 表示属性初始值、 observer 表示属性值被更改时的响应函数。type 是必填的，其它的可选。如果只有 type，可以写成：属性名：type类型。（2） 组件的 data 和普通页面的data一样，是组件的内部数据，和 properties 一同用于组件的模版渲染。（3） 组件的 method 是专门用于 事件响应函数 和 任意的自定义方法。在这里面获取数据有两种方法：一种是获取data里的数据： this.data.属性名；一种是获取 properties 中的属性值： this.properties.属性名（4） 创建animation动画，作用在通过 true 和 false 切换显示状态的内容上没有过渡、没有过渡、没有过渡。 第四步：引入组件，传入组件所需数据1. 引入前，需要在引入组件的页面的json文件中配置，比如我要在 index.wxml 中引入，那么在 index.json 中我就需要配置：\"usingComponents\": {\r\n    \"Select\": \"/Componet/select/select\"\r\n}（1） Select 是你定义的组件的名称，后面的是组件所在的位置。 /  单斜杠表示根目录，是绝对路径。（2） 如果出现下面这种说没找到路径的，一定是自己填写的路径不对，认真查找。2. 配置好后，就可以引入组件。<Select prop-array='{{selectArray}}'></Select>（1） prop-array 是我自定义的属性名，这个是和组件所在的 js 中properties中的属性是对应的。在 properties 定义的属性中，属性名采用驼峰写法（例如：propArray）；在引入组件的 wxml 中，指定属性值时则对应使用连字符写法（例如：prop-array=\"...\"）。3. 最后就是传入数据了。在引入组件的js的data中，添加：selectArray: [{\r\n    \"id\": \"10\",\r\n    \"text\": \"会计类\"\r\n}, {\r\n    \"id\": \"21\",\r\n    \"text\": \"工程类\"\r\n}] 最终结果： 如果引入两个相同的组件，传入的数据也相同： <Select prop-array='{{selectArray}}'></Select>\r\n<Select prop-array='{{selectArray}}'></Select> 这样的方式组件并不会相互影响，都是独立的。   第五步：获取点击的内容，即组件间的通信效果有了，最关键的是获取选中的内容。这个怎么实现呢，这时候需要组建间通信与事件了。1. 对组件的事件进行监听：<Select prop-array='{{selectArray}}' bind:myget='getDate'></Select>（1） 这里myget是自定义的子组件需要触发的事件名，getDate是引入组件的页面需要获取传过来的数据的自定义的事件名。2. 子组件触发事件因为这里的select组件是点击下拉列表的内容才进行内容的更新，所以这里只需要在下拉列表里添加一个点击事件，而原来已经设置了setText事件。所以只需要在setText函数里面写触发事件就行了。在setText函数的内容里加上：var nowDate={\r\n    id:nowIdx,\r\n    text:nowText\r\n}\r\nthis.triggerEvent('myget', nowDate)（1） 这里的 myget 和 bind:myget ，名称一定要对应。（2） nowDate是需要传回的数据，不一定要弄成对象，想传什么传什么，我这里只是演示而已。我试了一下也可以传函数。。。3. 引入组件的页面的js添加引入组件时，自定义的函数：getDate:function(e){\r\n    console.log(e.detail)\r\n}e的内容为：传过来的值就在detail里面。到此，一个完整的select组件就完成了。  更新：如果要select组件默认显示传入的第一个数据，做法是：（1） 在select组件的wxml页面，在class为com-sTxt的view标签中，原来的 {{ nowText }} 改为 {{ nowText==' ' ? propArray[0].text : nowText }}。（2） 然后在 select 组件 js文件 中原来nowText的值修改为 ‘ ’ 空。（3） 这样的话就表示如果最初nowText为空，就显示传入数据的第一个值，否则就是选中的值"}
{"title": "微信小程序之使用函数防抖与函数节流 ", "author": "Rolan", "pub_time": "2021-2-23 11:47", "content": "函数防抖和函数节流都是老生常谈的问题了。这两种方式都能优化 js 的性能。有些人可能会搞混两个的概念。所以，我以自己的理解，来解释这两个概念的含义。并且列举在小程序中这两个方法的使用。 函数防抖： 英文 debounce 有防反跳的意思，大致就是指防止重复触发。那么，函数防抖，真正的含义是：延迟函数执行。即不管debounce函数触发了多久，只在最后一次触发debounce函数时，才定义setTimeout，到达间隔时间再执行 需要防抖的函数。用处：多用于 input 框 输入时，显示匹配的输入内容的情况。 函数节流： 英文 throttle 有节流阀的意思。大致意思也是 节约触发的频率那么，函数节流，真正的含义是：单位时间n秒内，第一次触发函数并执行，以后 n秒内不管触发多少次，都不执行。直到下一个单位时间n秒，第一次触发函数并执行，这个n秒内不管函数多少次都不执行。用处：多用于页面scroll滚动，或者窗口resize，或者防止按钮重复点击等情况 其实如果只根据 控制函数触发的频率是不好区分这两个概念的。我认为两个函数都能达到防止重复触发的功能。但是函数防抖是 n秒后延迟执行；而函数节流是立马执行，n秒后再立马执行。 在小程序中，函数防抖、函数节流的使用方式：一般都会把这两种方法封装在公用的 js 中：tool.js/*函数节流*/\r\nfunction throttle(fn, interval) {\r\n  var enterTime = 0;//触发的时间\r\n  var gapTime = interval || 300 ;//间隔时间，如果interval不传，则默认300ms\r\n  return function() {\r\n    var context = this;\r\n    var backTime = new Date();//第一次函数return即触发的时间\r\n    if (backTime - enterTime > gapTime) {\r\n      fn.call(context,arguments);\r\n      enterTime = backTime;//赋值给第一次触发的时间，这样就保存了第二次触发的时间\r\n    }\r\n  };\r\n}\r\n\r\n/*函数防抖*/\r\nfunction debounce(fn, interval) {\r\n  var timer;\r\n  var gapTime = interval || 1000;//间隔时间，如果interval不传，则默认1000ms\r\n  return function() {\r\n    clearTimeout(timer);\r\n    var context = this;\r\n    var args = arguments;//保存此处的arguments，因为setTimeout是全局的，arguments不是防抖函数需要的。\r\n    timer = setTimeout(function() {\r\n      fn.call(context,args);\r\n    }, gapTime);\r\n  };\r\n}\r\n\r\nexport default {\r\n  throttle,\r\n  debounce\r\n}; 使用：import tool from \"../../static/js/tool.js\";\r\nPage({\r\n   data:{\r\n    win_scrollTop:0\r\n   },\r\n   onPageScroll: tool.throttle(function(msg){\r\n      this.setData({\r\n        win_scrollTop: msg[0].scrollTop\r\n      });\r\n   }),\r\n   gotoUnlock: tool.debounce(function() {\r\n      this.saveUserInfo();\r\n   }),\r\n   saveUserInfo:function(){\r\n      console.log(111)\r\n   }\r\n}) 上面的两种方式只是精简版的，可能还有某些情况没考虑到，以后遇到了再优化。 函数节流的说明：（1） 第一次执行时，是一定能执行函数的。（2） 然后 n秒内第二次触发的时候，当第一次与第二次间隔不足 设置的间隔时间时，就不会执行。之后第三、第四次触发还是不执行。（3） 直到 n秒之后 有且仅有一次，并且是第一次再次触发函数。 函数防抖的说明：（1） 第一次触发函数时，定义了一个定时器。在 n秒后执行。（2） 然后 函数第二次触发的时候，由于闭包的特性，这时候的 timer已经是第一次触发时的 定时器的标识了。然后直接清除第一次的setTimeout，这时候第一次的setTimeout里面的内容就不会执行了。然后再定义第二次的setTimeout。（3） 然后重复第二个步骤，一直清除，又一直设置。直到函数最后一次触发，定义了最后的一个定时器，并且间隔 n秒 执行。（4） 如果在 最后一个定时器没执行时，函数又触发了，那么又重复第三步。相当于 设置的间隔时间，只是延迟函数执行的时间，而不是间隔多少秒再执行。 到这里，这两个方式的区别就很明显了。函数节流是减少函数的触发频率，而函数防抖则是延迟函数执行，并且不管触发多少次都只执行最后一次。"}
{"title": "微信小程序支付API证书到期后如何续期? ", "author": "木鱼256", "pub_time": "2021-2-23 16:59", "content": "商家在注册微信小程序账号的时候，是需要开通微信支付商户账号的。开通支付账户之后，会有一个API安全证书，但是这个证书是有时间限制的，通常商户API证书默认期限为1年，到期后需要商户续期的操作才能继续使用。但是有很多的人不知道如何操作，下面木鱼小铺小编就来带着大家了解一下微信小程序支付API证书到期后如何续期？　　　　1、登录微信支付商户平台　　　　首先登录微信支付商户平台（https://pay.weixin.qq.com/），用超级管理员扫码登录进入管理后台。　　　　2、证书即将到期　　　　一般API证书到期前30天，微信支付商户平台会以短信及邮件发送，来提醒商户执行续期操作。操作方法如下：　　　　登录微信支付商户平台后，点击顶部导航栏【账户中心】->左边导航栏【API安全】页面会有提示续期操作，点击【马上续期】即可完成续期操作。操作界面如下图：　　　　3、证书已过期　　　　有的时候，商家比较忙，没有注意到短信以及邮件的提醒，导致原有证书已过期的情况，那么要怎么操作呢？证书过期的续期操作方式如下：　　　　登录商户平台后，点击顶部导航栏【账户中心】->左边导航栏【API安全】，页面会有提示证书已过期，点击【更改证书】进入证书更改流程。更改成功后新的证书会生效，新证书有效期为一年。操作界面如下图：　　　　4、操作证书未安装：　　　　还有一种情况，就是操作证书未安装，这个时候进行续期，就会有提示，如提示操作证书未安装，那么就需要商家请先安装操作证书。安装完成后，再返回【账户中心】->【账户设置】->【API安全】完成证书续期，如下图。　　 　　微信小程序API证书到期后如何续期的内容就介绍到这，希望可以帮助到大家。"}
{"title": "微信小程序运营者身份如何解除绑定 ", "author": "木鱼256", "pub_time": "2021-2-23 17:00", "content": "很多的人在运营微信公众平台的时候，会直接绑定自己的微信，但是想要解除绑定关系的时候，却不知如何下手，对此小编做一个关于微信小程序运营者身份如何解除绑定的教程，希望可以帮助到大家。　　　　1.打开登录微信公众平台，在左侧找到【安全中心】，点击进入。　　　　2.选择【管理员微信号】这一项，然后点击【详情】进入。如图所示：　　　　3.在【运营者微信号】一栏找到对应人的微信号，后面会有一个【解除绑定】按钮，点击解除绑定。如图所示：　　　　点解解除绑定的时候，会弹出一个二维码，这个时候需要用管理者的微信扫描二维码确认，这样就可以解除绑定了。　　　　一般只要按照上述的流程步骤来，顺利的话，就可以解绑，如果存在其他问题的话，就需要按照问题的引导指示来操作，或者找微信公众平台去解决了。以上就是关于微信小程序微信小程序运营者身份如何解除绑定的介绍，希望可以帮助到大家。"}
{"title": "小程序获取用户手机号信息 ", "author": "Rolan", "pub_time": "2021-2-23 17:24", "content": "小程序获取用户信息和手机号必须要用户主动授权，所以这里需要有个按钮提示用户触发页面样子： 展示效果：  点击拒绝： 点击确定跳转到过来时的页面wxml页面：\r\n<view class=\"no-login\">\r\n  \r\n  <view class=\"page\">\r\n    <view class=\"hd\">\r\n      <image class=\"logo\" src=\"../../../static/images/assets/logo.png\">image>\r\n    view>\r\n    <view class=\"bd\">\r\n      <view class=\"top_line\">view>\r\n      \r\n      <text class=\"s_name\">为了保护你的隐私，请登录后查看text>\r\n    view>\r\n    <view class=\"btn spacing\">\r\n      \r\n      <button open-type=\"getPhoneNumber\" class=\"weui_btn weui_btn_primary\"\r\n        bindgetphonenumber=\"bindPhoneNumber\">登录查看button>\r\n      \r\n    view>\r\n  view>\r\nview>wxss:.no-login .page{\r\n  margin-top: 100rpx;\r\n}\r\n\r\n.no-login .hd {\r\n  display: flex;\r\n  width: 100%;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n}\r\n\r\n.no-login .hd .logo {\r\n  width: 170rpx;\r\n  height: 170rpx;\r\n  margin-top: 40rpx;\r\n  border-radius: 50%;\r\n}\r\n\r\n.no-login .hd .title {\r\n  text-align: center;\r\n  font-size: 36rpx;\r\n  color: #000;\r\n}\r\n\r\n.no-login .bd {\r\n  width: 100%;\r\n  padding: 50rpx;\r\n}\r\n\r\n.no-login .bd .top_line {\r\n  width: 100%;\r\n  height: 2rpx;\r\n  background: #ccc;\r\n  margin-top: 20rpx;\r\n  margin-bottom: 50rpx;\r\n}\r\n\r\n.no-login .bd .m_name {\r\n  display: block;\r\n  font-size: 36rpx;\r\n  color: #000;\r\n}\r\n\r\n.no-login .bd .s_name {\r\n  margin-top: 25rpx;\r\n  display: block;\r\n  font-size: 34rpx;\r\n  color: #8a8a8a;\r\n  text-align: center;\r\n}\r\n\r\n.no-login .btn {\r\n  padding: 120rpx 50rpx 0;\r\n}\r\n\r\n.no-login .weui_btn_primary {\r\n  background-color: #5986ED;\r\n}\r\n\r\n.no-login .weui_btn {\r\n  position: relative;\r\n  display: block;\r\n  margin-left: auto;\r\n  margin-right: auto;\r\n  padding-left: 14px;\r\n  padding-right: 14px;\r\n  box-sizing: border-box;\r\n  font-size: 18px;\r\n  text-align: center;\r\n  text-decoration: none;\r\n  color: #fff;\r\n  line-height: 2.33333333;\r\n  border-radius: 5px;\r\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\r\n  overflow: hidden;\r\n}\r\n\r\n.no-login .weui_btn:after {\r\n  content: \" \";\r\n  width: 200%;\r\n  height: 200%;\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  border: 1px solid rgba(0, 0, 0, 0.2);\r\n  -webkit-transform: scale(0.5);\r\n  -ms-transform: scale(0.5);\r\n  transform: scale(0.5);\r\n  -webkit-transform-origin: 0 0;\r\n  -ms-transform-origin: 0 0;\r\n  transform-origin: 0 0;\r\n  box-sizing: border-box;\r\n  border-radius: 10px;\r\n}js:const util = require('../../../utils/util.js');\r\nconst api = require('../../../config/api.js');\r\nComponent({\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  globalData: {\r\n    appid: 'wx5123af152604563', //appid需自己提供，此处的appid我随机编写\r\n    secret: 'c42b59b15d7b7fc3d53c746f7369m4cf', //secret需自己提供，此处的secret我随机编写\r\n  },\r\n  data: {\r\n    canIUse: wx.canIUse('button.open-type.getPhoneNumber'),\r\n    navUrl: '',\r\n    code: '',\r\n    sessionkey: '',\r\n    openid: '',\r\n    appid: 'wx5123af152604563', //appid需自己提供，此处的appid我随机编写\r\n    secret: 'c42b59b15d7b7fc3d53c746f7369m4cf', //secret需自己提供，此处的secret我随机编写\r\n\r\n    isLogin: true, // 显示当前组件\r\n  },\r\n  /**\r\n   * 组件的属性列表 \r\n   */\r\n  properties: {\r\n    isLogin: { // 接收传递过来的是否显示\r\n      type: Boolean,\r\n      value: true,\r\n    },\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    getToken: function(encryptedData,iv,sessionkey){\r\n      let that = this;\r\n\r\n      //let openid = that.data.openid\r\n      console.log('sessionkey：' + sessionkey)\r\n      wx.showLoading({\r\n        title: '加载中',\r\n      })\r\n\r\n      util.request(api.AuthLoginByWeixin, {\r\n        sEncryptedData: encryptedData,\r\n        sIv: iv,\r\n        sSessionkey: sessionkey,\r\n        // openid:openid,\r\n      }, 'POST', 'application/json').then(res => {\r\n        console.log(res)\r\n        if (res.code === \"SUCCESS\") {\r\n          wx.hideLoading();\r\n          //存储用户信息\r\n          wx.setStorageSync('token', res.token)\r\n          console.log(wx.getStorageSync('token'))\r\n\r\n          if (that.data.navUrl && (that.data.navUrl == '/pages/index/index' || that.data.navUrl == '/pages/cart/cart' || that.data.navUrl == \"/pages/ucenter/index/index\")) {\r\n            that.setData({\r\n              isLogin: !that.properties.isLogin\r\n            })\r\n\r\n            // 将数据传递过去\r\n            this.triggerEvent(\"onBindAuthorize\", {\r\n              \"isLogin\": this.data.isLogin,\r\n            })\r\n\r\n          } else if (that.data.navUrl) {\r\n            wx.redirectTo({\r\n              url: that.data.navUrl,\r\n            })\r\n          }\r\n        }\r\n      });\r\n    },\r\n    \r\n    login(encryptedData,iv) {\r\n      let that = this;\r\n      wx.login({\r\n        success: function (res) {\r\n          console.log(\"登陆成功：\")\r\n          console.log(res)\r\n          if (res.code) {\r\n            util.request(api.Code2Session+'?code='+res.code).then(function (res) {\r\n              if (res.code === \"SUCCESS\") {\r\n                console.log('openid和sessionkey:' + res)\r\n                wx.setStorageSync('openid', res.data.openid); //存储openid\r\n                \r\n                that.setData({\r\n                  sessionkey: res.data.session_key,\r\n                  openid: res.data.openid\r\n                })\r\n\r\n                that.getToken(encryptedData,iv,res.data.session_key)\r\n              }\r\n            })\r\n          }\r\n        }\r\n      })\r\n    },\r\n\r\n    // 绑定手机号\r\n    bindPhoneNumber: function (e) {\r\n      let that = this;\r\n\r\n      console.log('绑定手机号信息:')\r\n      console.log(e.detail)\r\n\r\n      //登录远程服务器\r\n      if (e.detail.errMsg == 'getPhoneNumber:ok') {\r\n        //用户按了允许授权按钮\r\n        let encryptedData = e.detail.encryptedData // 包括敏感数据在内的完整用户信息的加密数据\r\n        let iv = e.detail.iv // 加密算法的初始向量\r\n\r\n        //登录验证\r\n        wx.checkSession({\r\n          success(){\r\n            that.getToken(encryptedData,iv,that.data.sessionkey)\r\n          },\r\n          fail() {\r\n            // session_key 已经失效，需要重新执行登录流程\r\n            that.login(encryptedData,iv)\r\n          }\r\n        })\r\n      } else {\r\n        //用户按了拒绝按钮\r\n        wx.showModal({\r\n          title: '警告',\r\n          content: '您点击了拒绝授权，将无法继续下一步操作，请授权之后再进入!!!',\r\n          showCancel: false,\r\n          confirmText: '返回授权',\r\n          success: function (res) {\r\n            if (res.confirm) {\r\n              console.log('用户点击了“返回授权”');\r\n            }\r\n          }\r\n        });\r\n      }\r\n    },\r\n\r\n  },\r\n\r\n  created() {\r\n    let that = this;\r\n    console.log('登陆页navuRL：' + wx.getStorageSync('navUrl'))\r\n    // that.login.bind(this)();\r\n\r\n    wx.login({\r\n      success: function (res) {\r\n        console.log(\"登陆成功：\")\r\n        console.log(res)\r\n        if (res.code) {\r\n          util.request(api.Code2Session+'?code='+res.code).then(function (res) {\r\n            if (res.code === \"SUCCESS\") {\r\n              console.log('openid和sessionkey:' + res)\r\n              wx.setStorageSync('openid', res.data.openid); //存储openid\r\n              \r\n              that.setData({\r\n                sessionkey: res.data.session_key,\r\n                openid: res.data.openid\r\n              })\r\n            }\r\n          })\r\n        }\r\n      }\r\n    })\r\n\r\n    if (wx.getStorageSync(\"navUrl\")) {\r\n      that.setData({\r\n        navUrl: '/' + wx.getStorageSync(\"navUrl\")\r\n      })\r\n    } else {\r\n      that.setData({\r\n        navUrl: '/pages/index/index'\r\n      })\r\n    }\r\n    if (wx.getStorageSync(\"token\")) {\r\n      if (that.data.navUrl && that.data.navUrl == '/pages/index/index' && that.data.navUrl == '/pages/cart/cart' && that.data.navUrl == '/pages/ucenter/index/index') {\r\n        wx.navigateTo({\r\n          url: that.data.navUrl,\r\n        })\r\n      } else if (that.data.navUrl) {\r\n        wx.switchTab({\r\n          url: that.data.navUrl,\r\n        })\r\n      }\r\n    }\r\n\r\n\r\n  },\r\n})"}
{"title": "微信小程序----返回上一页刷新或当前页刷新 ", "author": "Rolan", "pub_time": "2021-2-23 17:58", "content": "HTML实现当前页面刷新首先我们都知道在HTML页面我们要实现当前页面刷新一般会怎么解决呢？1，reload()方法刷新当前页面；2，replace() 方法刷新当前页面；3，页面自动刷新当前页面；三种实现js 刷新当前页面的方法用法1，在实现效果之前，需要知道微信小程序的页面生命周期，不是很清楚的可以看微信小程序----页面生命周期；2，可以知道微信小程序的页面是由onLoad（页面加载）、onReady（页面初次渲染完成）、onShow（页面显示）、onHide（页面隐藏）、onUnload（页面卸载）五个周期构成；3，知道了页面的生命周期，如何实现返回刷新和当前页刷新呢？又在什么场景需要页面刷新效果呢？当前页面刷新场景：在这个电商充斥着生活各个角落的时代，都知道在购物过程会给用户生成订单，如果用户不满意或者收货等就需要去修改订单状态，在开发过程中，当用户修改订单成功后，后台一般会返回提示是否修改成功，而不会返回这个订单的详细情况。那么我们如何使前端页面更新这个订单的状态呢？一般有两种方法实现：1，人为的修改前端的数据；2，再次请求数据（也就是页面刷新）。为实现取消订单刷新效果：实现取消订单刷新效果：在这里实现需要实现的就是当前页面刷新，在讲场景的时候都说了，实现的方式是再次请求数据进行更新，如何再次请求数据？就是周期函数的onLoad，将页面重新加载，但是需要注意的是必须对相关data变量进行初始化。更新订单状态函数的代码：//更新订单状态函数\r\nupdateOrder(orderID, orderState, title){\r\n\t//获取用户保存在本地的个人信息\r\n    let account = wx.getStorageSync('accountInfo'); \r\n    //请求服务器接口更新订单状态\r\n    app.globalMethod.REQUEST({\r\n      url: urlList.updateOrderStateUrl,\r\n      data: {\r\n        accountID: account.accountID,\r\n        passWord: account.passWord,\r\n        orderID: orderID,\r\n        orderState: orderState,\r\n        token: ''\r\n      },\r\n      success: res => {\r\n        // console.log(res)\r\n        //如果更新成功\r\n        if(res.data.state == '1'){\r\n\t        //提示用户订单状态修改成功\r\n          wx.showToast({title: '您已' + title,success: res => {\r\n            //在提示的成功函数中初始化当前加载订单页为第一页，清空订单列表数据\r\n            this.setData({ currentPage: 1,orderList: []});\r\n            //用onLoad周期方法重新加载，实现当前页面的刷新\r\n            this.onLoad()\r\n          }})\r\n        }\r\n      }\r\n    })\r\n  }\r\n返回上一页刷新\r\n场景：电商购买物品时填写地址，然后返回购买页面，更新填写的新地址。为实现返回刷新效果：实现返回刷新效果：1，通过页面的生命周期，可以知道在微信小程序中，实现返回上一页的时候其实是直接将隐藏的页面再显示出来，所以不存在页面的再次加载，但是如果业务需求再次加载，在么实现？2， 通过上边的逻辑可以看出过程是： A页面 —》 B页面（改变A页面的数据）（在A跳转B的过场实现是A页面隐藏B页面渲染） —》返回A页面（更新A页面数据）（返回过程是隐藏B页面显示A页面）3，通过上边的流程，可以看出是在A页面的显示函数中执行加载函数（onShow(){this.onLoad()}）更新收货地址的代码：onShow() { //返回显示页面状态函数\r\n\t//错误处理\r\n\t//this.onLoad()//再次加载，实现返回上一页页面刷新\r\n\t//正确方法\r\n\t//只执行获取地址的方法，来进行局部刷新\r\n}\r\n总结微信小程序要实现页面刷新，简单的说就是在不同的地方执行onLoad周期函数。不过需要注意在刷新时是否需要初始化变量，这个必须注意。"}
{"title": "微信小程序----全局状态管理 (便于全局埋点等操作) ", "author": "Rolan", "pub_time": "2021-2-23 18:00", "content": "需求场景小程序开发完成，接到需求：需要对小程序的所有页面【onLoad】生命周期进行埋点，对页面中的点击事件进行埋点。需求分析全部页面生命周期和点击事件的埋点，埋点多；每个页面引入埋点文件，不利于后期维护。需求解决解决多页面生命周期埋点----重写页面生命周期：1.1 重写 Page 对象的传入对象，也就是【微信小程序之页面拦截器】的方法；1.2 重写 Page 对象本身，就是【 微信小程序–页面劫持】的方法；解决多页面引入重写文件的方法：2.1 重写 Page 对象本身，或者重写 App.Page 对象，方案：【 微信小程序全局状态管理库（wxMiniStore）】1. 方案1：劫持 Page 的传入对象1.1 hijack_page_object.js 代码/**\r\n * hijack_page_object 页面对象劫持\r\n * options 对象传入参数\r\n*/\r\nconst hijack_page_object = (options = {}) => {\r\n  const { onLoad, onUnload } = options;\r\n  options = {\r\n    ...options,\r\n    collectClick(opts){\r\n      // 页面点击埋点\r\n      console.log('页面点击埋点')\r\n      // 点击埋点逻辑\r\n    },\r\n    collectPage(opts){\r\n      // 页面生命周期埋点\r\n      console.log('页面生命周期埋点')\r\n      // 生命周期埋点逻辑\r\n    },\r\n    jumpNextPage(url){\r\n      // 全局页面跳转方法\r\n      wx.navigateTo({url})\r\n      // 埋点跳转点击\r\n      this.collectClick({})\r\n    },\r\n    onLoad(opts){\r\n      onLoad && onLoad.call(this, opts)\r\n      console.log('全局页面生命周期！')\r\n      // 埋点\r\n      this.collectPage({\r\n        \"lifeCycle\": \"onLoad\",\r\n        \"loadTime\": +new Date()\r\n      })\r\n    },\r\n    onUnload(){\r\n      onUnload && onUnload.call(this)\r\n      // 埋点\r\n      this.collectPage({\r\n        \"lifeCycle\": \"onUnload\",\r\n        \"loadTime\": +new Date()\r\n      })\r\n    }\r\n  }\r\n  return options;\r\n}\r\n\r\nmodule.exports = hijack_page_object;\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445461.2 全局引入或者单页面引入1.2.1 全局引入 app.js// 引入页面传入对象处理方法\r\nconst hijack_page_object = require('./utils/hijack_page_object')\r\n// App 中注册为全局方法\r\nApp({\r\n\thijack_page_object \r\n})\r\n1234561.2.2 页面使用 hijack_page_object 方法（index.js）// 引入 hijack_page_object \r\nconst app = getApp();\r\nconst { hijack_page_object } = app;\r\n\r\n// 使用 hijack_page_object \r\nPage(hijack_page_object({\r\n  onLoad(){\r\n    console.log('当前页面生命周期！')\r\n  }\r\n}))\r\n123456789101.2.3 单页面对 hijack_page_object.js 的引入和使用（index.js）// 引入 hijack_page_object.js\r\nconst hijack_page_object = require('../utils/hijack_page_object')\r\n// 使用 hijack_page_object \r\nPage(hijack_page_object({\r\n  onLoad(){\r\n    console.log('当前页面生命周期！')\r\n  }\r\n}))\r\n123456781.2.4 引入当前代码的输出（index.js）当前页面生命周期！\r\n全局页面生命周期！\r\n页面生命周期埋点\r\n1231.2.5 总结方案 1 的两种引入方式比较，全局引入比较快捷，一次引入，其他页面直接使用app里的变量访问即可；单页面引入不方便维护，代码冗余！建议多频率使用的方法等直接在app.js中注册！2. 方案2：重写 Page 对象2.1 hijack_page.js 代码let _Page = Page;\r\nPage = (options) => {\r\n  const { onLoad, onUnload } = options;\r\n  options = {\r\n    ...options,\r\n    collectClick(opts){\r\n      // 页面点击埋点\r\n      console.log('页面点击埋点')\r\n      // 点击埋点逻辑\r\n    },\r\n    collectPage(opts){\r\n      // 页面生命周期埋点\r\n      console.log('页面生命周期埋点')\r\n      // 生命周期埋点逻辑\r\n    },\r\n    jumpNextPage(url){\r\n      // 全局页面跳转方法\r\n      wx.navigateTo({url})\r\n      // 埋点跳转点击\r\n      this.collectClick({})\r\n    },\r\n    onLoad(opts){\r\n      onLoad && onLoad.call(this, opts);\r\n      console.log('全局页面生命周期！')\r\n      this.collectPage({\r\n        \"lifeCycle\": \"onLoad\",\r\n        \"loadTime\": +new Date()\r\n      });\r\n    },\r\n    onUnload(){\r\n      onUnload && onUnload.call(this);\r\n      this.collectClick({\r\n        \"lifeCycle\": \"onUnload\",\r\n        \"stayTime\": +new Date() - this._enterTime\r\n      });\r\n    }\r\n  }\r\n  _Page(options)\r\n}\r\nmodule.exports = {\r\n  Page\r\n}\r\n1234567891011121314151617181920212223242526272829303132333435363738394041422.2 hijack_page 的使用2.2.1 全局引入 hijack_page （app.js）// 引入 hijack_page\r\nconst hijack_page = require('./utils/hijack_page')\r\n// 注册 hijack_page\r\nApp({\r\n\thijack_page\r\n})\r\n1234562.2.2 页面使用 hijack_page (index.js)// 引入 Page \r\nconst app = getApp();\r\nconst { Page } = app.hijack_page;\r\n// 使用 Page \r\nPage({\r\n\tonLoad(){\r\n\t    console.log('当前页面生命周期！')\r\n\t}\r\n})\r\n1234567892.2.3 当前方案代码输出（index.js）当前页面生命周期！\r\n全局页面生命周期！\r\n页面生命周期埋点\r\n1232.2.4 总结对比方案1和方案2，发现直接重写 Page 比 劫持传入 Page 的对象在使用时方便很多！3. 方案3：重写 App.Page3.1 proxyStore.js 代码const { \r\n  TYPE_OBJECT,\r\n  _typeOf,\r\n  _deepClone,\r\n  _isObjEqual\r\n} = require('./util');\r\n\r\nlet $state =  Symbol('$state'),\r\n    $openPart =  Symbol('$openPart'),\r\n    $behavior =  Symbol('$behavior'),\r\n    $methods =  Symbol('$methods'),\r\n    $pageLife =  Symbol('$pageLife'),\r\n    $pageListener =  Symbol('$pageListener'),\r\n    $nonWritable =  Symbol('$nonWritable'),\r\n    $stack =  Symbol('$stack'),\r\n    $debug =  Symbol('$debug');\r\n\r\nclass ProxyStore{\r\n  constructor(opts){\r\n    // 初始化数据\r\n    this.initData(opts);\r\n    // 初始化页面周期数组\r\n    this.initPageLife();\r\n    // 重写 Page 对象\r\n    this.rewritePage();\r\n    // 重写 Component 对象\r\n    this.rewriteComponent();\r\n  }\r\n  initData(opts){\r\n    const { \r\n      openPart = false,\r\n      behavior,\r\n      methods = {},\r\n      pageLisener = {},\r\n      pageListener,\r\n      nonWritable = false,\r\n      debug = true,\r\n    } = opts;\r\n    if(_typeOf(opts.state) === TYPE_OBJECT){\r\n      this[$state] = _deepClone(opts.state);\r\n    }\r\n    this[$openPart] = openPart;\r\n    this[$behavior] = behavior;\r\n    this[$methods] = methods;\r\n    this[$pageListener] = pageListener || pageLisener;\r\n    this[$nonWritable] = nonWritable;\r\n    this[$debug] = debug;\r\n    this[$stack] = [];\r\n  }\r\n  initPageLife(){\r\n    this[$pageLife] = [\r\n      \"data\",\r\n      \"onLoad\",\r\n      \"onShow\",\r\n      \"onReady\",\r\n      \"onHide\",\r\n      \"onUnload\",\r\n      \"onPullDownRefresh\",\r\n      \"onReachBottom\",\r\n      \"onShareAppMessage\",\r\n      \"onPageScroll\",\r\n      \"onTabItemTap\",\r\n    ]\r\n  }\r\n  created(page){\r\n    !this[$stack].some(cur => cur === page) && this[$stack].push(page);\r\n    page.watch && this.watch(page)\r\n    if(!_isObjEqual(page.data.$state, this[$state])){\r\n      page.setData({$state: this[$state]})\r\n    }\r\n  }\r\n  destroy(page){\r\n    let index = this[$stack].findIndex(cur => cur === page);\r\n    ~index && this[$stack].splice(index, 1);\r\n  }\r\n  watch(page){\r\n    page.data = new Proxy(page.data,{\r\n      set(target, key, value, receiver){\r\n        page.watch && page.watch[key] && page.watch[key].call(page, value);\r\n        return Reflect.set(target, key, value, receiver);\r\n      },\r\n      get(target, key, receiver){\r\n        return Reflect.get(target, key, receiver);\r\n      }\r\n    })\r\n  }\r\n  rewritePage(){\r\n    const _Page = Page;\r\n    const _this = this;\r\n    App.Page = (options = {}, ...args) => {\r\n      const { onLoad, onUnload } = options;\r\n      options = {\r\n        ...options,\r\n        data: {\r\n          ...(options.data || {}),\r\n          $state: _this[$state]\r\n        },\r\n        ...(_this[$methods] || {}),\r\n        onLoad(opts){\r\n          _this.created(this)\r\n          onLoad && onLoad.call(this,opts)\r\n        },\r\n        onUnload(){\r\n          _this.destroy(this)\r\n          onUnload && onUnload.call(this)\r\n        }\r\n      }\r\n      Object.keys(_this[$pageListener]).forEach(key => {\r\n        if(typeof _this[$pageListener][key] === \"function\" && _this[$pageLife].some((item) => item === key)){\r\n          const lifeName = options[key];\r\n          options = {\r\n            ...options,\r\n            [key](opts){\r\n              let globalValue = _this[$pageListener][key].call(this, opts);\r\n              let pageValue = lifeName && lifeName.call(this, opts);\r\n              return pageValue || globalValue;\r\n            }\r\n          }\r\n        }\r\n      })\r\n      _Page(options, ...args)\r\n    }\r\n    if (!this[$nonWritable]) {\r\n      try {\r\n        Page = App.Page;\r\n      } catch (e) {}\r\n    }\r\n  }\r\n  rewriteComponent(){\r\n    const _Component = Component;\r\n    const _this = this;\r\n    App.Component = (options = {}, ...args) => {\r\n      const { lifetimes = {} } = options;\r\n      let attached = lifetimes.attached || options.attached,\r\n          detached = lifetimes.detached || options.detached;\r\n      options = {\r\n        ...options,\r\n        data: {\r\n          ...(options.data || {}),\r\n          $state: _this[$state]\r\n        }\r\n      }\r\n      Object.keys(_this[$methods]).forEach(key => {\r\n        if(typeof _this[$methods][key] === \"function\" && !_this[$pageLife].some((item) => item === key)){\r\n          options.methods || (options.methods = {})\r\n          const lifeName = options.methods[key];\r\n          options.methods[key] = function(opts){\r\n            _this[$methods][key].call(this, opts);\r\n            lifeName && lifeName.call(this,opts);\r\n          }\r\n        }\r\n      })\r\n      let attachednew = function(){\r\n        _this.created(this)\r\n        attached && attached.call(this)\r\n      }\r\n      let detachednew = function(){\r\n        _this.destroy(this)\r\n        detached && detached.call(this)\r\n      }\r\n      if(options.lifetimes && _typeOf(options.lifetimes) === TYPE_OBJECT){\r\n        options.lifetimes.attached = attachednew;\r\n        options.lifetimes.detached = detachednew;\r\n      } else {\r\n        options.attached = attachednew;\r\n        options.detached = detachednew;\r\n      }\r\n      _Component(options, ...args)\r\n    }\r\n    if (!this[$nonWritable]) {\r\n      try {\r\n        Component = App.Component;\r\n      } catch (e) {}\r\n    }\r\n  }\r\n  getState() {\r\n    return _deepClone(this[$state]);\r\n  }\r\n  setState(obj, fn = () => {}) {\r\n    if (_typeOf(obj) !== TYPE_OBJECT) throw new Error(\"setState的第一个参数须为object!\");\r\n    let prev = this[$state];\r\n    let current = {\r\n      ..._deepClone(prev),\r\n      ..._deepClone(obj)\r\n    };\r\n    this[$state] = current;\r\n    if(this[$stack].length){\r\n      let props = this[$stack].map(page => {\r\n        return new Promise((resolve,reject) => {\r\n          page.setData({$state: current}, resolve)\r\n        })\r\n      })\r\n      Promise.all(props).then(fn);\r\n    }else{\r\n      fn();\r\n    }\r\n  }\r\n}\r\nmodule.exports = ProxyStore;\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981993.2 util.js 基础方法js代码const util = {\r\n  TYPE_ARRAY: \"[object Array]\",\r\n  TYPE_OBJECT: \"[object Object]\",\r\n  _typeOf(value){\r\n    return Object.prototype.toString.call(value)\r\n  },\r\n  _deepClone(obj){\r\n    return JSON.parse(JSON.stringify(obj))\r\n  },\r\n  _isEmptyObject(obj){\r\n    if(util._typeOf(obj) !== util.TYPE_OBJECT) throw new Error(`传入值不是对象！`);\r\n    for(let key in  obj){\r\n      return false;\r\n    }\r\n    return true\r\n  },\r\n  _isObjEqual(o1,o2){\r\n    var props1 = Object.getOwnPropertyNames(o1);\r\n    var props2 = Object.getOwnPropertyNames(o2);\r\n    if (props1.length != props2.length) {\r\n      return false;\r\n    }\r\n    for (var i = 0,max = props1.length; i < max; i++) {\r\n      var propName = props1[i];\r\n      if (o1[propName] !== o2[propName]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\nmodule.exports = util;\r\n12345678910111213141516171819202122232425262728293031323.3 使用 ProxyStore3.3.1 app.js 注册// 引入 ProxyStore\r\nconst ProxyStore = require('./store/proxyStore');\r\n// 声明\r\nlet store = new ProxyStore({\r\n  state: {\r\n    msg: 'Hello World!'\r\n  },\r\n  methods: {\r\n    jumpNextPage(url){\r\n      wx.navigateTo({url})\r\n    }\r\n  },\r\n  pageListener: {\r\n    onLoad(){\r\n      console.log('全局')\r\n    }\r\n  }\r\n})\r\n// app.js注册\r\nApp({\r\n\tstore \r\n})\r\n123456789101112131415161718192021223.3.2 index.js 使用Page({\r\n\tonLoad(){\r\n\t    console.log('当前页面生命周期！')\r\n\t}\r\n})\r\n123453.3.3 index.js页面输出全局\r\n当前页面生命周期！\r\n124. 总结方案3 采用的是【 微信小程序全局状态管理库——wxMiniStore】的方法，方案可以对全局状态进行管理，同时页面可以使用watch 监听变量的修改！对比三种方案，方案三使用最简单，如果不需要那么多功能，可以删除不需要的代码！5. 注意方案三基本使用的是【微信小程序全局状态管理库——wxMiniStore】，但是做了自定义调整，调整如下：5.1 获取全局状态必须使用 getState() 获取 $state 对象；// 错误示范【这样是获取不到$state对象的】\r\nlet $state = getApp().store.$state\r\n\r\n// 正确示范\r\nlet $state = getApp().store.getState()\r\n123455.2 设置全局状态必须使用setState(Object);// 错误示范【这样是更新不到$state对象的】\r\ngetApp().store.$state.msg = 'Hello Index!'\r\n\r\n// 正确示范\r\ngetApp().store.setState({msg: 'Hello Index!'})\r\n123455.3 watch 监听必须是 this.data 改变的变量；// 错误示范【使用 this.setData 监听不到修改】\r\nPage({\r\n\tonLoad(){\r\n\t\tthis.setData({goodsList: [1,2,3,4,5,6]})\r\n\t},\r\n\twatch: {\r\n\t\tgoodsList(val){\r\n\t\t\tconsole.log(val)\r\n\t\t\tthis.setData({goodsList: val})\r\n\t\t}\r\n\t}\r\n})\r\n\r\n// 正确示范\r\nPage({\r\n\tonLoad(){\r\n\t\tthis.data.goodsList =  [1,2,3,4,5,6]\r\n\t},\r\n\twatch: {\r\n\t\tgoodsList(val){\r\n\t\t\tconsole.log(val)\r\n\t\t\tthis.setData({goodsList: val})\r\n\t\t}\r\n\t}\r\n})\r\n12345678910111213141516171819202122232425注意： 如果页面没有 watch 对象，页面并不会执行变量的监听，所以在不需要监听时，尽量不要 watch，减少性能消耗！"}
{"title": "微信小程序----全局状态管理 (便于全局埋点等操作) ", "author": "Rolan", "pub_time": "2021-2-23 18:12", "content": "需求场景小程序开发完成，接到需求：需要对小程序的所有页面【onLoad】生命周期进行埋点，对页面中的点击事件进行埋点。需求分析全部页面生命周期和点击事件的埋点，埋点多；每个页面引入埋点文件，不利于后期维护。需求解决解决多页面生命周期埋点----重写页面生命周期：1.1 重写 Page 对象的传入对象，也就是【微信小程序之页面拦截器】的方法；1.2 重写 Page 对象本身，就是【 微信小程序–页面劫持】的方法；解决多页面引入重写文件的方法：2.1 重写 Page 对象本身，或者重写 App.Page 对象，方案：【 微信小程序全局状态管理库（wxMiniStore）】1. 方案1：劫持 Page 的传入对象1.1 hijack_page_object.js 代码/**\r\n * hijack_page_object 页面对象劫持\r\n * options 对象传入参数\r\n*/\r\nconst hijack_page_object = (options = {}) => {\r\n  const { onLoad, onUnload } = options;\r\n  options = {\r\n    ...options,\r\n    collectClick(opts){\r\n      // 页面点击埋点\r\n      console.log('页面点击埋点')\r\n      // 点击埋点逻辑\r\n    },\r\n    collectPage(opts){\r\n      // 页面生命周期埋点\r\n      console.log('页面生命周期埋点')\r\n      // 生命周期埋点逻辑\r\n    },\r\n    jumpNextPage(url){\r\n      // 全局页面跳转方法\r\n      wx.navigateTo({url})\r\n      // 埋点跳转点击\r\n      this.collectClick({})\r\n    },\r\n    onLoad(opts){\r\n      onLoad && onLoad.call(this, opts)\r\n      console.log('全局页面生命周期！')\r\n      // 埋点\r\n      this.collectPage({\r\n        \"lifeCycle\": \"onLoad\",\r\n        \"loadTime\": +new Date()\r\n      })\r\n    },\r\n    onUnload(){\r\n      onUnload && onUnload.call(this)\r\n      // 埋点\r\n      this.collectPage({\r\n        \"lifeCycle\": \"onUnload\",\r\n        \"loadTime\": +new Date()\r\n      })\r\n    }\r\n  }\r\n  return options;\r\n}\r\nmodule.exports = hijack_page_object;\r\n1.2 全局引入或者单页面引入1.2.1 全局引入 app.js// 引入页面传入对象处理方法\r\nconst hijack_page_object = require('./utils/hijack_page_object')\r\n// App 中注册为全局方法\r\nApp({\r\n\thijack_page_object \r\n})\r\n1.2.2 页面使用 hijack_page_object 方法（index.js）// 引入 hijack_page_object \r\nconst app = getApp();\r\nconst { hijack_page_object } = app;\r\n\r\n// 使用 hijack_page_object \r\nPage(hijack_page_object({\r\n  onLoad(){\r\n    console.log('当前页面生命周期！')\r\n  }\r\n}))\r\n1.2.3 单页面对 hijack_page_object.js 的引入和使用（index.js）// 引入 hijack_page_object.js\r\nconst hijack_page_object = require('../utils/hijack_page_object')\r\n// 使用 hijack_page_object \r\nPage(hijack_page_object({\r\n  onLoad(){\r\n    console.log('当前页面生命周期！')\r\n  }\r\n}))\r\n1.2.4 引入当前代码的输出（index.js）当前页面生命周期！全局页面生命周期！页面生命周期埋点1.2.5 总结方案 1 的两种引入方式比较，全局引入比较快捷，一次引入，其他页面直接使用app里的变量访问即可；单页面引入不方便维护，代码冗余！建议多频率使用的方法等直接在app.js中注册！方案2：重写 Page 对象2.1 hijack_page.js 代码let _Page = Page;\r\nPage = (options) => {\r\n  const { onLoad, onUnload } = options;\r\n  options = {\r\n    ...options,\r\n    collectClick(opts){\r\n      // 页面点击埋点\r\n      console.log('页面点击埋点')\r\n      // 点击埋点逻辑\r\n    },\r\n    collectPage(opts){\r\n      // 页面生命周期埋点\r\n      console.log('页面生命周期埋点')\r\n      // 生命周期埋点逻辑\r\n    },\r\n    jumpNextPage(url){\r\n      // 全局页面跳转方法\r\n      wx.navigateTo({url})\r\n      // 埋点跳转点击\r\n      this.collectClick({})\r\n    },\r\n    onLoad(opts){\r\n      onLoad && onLoad.call(this, opts);\r\n      console.log('全局页面生命周期！')\r\n      this.collectPage({\r\n        \"lifeCycle\": \"onLoad\",\r\n        \"loadTime\": +new Date()\r\n      });\r\n    },\r\n    onUnload(){\r\n      onUnload && onUnload.call(this);\r\n      this.collectClick({\r\n        \"lifeCycle\": \"onUnload\",\r\n        \"stayTime\": +new Date() - this._enterTime\r\n      });\r\n    }\r\n  }\r\n  _Page(options)\r\n}\r\nmodule.exports = {\r\n  Page\r\n}\r\n2.2 hijack_page 的使用2.2.1 全局引入 hijack_page （app.js）// 引入 hijack_page\r\nconst hijack_page = require('./utils/hijack_page')\r\n// 注册 hijack_page\r\nApp({\r\n\thijack_page\r\n})\r\n2.2.2 页面使用 hijack_page (index.js)// 引入 Page \r\nconst app = getApp();\r\nconst { Page } = app.hijack_page;\r\n// 使用 Page \r\nPage({\r\n\tonLoad(){\r\n\t    console.log('当前页面生命周期！')\r\n\t}\r\n})\r\n2.2.3 当前方案代码输出（index.js）当前页面生命周期！全局页面生命周期！页面生命周期埋点2.2.4总结对比方案1和方案2，发现直接重写 Page 比 劫持传入 Page 的对象在使用时方便很多！3. 方案3：重写 App.Page3.1 proxyStore.js 代码const { \r\n  TYPE_OBJECT,\r\n  _typeOf,\r\n  _deepClone,\r\n  _isObjEqual\r\n} = require('./util');\r\n\r\nlet $state =  Symbol('$state'),\r\n    $openPart =  Symbol('$openPart'),\r\n    $behavior =  Symbol('$behavior'),\r\n    $methods =  Symbol('$methods'),\r\n    $pageLife =  Symbol('$pageLife'),\r\n    $pageListener =  Symbol('$pageListener'),\r\n    $nonWritable =  Symbol('$nonWritable'),\r\n    $stack =  Symbol('$stack'),\r\n    $debug =  Symbol('$debug');\r\n\r\nclass ProxyStore{\r\n  constructor(opts){\r\n    // 初始化数据\r\n    this.initData(opts);\r\n    // 初始化页面周期数组\r\n    this.initPageLife();\r\n    // 重写 Page 对象\r\n    this.rewritePage();\r\n    // 重写 Component 对象\r\n    this.rewriteComponent();\r\n  }\r\n  initData(opts){\r\n    const { \r\n      openPart = false,\r\n      behavior,\r\n      methods = {},\r\n      pageLisener = {},\r\n      pageListener,\r\n      nonWritable = false,\r\n      debug = true,\r\n    } = opts;\r\n    if(_typeOf(opts.state) === TYPE_OBJECT){\r\n      this[$state] = _deepClone(opts.state);\r\n    }\r\n    this[$openPart] = openPart;\r\n    this[$behavior] = behavior;\r\n    this[$methods] = methods;\r\n    this[$pageListener] = pageListener || pageLisener;\r\n    this[$nonWritable] = nonWritable;\r\n    this[$debug] = debug;\r\n    this[$stack] = [];\r\n  }\r\n  initPageLife(){\r\n    this[$pageLife] = [\r\n      \"data\",\r\n      \"onLoad\",\r\n      \"onShow\",\r\n      \"onReady\",\r\n      \"onHide\",\r\n      \"onUnload\",\r\n      \"onPullDownRefresh\",\r\n      \"onReachBottom\",\r\n      \"onShareAppMessage\",\r\n      \"onPageScroll\",\r\n      \"onTabItemTap\",\r\n    ]\r\n  }\r\n  created(page){\r\n    !this[$stack].some(cur => cur === page) && this[$stack].push(page);\r\n    page.watch && this.watch(page)\r\n    if(!_isObjEqual(page.data.$state, this[$state])){\r\n      page.setData({$state: this[$state]})\r\n    }\r\n  }\r\n  destroy(page){\r\n    let index = this[$stack].findIndex(cur => cur === page);\r\n    ~index && this[$stack].splice(index, 1);\r\n  }\r\n  watch(page){\r\n    page.data = new Proxy(page.data,{\r\n      set(target, key, value, receiver){\r\n        page.watch && page.watch[key] && page.watch[key].call(page, value);\r\n        return Reflect.set(target, key, value, receiver);\r\n      },\r\n      get(target, key, receiver){\r\n        return Reflect.get(target, key, receiver);\r\n      }\r\n    })\r\n  }\r\n  rewritePage(){\r\n    const _Page = Page;\r\n    const _this = this;\r\n    App.Page = (options = {}, ...args) => {\r\n      const { onLoad, onUnload } = options;\r\n      options = {\r\n        ...options,\r\n        data: {\r\n          ...(options.data || {}),\r\n          $state: _this[$state]\r\n        },\r\n        ...(_this[$methods] || {}),\r\n        onLoad(opts){\r\n          _this.created(this)\r\n          onLoad && onLoad.call(this,opts)\r\n        },\r\n        onUnload(){\r\n          _this.destroy(this)\r\n          onUnload && onUnload.call(this)\r\n        }\r\n      }\r\n      Object.keys(_this[$pageListener]).forEach(key => {\r\n        if(typeof _this[$pageListener][key] === \"function\" && _this[$pageLife].some((item) => item === key)){\r\n          const lifeName = options[key];\r\n          options = {\r\n            ...options,\r\n            [key](opts){\r\n              let globalValue = _this[$pageListener][key].call(this, opts);\r\n              let pageValue = lifeName && lifeName.call(this, opts);\r\n              return pageValue || globalValue;\r\n            }\r\n          }\r\n        }\r\n      })\r\n      _Page(options, ...args)\r\n    }\r\n    if (!this[$nonWritable]) {\r\n      try {\r\n        Page = App.Page;\r\n      } catch (e) {}\r\n    }\r\n  }\r\n  rewriteComponent(){\r\n    const _Component = Component;\r\n    const _this = this;\r\n    App.Component = (options = {}, ...args) => {\r\n      const { lifetimes = {} } = options;\r\n      let attached = lifetimes.attached || options.attached,\r\n          detached = lifetimes.detached || options.detached;\r\n      options = {\r\n        ...options,\r\n        data: {\r\n          ...(options.data || {}),\r\n          $state: _this[$state]\r\n        }\r\n      }\r\n      Object.keys(_this[$methods]).forEach(key => {\r\n        if(typeof _this[$methods][key] === \"function\" && !_this[$pageLife].some((item) => item === key)){\r\n          options.methods || (options.methods = {})\r\n          const lifeName = options.methods[key];\r\n          options.methods[key] = function(opts){\r\n            _this[$methods][key].call(this, opts);\r\n            lifeName && lifeName.call(this,opts);\r\n          }\r\n        }\r\n      })\r\n      let attachednew = function(){\r\n        _this.created(this)\r\n        attached && attached.call(this)\r\n      }\r\n      let detachednew = function(){\r\n        _this.destroy(this)\r\n        detached && detached.call(this)\r\n      }\r\n      if(options.lifetimes && _typeOf(options.lifetimes) === TYPE_OBJECT){\r\n        options.lifetimes.attached = attachednew;\r\n        options.lifetimes.detached = detachednew;\r\n      } else {\r\n        options.attached = attachednew;\r\n        options.detached = detachednew;\r\n      }\r\n      _Component(options, ...args)\r\n    }\r\n    if (!this[$nonWritable]) {\r\n      try {\r\n        Component = App.Component;\r\n      } catch (e) {}\r\n    }\r\n  }\r\n  getState() {\r\n    return _deepClone(this[$state]);\r\n  }\r\n  setState(obj, fn = () => {}) {\r\n    if (_typeOf(obj) !== TYPE_OBJECT) throw new Error(\"setState的第一个参数须为object!\");\r\n    let prev = this[$state];\r\n    let current = {\r\n      ..._deepClone(prev),\r\n      ..._deepClone(obj)\r\n    };\r\n    this[$state] = current;\r\n    if(this[$stack].length){\r\n      let props = this[$stack].map(page => {\r\n        return new Promise((resolve,reject) => {\r\n          page.setData({$state: current}, resolve)\r\n        })\r\n      })\r\n      Promise.all(props).then(fn);\r\n    }else{\r\n      fn();\r\n    }\r\n  }\r\n}\r\nmodule.exports = ProxyStore;\r\n3.2 util.js 基础方法js代码const util = {\r\n  TYPE_ARRAY: \"[object Array]\",\r\n  TYPE_OBJECT: \"[object Object]\",\r\n  _typeOf(value){\r\n    return Object.prototype.toString.call(value)\r\n  },\r\n  _deepClone(obj){\r\n    return JSON.parse(JSON.stringify(obj))\r\n  },\r\n  _isEmptyObject(obj){\r\n    if(util._typeOf(obj) !== util.TYPE_OBJECT) throw new Error(`传入值不是对象！`);\r\n    for(let key in  obj){\r\n      return false;\r\n    }\r\n    return true\r\n  },\r\n  _isObjEqual(o1,o2){\r\n    var props1 = Object.getOwnPropertyNames(o1);\r\n    var props2 = Object.getOwnPropertyNames(o2);\r\n    if (props1.length != props2.length) {\r\n      return false;\r\n    }\r\n    for (var i = 0,max = props1.length; i < max; i++) {\r\n      var propName = props1[i];\r\n      if (o1[propName] !== o2[propName]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\nmodule.exports = util;\r\n3.3 使用 ProxyStore3.3.1 app.js 注册// 引入 ProxyStore\r\nconst ProxyStore = require('./store/proxyStore');\r\n// 声明\r\nlet store = new ProxyStore({\r\n  state: {\r\n    msg: 'Hello World!'\r\n  },\r\n  methods: {\r\n    jumpNextPage(url){\r\n      wx.navigateTo({url})\r\n    }\r\n  },\r\n  pageListener: {\r\n    onLoad(){\r\n      console.log('全局')\r\n    }\r\n  }\r\n})\r\n// app.js注册\r\nApp({\r\n\tstore \r\n})\r\n3.3.2 index.js 使用Page({\r\n\tonLoad(){\r\n\t    console.log('当前页面生命周期！')\r\n\t}\r\n})\r\n3.3.3 index.js页面输出全局当前页面生命周期！4. 总结方案3 采用的是【 微信小程序全局状态管理库——wxMiniStore】的方法，方案可以对全局状态进行管理，同时页面可以使用watch 监听变量的修改！对比三种方案，方案三使用最简单，如果不需要那么多功能，可以删除不需要的代码！5. 注意方案三基本使用的是【微信小程序全局状态管理库——wxMiniStore】，但是做了自定义调整，调整如下：5.1 获取全局状态必须使用 getState() 获取 $state 对象；// 错误示范【这样是获取不到$state对象的】\r\nlet $state = getApp().store.$state\r\n\r\n// 正确示范\r\nlet $state = getApp().store.getState()\r\n5.2 设置全局状态必须使用setState(Object);// 错误示范【这样是更新不到$state对象的】\r\ngetApp().store.$state.msg = 'Hello Index!'\r\n\r\n// 正确示范\r\ngetApp().store.setState({msg: 'Hello Index!'})\r\n5.3 watch 监听必须是 this.data 改变的变量；// 错误示范【使用 this.setData 监听不到修改】\r\nPage({\r\n\tonLoad(){\r\n\t\tthis.setData({goodsList: [1,2,3,4,5,6]})\r\n\t},\r\n\twatch: {\r\n\t\tgoodsList(val){\r\n\t\t\tconsole.log(val)\r\n\t\t\tthis.setData({goodsList: val})\r\n\t\t}\r\n\t}\r\n})\r\n\r\n// 正确示范\r\nPage({\r\n\tonLoad(){\r\n\t\tthis.data.goodsList =  [1,2,3,4,5,6]\r\n\t},\r\n\twatch: {\r\n\t\tgoodsList(val){\r\n\t\t\tconsole.log(val)\r\n\t\t\tthis.setData({goodsList: val})\r\n\t\t}\r\n\t}\r\n})\r\n注意： 如果页面没有 watch 对象，页面并不会执行变量的监听，所以在不需要监听时，尽量不要 watch，减少性能消耗！5.4 未开发的 wxMiniStore 功能：【开启局部模式、设置范围、useProp 】"}
{"title": "微信小程序----简易双向绑定 ", "author": "Rolan", "pub_time": "2021-2-23 18:27", "content": "基础库 2.9.3 开始支持，低版本需做兼容处理。在 WXML 中，普通的属性的绑定是单向的。例如：<input value=\"{{value}}\" />\r\n1在【基础库 2.9.3 】之前，属性的绑定是单向的，在上边的实例中在视图层修改value，只会改变视图层的value，不会对逻辑层的value（this.data.value）进行修改。但是又需要同时修改逻辑层value（this.data.value），怎么做呢？就是采用input组件的bindinput触发事件实现。实现单向数据的双向绑定单向数据的WXML<input bindinput=\"getCurrentValue\" value=\"{{value}}\" />\r\n1单向数据的JSgetCurrentValue(e){\r\n\tthis.setData({value: e.detail.value})\r\n}\r\n123实现原理：通过触发bindinput事件，实时监听value的值，然后通过微信小程序提供的this.setData方法，同时对逻辑层(this.data.value)和视图层(value)进行修改。这样就实现数据的双向绑定！简易双向绑定<input model:value=\"{{value}}\" />\r\n1微信小程序提供的简易双向绑定，在输入框修改value的时候，逻辑层（this.data.value）和视图层（value）就会同时进行修改，优化了调用this.setData的消耗！注意只能是一个单一字段的绑定；目前，尚不能 data 路径。反例(不支持)<input model:value=\"值为 {{value}}\" />\r\n<input model:value=\"{{ a + b }}\" />\r\n<input model:value=\"{{ a.b }}\" />"}
{"title": "微信小程序：实现简单的拼券功能（uniCloud） ", "author": "Rolan", "pub_time": "2021-2-19 09:51", "content": "使用uniApp+uniCloud实现了一个简单的拼券功能，整个需求与京东的拼券和拼多多的砍一刀类似。\r\n分享方：\r\n\r\n分享优惠券信息，请好友帮忙助力（授权登录后可操作）\r\n若邀请人数不足，则提示还差多少人\r\n若邀请人数满足，则可使用该券\r\n\r\n助力方：\r\n\r\n点击好友发送的分享信息框进入小程序\r\n点击助力按钮，即可帮好友助力（助力即授权登录）\r\n若助力成功，则提示助力成功\r\n若好友已助力完毕，则提示助力已满\r\n\r\n数据库设计\r\n\r\nuser 用户表，存用户信息\r\ncoupons 优惠券表，存优惠券信息\r\nuser-coupons 用户的优惠券表，存用户与优惠券的对应关系（只要用户操作过该优惠券，如：领取、分享，则回插上一条数据）\r\n\r\n地址\r\n\r\n插件市场：ext.dcloud.net.cn/plugin?id=4…\r\n\r\n\r\ngithub：github.com/oyai32/oyyl…\r\n\r\n截图"}
{"title": "微信小程序-bindtap等事件传参 ", "author": "Rolan", "pub_time": "2021-2-9 23:48", "content": "什么是事件事件是视图层到逻辑层的通讯方式。 事件可以将用户的行为反馈到逻辑层进行处理。事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。事件对象可以携带额外信息，如 id, dataset, touches。看图，因为需要传递的数据比较多，所以我们通过dataset携带参数信息。如果只有一个参数，可以通过id来传递。详解（以常见的tap点击事情为例）wxml<view id=\"tapTest\" data-hi=\"WeChat\" bindtap=\"tapName\"> Click me! </view>1JSPage({\r\n  tapName: function(event) {\r\n    console.log(event)\r\n  }\r\n})12345event 打印结果{\r\n\"type\":\"tap\",\r\n\"timeStamp\":895,\r\n/////////////////////////////////\r\n\"target\": {\r\n  \"id\": \"tapTest\",\r\n  \"dataset\":  {\r\n    \"hi\":\"WeChat\"\r\n  }\r\n},\r\n\"currentTarget\":  {\r\n  \"id\": \"tapTest\",\r\n  \"dataset\": {\r\n    \"hi\":\"WeChat\"\r\n  }\r\n},\r\n///////////////////////////////\r\n\"detail\": {\r\n  \"x\":53,\r\n  \"y\":14\r\n},\r\n\"touches\":[{\r\n  \"identifier\":0,\r\n  \"pageX\":53,\r\n  \"pageY\":14,\r\n  \"clientX\":53,\r\n  \"clientY\":14\r\n}],\r\n\"changedTouches\":[{\r\n  \"identifier\":0,\r\n  \"pageX\":53,\r\n  \"pageY\":14,\r\n  \"clientX\":53,\r\n  \"clientY\":14\r\n}]\r\n}123456789101112131415161718192021222324252627282930313233343536注意两点：1、data-名称 不能有大写字母，如果需要，可以通过 - （中划线）来连接单词，编译的时候小程序会将第二个单词首字母自动大写。图中代码是为了自己标志，所以第二个单词的首字母大写了，其实可以不用。data-* 属性中不可以存放对象。2、注意打印结果中target和currentTarget的区别。target 触发事件的源组件。currentTarget 事件绑定的当前组件。如果你在父容器上绑定了事件并传参，当你点击父容器时，事件绑定的组件和触发事件的源组件是同一个元素，所以currentTarget 、target 都可以拿到参数，但是当你点击子元素时，target 就不是事件绑定的组件了，所以拿不到参数。由于事件冒泡的机制，父容器上绑定的事件依然可以触发，所以currentTarget 依然可以拿到参数。说明id传参和dataset类似，只是最后获取值的时候不同。event.currentTarget.id"}
{"title": "极速入门微信小程序 之 生命周期篇(3-组件) ", "author": "Rolan", "pub_time": "2021-2-19 09:57", "content": "组件生命周期\r\n现时代的前端项目开发，都是基于组件化的，因此学好微信小程序-组件的生命周期会更加有利于我们开发高质量的项目代码。\r\n\r\n搭建父子组件结构\r\n\r\n\r\n新建组件 components\\chitu\\chitu\r\n\r\n\r\n\r\n页面中引用\r\n\r\n\r\nindex.json\r\n{\r\n  \"usingComponents\": {\r\n    \"chitu\":\"/components/chitu/chitu\"\r\n  }\r\n}\r\n复制代码\r\n\r\n\r\nindex.wxml\r\n<chitu>chitu>\r\n复制代码\r\n组件自身的生命周期\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n生命周期描述created在组件实例刚刚被创建时执行attached在组件实例进入页面节点树时执行ready在组件在视图层布局完成后执行moved在组件实例被移动到节点树另一个位置时执行detached在组件实例被从页面节点树移除时执行error每当组件方法抛出错误时执行\r\n组件所在页面的生命周期\r\n还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。其中可用的生命周期包括：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n生命周期描述show组件所在的页面被展示时执行hide组件所在的页面被隐藏时执行resize组件所在的页面尺寸变化时执行\r\n具体实现可以参考如下\r\nComponent({\r\n  pageLifetimes: {\r\n    show: function() {\r\n      // 页面被展示\r\n    },\r\n    hide: function() {\r\n      // 页面被隐藏\r\n    },\r\n    resize: function(size) {\r\n      // 页面尺寸变化\r\n    }\r\n  }\r\n})\r\n复制代码\r\ncreated\r\n\r\n组件实例刚刚被创建时触发 此时不 setData 不生效\r\n\r\n触发时机\r\n组件实例刚刚被创建时触发\r\n作用\r\n可以给 this 添加一些自定义属性\r\n代码\r\nComponent({\r\n  lifetimes: {\r\n    /**\r\n     * 组件刚刚创建完毕\r\n     */\r\n    created() {\r\n      console.log(\"created 组件刚刚创建完毕\");\r\n    } \r\n  }\r\n})\r\n复制代码\r\n效果\r\n\r\nattached\r\n\r\n组件实例 被创建到页面节点时触发 此时已经可以使用 setData\r\n\r\n触发时机\r\n组件实例 被创建到页面节点时触发 此时已经可以使用 setData\r\n作用\r\n一般用在发送异步请求获取数据赋值data然后渲染页面\r\n代码\r\nComponent({\r\n  lifetimes: {\r\n    /**\r\n     * 组件实例 被创建到页面节点时触发\r\n     */\r\n    attached(){\r\n      console.log(\"attached 组件实例 被创建到页面节点时触发\");\r\n    }\r\n  }\r\n})\r\n复制代码\r\n效果\r\n\r\nready\r\n\r\n组件视图渲染完毕后触发\r\n\r\n触发时机\r\n组件视图渲染完毕后触发\r\n作用\r\n可以用在获取渲染结束后的节点样式\r\n代码\r\nComponent({\r\n  lifetimes: {\r\n    /**\r\n     * 组件视图渲染完毕后触发\r\n     */\r\n    ready() {\r\n      console.log(\"ready 组件视图渲染完毕后触发 \");\r\n    },\r\n  }\r\n})\r\n复制代码\r\n效果\r\n\r\nmoved\r\n\r\n当组件节点位置发生改变时生效\r\n\r\n触发时机\r\n我们这样理解   存在一个数组 通过循环生成了一系列组件，当数组中的元素发生位置改变时，那么其中的组件的位置也发生了改变。这样便会触发 move 生命周期\r\n作用\r\n可用做组件自身由于位置改变而附带的副作用\r\n代码\r\n\r\n\r\n父页面\r\n\r\n\r\nindex.js\r\n      \r\nPage({\r\n  data: {\r\n    list: [\r\n      { id: 0, text: 0 },\r\n      { id: 1, text: 1 }\r\n    ]\r\n  },\r\n  onLoad: function () {\r\n    setTimeout(() => {\r\n      const [a, b] = this.data.list;\r\n      const list = [b, a];\r\n      this.setData({ list })\r\n    }, 2000);\r\n  },\r\n})\r\n复制代码\r\n\r\n\r\nindex.wxml\r\n\r\n   {{item.text}} \r\n\r\n复制代码\r\n\r\n\r\n\r\n\r\n子组件\r\n\r\n\r\nwxml\r\n<view><slot>slot>view>\r\n复制代码\r\n\r\n\r\njs\r\nComponent({\r\n    /**\r\n     * 组件的位置发生改变时触发\r\n     */\r\n    moved() {\r\n      console.log(\"moved 组件的位置发生改变时触发\");\r\n    }\r\n  }\r\n})\r\n复制代码\r\n\r\n\r\n\r\n\r\n效果\r\n定时器等待 2s 通过 setData 修改数组  同时观察页面中的  文本\r\n\r\ndetached\r\n\r\n当组件在页面中被移除时触发\r\n\r\n触发时机\r\n当组件在页面中被移除时触发 组件在父页面中通过 wx:if  实现了隐藏即为被移除\r\n作用\r\n停止异步任务\r\n代码\r\n\r\n\r\n父页面\r\n\r\n\r\nindex.js\r\nPage({\r\n  data: {\r\n    show: true\r\n  },\r\n  onLoad: function () {\r\n    setTimeout(() => {\r\n      this.setData({ show: false })\r\n    }, 2000);\r\n  }\r\n})\r\n复制代码\r\n\r\n\r\nindex.wxml\r\n<view>\r\n  <chitu wx:if=\"{{show}}\">赤兔chitu>\r\nview>\r\n复制代码\r\n\r\n\r\n\r\n\r\n子组件\r\nComponent({\r\n  lifetimes: {\r\n    /**\r\n     * 当组件在页面中被移除时触发\r\n     */\r\n    detached(){\r\n      console.log(\"detached 当组件在页面中被移除时触发\");\r\n    } \r\n  }\r\n})\r\n复制代码\r\n\r\n\r\n效果\r\n\r\nerror\r\n\r\n当组件内代码出现错误时触发\r\n\r\n触发时机\r\n当组件内代码出现错误时触发\r\n作用\r\n可以用做收集错误信息 或者给出用户友好提示\r\n代码\r\nComponent({\r\n  lifetimes: {\r\n    created() {\r\n      // 瞎调用一通\r\n      this.setabcd();\r\n    },\r\n    /**\r\n     * 当组件内的代码出现错误时触发\r\n     */\r\n    error(){\r\n      console.log(\"error 当组件内的代码出现错误时触发\");\r\n    }\r\n  }\r\n})\r\n复制代码\r\n效果"}
{"title": "小程序自定义下拉刷新组件（为应对头部有非滚动区的情况） ... ", "author": "Rolan", "pub_time": "2021-2-19 10:47", "content": "效果动图：小程序是有其下拉刷新api的，然而头部或者尾部有非滚动区域的情况下，是应对不了的，相关问题在微信开放社区已经是老生常谈了，比如：onPullDownRefresh 下拉刷新在安卓手机上会带动头部fixed元素一起下拉的问题又比如：小程序下拉刷新onPullDownRefresh 问题，fixed定位下移！像这种问题有很多，不一一列举了。这个问题从2018年开始就不断有开发者向微信开放社区反馈，一直到现在，都没有解决，没办法，本公司项目中有头部是固定非滚动的列表页面，只得自己自定义一个。列表页的上拉加载，参考了这篇文章中的方法，链接放在这里，大家可以移步去看一下：浅谈微信小程序中的下拉刷新和上拉加载回到主题，下拉刷新，我的思路是在这篇文章里找到的：小程序开发踩坑记录（五）——模拟实现底部tabbar和下拉刷新功能（解决安卓端打开下拉刷新功能后fixed元素失效问题）我一上来打算用该文章中的方法，来自制下拉刷新，可是我是在自定义组件中使用，不是在page中定义，在自定义组件中scroll-view的onscroll事件怎么也响应不了，也就无法获得当前页面的scrollTop。后来我受这个启发，既然可以在tocuh事件中改变scroll-view的scrollTop,来模拟出一个下拉刷新区域的scrollTop随手指滑动而变化，进而实现其下拉显示和回弹，那我也可以使用绝对定位和相对定位，依靠改变容器的top值来实现这个功能，也就是可以将滚动容器的top初始值设置为负的刷新区域的高度，在tocuhstart和tocuhmove事件中获取手指在屏幕上的滑动距离，让容器的top和滑动距离呈正相关，当top值达到自己设置的阈值的时候停止变化，随后在tocuhend事件中发起刷新请求。大体思路如上图所示下面贴一下基本代码：\r\n<view\r\n  class=\"scroll\"\r\n  scroll-y\r\n  style=\"min-height: {{pageHeight + 'px'}}; top: {{marginTop + 'rpx'}}\"\r\n  enable-back-to-top=\"{{true}}\"\r\n  bindtouchmove=\"movePull\" \r\n  bindtouchstart=\"startPull\" \r\n  bindtouchend=\"endPull\"\r\n  bindscroll=\"onScroll\" >\r\n  <view class=\"scroll__content {{springbacking ? 'return__content' : ''}}\" style=\"min-height: {{contentHeight + 'px'}};top: {{scrollTop + 'px'}}\">\r\n    <view class=\"refresh__wrap\">\r\n      <view class=\"refresh__center\">\r\n        <view class=\"refresh__icon {{refreshText === '松开刷新' ? 'rotate' : ''}}\" >\r\n          <mp-icon icon=\"sending\" color=\"#999\" size=\"{{35}}\"></mp-icon>\r\n        </view>\r\n        <view class=\"tips\">{{refreshText}}</view>\r\n        <view class=\"times\">最后更新：{{refreshTime}}</view>\r\n      </view>\r\n    </view>\r\n    <slot />\r\n    <view class=\"footer__line\" wx:if=\"{{recycleList.length}}\">\r\n      <view class=\"scroll__loading\" wx:if=\"{{bottomLoadingShow}}\"></view>\r\n      <text class=\"text {{bottomLoadingShow ? 'notline' : ''}}\">{{lineText}}</text>\r\n    </view>\r\n  </view>\r\n  <no-data \r\n    show=\"{{notDataShow}}\"\r\n    bind:refresh=\"refresh\" />\r\n</view>重点说下，这个组件结构为外层.scroll元素，最小高度设置为pageHeight（计算方法后面会贴），position为relative，其top值设置为父级页面传入的marginTop值，就是父级页面头部非滚动元素的rpx高度，如果没有非滚动元素，则默认为0，这样的话，外层的位置就可以依赖marginTop值来确定了，滚动的时候不会把非滚动区域也算进去；内层列表滚动区域.scroll__content元素，position为absolute最小高度contentHeight，top值scrollTop，初始-80px（刷新文案元素高度），这样就把.refresh__wrap刷新文案元素隐藏起来了。此外，设置一个默认插槽，就是列表循环内容。pageHeight和contentHeight计算方法，用到wx.getSystemInfozhege api,比较简单：getPageHeight() {\r\n      const self = this;\r\n      wx.getSystemInfo({\r\n        success: (res) => {\r\n          self.setData({\r\n            pageHeight: res.windowHeight - (self.data.marginTop / 750 * res.windowWidth),\r\n            contentHeight: (res.windowHeight - (self.data.marginTop / 750 * res.windowWidth)) + REFRESHHEIGHT + 2,\r\n          })\r\n        }\r\n      })\r\n    }以上，marginTop是父级组件传进来的头部非滚动区域的rpx高度值（头部非滚动区域position设置为fixed），默认为0，REFRESHHEIGHT是80，就是刷新文案区域的高度px值，最后加2是保证在第一页铺不满整屏的情况下，能让onReachBottom上拉事件生效，上拉加载本文不多说了，可以直接去看上面贴出的链接：“浅谈微信小程序中的下拉刷新和上拉加载”（注意，我这里是自定义组件，onReachBottom事件同样要在父页面中写onReachBottom生命周期，来调用自定义组件中的onReachBottom方法）。tocuhstart方法，就是获取手指开始接触屏幕的clentY值：startPull(ev) {\r\n  this.lastTop = ev.changedTouches[0].clientY;\r\n},Tocuhmove方法：// MAX_MOVE_TOP 为 120 允许最大滑动距离\r\n// MAX_SCROLL_TOP 为 20 允许.scroll__content的最大top值\r\nmovePull(ev) {\r\n      this.nowY = ev.changedTouches[0].clientY;// 手指当前触摸位置的clentY值\r\n      this.nowY = this.nowY - this.lastTop;// 滑动距离\r\n      const query = wx.createSelectorQuery();\r\n      query.select('.scroll').boundingClientRect();\r\n      query.selectViewport().scrollOffset();\r\n      query.exec((rect) => { // 必须是滚动高度为0即在顶部的时候触发\r\n        if (rect[1].scrollTop <= 0 && this.nowY > 0 && this.nowY <= MAX_MOVE_TOP && this.data.recycleList.length) {\r\n          this.setData({// 满足以上条件的，则使.scroll__content元素的top值等于-80px 加上滑动距离 nowY\r\n            scrollTop: -REFRESHHEIGHT + this.nowY,\r\n          })\r\n          if(this.nowY >= 100) {\r\n            this.setData({\r\n              refreshText: '松开刷新',\r\n            })\r\n          }\r\n        }\r\n      })\r\n\r\n      if(this.nowY > MAX_MOVE_TOP && this.data.scrollTop < MAX_SCROLL_TOP) {\r\n        this.setData({// 此处判断是为了解决手指滑动过快，tocuhmove得到的clentY值呈非线性变化，导致滑动距离可能上一次还是100以内，下一次直接就到300开外，无法满足上面的top变化条件，就卡住了。所以此时手动将.scroll__content的top值设置为20。\r\n          refreshText: '松开刷新',\r\n          scrollTop: MAX_SCROLL_TOP,\r\n        })\r\n      }\r\n      ...\r\n      // 上拉加载逻辑\r\n      ...\r\n    }Tocuhend事件：endPull() {// 结束滑动的时候当.scroll__content的top值大于等于20，则可以执行刷新方法。\r\n      if(this.data.scrollTop >= MAX_SCROLL_TOP) {\r\n        wx.showNavigationBarLoading();\r\n        this.refresh();\r\n      }\r\n      ...\r\n      // 上拉加载逻辑\r\n      ...\r\n      if (this.data.scrollTop > -REFRESHHEIGHT) {\r\n        this.setData({ // 这个springbacking为true的时候，.scroll__content元素的transition就是0.4s，回弹时候的动画效果。\r\n          springbacking: true,\r\n          scrollTop: -REFRESHHEIGHT\r\n        })\r\n      }\r\n    },好了，下拉刷新的逻辑就写完了，该下拉刷新在安卓和ios上的效果差别不是很大，由于业务需要，我是把他做成了一个组件，一些刷新方法和父页面的请求事件成功交互，失败交互，不在本文探讨范围之内，所以就略去了，想试试的朋友可以直接在页面中将slot插槽替换成列表循环元素尝试。"}
{"title": "「建议收藏」小程序canvas绘制海报全流程 ", "author": "Rolan", "pub_time": "2021-2-19 10:58", "content": "接下来，我会把纯前端实现生成海报全流程给大家讲个明明白白，把我自己遇到的坑，给大家详细分享并讲解，防止大家遇到相似问题，即使遇到问题，也会有一个明确的方向，并且吐血建议大家收藏一波，以备不时之需。(你不能保证以后的需求，没有类似的吧，有的话，记得翻出来看看)一 写在前面\r\n1 canvas绘制带二维码的海报，这些坑总有一个你可能会踩到，我会带你一步步解决这些坑\r\n技术选型背景：taro3.0-vue\r\n先来十一个问题压压惊，相信你做绘制海报过程中，一定会遇到\r\ntaro框架遇到的坑\r\n① taro-vue  createCanvasContext 获取canvas实例无效问题，绘制不出来效果？✅\r\n② taro-vue 初始化获取不到canvas上下文怎么办，完全绘制不出来图片？✅\r\n小程序canvas遇到的坑\r\n③ 关于canvas 宽高以及缩放比问题，绘制的元素变形，画布的高度真得等于cavans标签设置的宽高么？✅\r\n④ canvas怎么绘制叠在一起的两张图片，并控制层级？✅\r\n⑤ 如何用canvas绘制，多行文本？✅\r\n⑥ 如何根据设计稿，精确还原海报各个元素位置问题。✅\r\n⑦ canvas怎么绘制base64的图片✅\r\n⑧ 如何绘制网络的图片,两种canvas画布api，绘制图片有什么区别完成✅\r\n生成二维码遇到的坑\r\n⑨ 如何正确选型生成二维码工具？✅\r\n⑩ 生成的二维码，识别不出来怎么办，✅\r\n⑪ 如何绘制二维码上的logo✅二 实战一第一阶段：小程序canva初始化\r\n1 两种cavnas获取上下文方式\r\n我们即将解决的问题\r\n① taro-vue  createCanvasContext 获取canvas实例无效问题，绘制不出来效果？\r\n② taro-vue 初始化获取不到canvas上下文怎么办？\r\n微信官网上介绍两种 canvas 获取上下文方式，一种是老的api ,一种是新的 api ,接下来我将讲解一下这两api的用法。\r\n老版本 createCanvasContext 方式\r\ncreateCanvasContext是微信提供的获取 canvas实例的老得接口，使用方式如下。\r\nwxml\r\n<canvas style=\"width: 300px; height: 200px;\" canvas-id=\"firstCanvas\">canvas>\r\n复制代码\r\n美好的一天从写一个hello,world开始。\r\njs中这么写\r\nonReady(){\r\n    /*  使用 wx.createContext 获取绘图上下文 context ， firstCanvas 与 canvas 属性中的canvas-id一一对应  */\r\n    const context = wx.createCanvasContext('firstCanvas')\r\n    /* 设置字体大小 */\r\n    context.setFontSize(20) \r\n    /* 设置字体颜色 */\r\n    context.setFillStyle('pink')\r\n    /* 设置文本内容,位置 */\r\n    context.fillText('hello,world', 0, 0)\r\n    context.draw()\r\n}\r\n\r\n复制代码\r\n老版本是使用createCanvasContext传入 canvas标签中的 canvas-id属性，来获取canvas实例，老版本的使用起来说实话，不够灵活，很多对canvas线条，颜色的设置，都封装成方法了,每次改变需要调用方法。\r\n新版本 getContext 上下文方式\r\n新的方式，则是先通过 createSelectorQuery 获取  canvas 元素节点, 然后通过 getContext 获取上下文。\r\nwxml\r\n <canvas type=\"2d\" id=\"myCanvas\">canvas>\r\n复制代码\r\njs\r\nconst query = wx.createSelectorQuery()\r\nquery.select('#myCanvas')\r\n.fields({\r\n    node: true,\r\n    size: true\r\n})\r\n.exec((res)=>{\r\n    const { node } = res[0]\r\n    if (!node) return\r\n    /* 获取 canvas 实例 */\r\n    const context = node.getContext('2d')\r\n    context.fillStyle = 'pink'\r\n    /* 设置字体样式 大小 字体类别 */\r\n    context.font = 'normal 400 12px PingFangSC-Regular',\r\n    context.fillText('hello,world', 0, 0)\r\n})\r\n复制代码\r\n这种方式和第一种 createSelectorQuery 方式，在api使用方式上会有微妙的差别，这种写法更像原生的DOM写法，设置颜色，样式，直接改变context属性，而不再需要调用对应的api。\r\ntaro-vue 使用 canvas\r\n解决问题： ① taro-vue  createCanvasContext 获取canvas实例无效问题，绘制不出来效果？\r\n因为我们小程序技术选择是 taro-vue2,所以我这里重点将一下，在taro-vue中，目前使用 createCanvasContext 方式获取 canvas 实例，绘制画布从来没有成功过，即便是createCanvasContext能够创建上下文，但是任何东西也画不出来(传this之类的方案试了一个遍)。要是问我为什么？实际我也不知道，只有凹凸实验室的同学应该更清楚，GitHub上也有issue，希望taro团队能够重视起来。\r\n解决方案就是采用最新的api，就是上述讲的第二个方案。代码如下：\r\nimport Taro  from '@tarojs/taro'\r\nconst query = Taro.createSelectorQuery()\r\nquery.select('#myCanvas')\r\n.fields({\r\n    node: true,\r\n    size: true\r\n})\r\n.exec(res=>{\r\n    //TODO:....\r\n})\r\n复制代码\r\n② taro-vue 初始化获取不到canvas上下文怎么办？\r\n在使用taro-vue的过程中，会面临一个问题，就是小程序node节点获取不到的问题，这个有可能是小程序本身的生命周期，和vue生命周期混乱造成的。尤其当我们选择的是组件而不是页面的情况。对于这样的情况，官方文档给出了答案。页面首次渲染完毕时执行，此生命周期在小程序端对应小程序页面的 onReady 生命周期。从此生命周期开始可以使用 createCanvasContext 或 createselectorquery 等 API 访问真实 DOM。\r\n也就是说如果想要获取真是dom节点，我们可以这么做，\r\n组件中\r\nmounted () {\r\n    eventCenter.once(getCurrentInstance().router.onReady, () => {\r\n       const query = Taro.createSelectorQuery()\r\n        query.select('#myCanvas')\r\n        .fields({\r\n           node: true,\r\n           size: true\r\n        })\r\n        .exec(res=>{\r\n        //TODO:....\r\n        })         \r\n    })\r\n}\r\n\r\n复制代码\r\n尴尬的是，这种情况下，有的时候会造成 eventCenter.once() 回调函数不执行的情况，比如说当前组件的是收到v-if控制的情况。那么怎么样解决呢，对于这种情况，我教大家一种解决方案。\r\n我们可以用taro中，通过 Taro.nextTick 方法，将获取元素的任务放在下一次nextTick执行。\r\nmounted(){\r\n  Taro.nextTick(() => {\r\n      // 获取元素\r\n  })   \r\n}\r\n复制代码2 初始化 canvas设置宽高百分比\r\n我们即将解决的问题：\r\n③ 关于canvas 宽高以及缩放比问题，绘制的元素变形，画布的高度真得等于cavans标签设置的宽高么？\r\n<template>\r\n    <view>\r\n        <canvas\r\n            id=\"myPoster\"\r\n            type=\"2d\"\r\n            class=\"canves\"\r\n            :style=\"canvasStyle\"\r\n        />\r\n    view>\r\n<template>\r\n复制代码\r\n在这里我们首先要明白二个概念，\r\n容器宽高: 我们给canvas标签设置的宽高,就是如上代码中的 canvasStyle,是canvas容器的宽高。\r\n画布宽高: 而我们画布的宽高，在新版本api中，是通过获取node节点，动态设置的node.width 和 node.height的值。\r\n我们期望将整个屏幕作为画布，对于不同手机，屏幕尺寸都会有差别，所以要动态获取设备的宽高。这里有一个问题是  容器宽高等于画布宽高吗 , 答案是否定的，为什么这么说呢，原因如下 小程序的canvas画布有一个原始的画布宽高，以及缩放比，而且是按照一倍像素来的，当我们给canvas容器设定容器宽高之后，如果没有对应设置canvas画布的画布宽高以及scale，画出的画布就会严重的变形,我们用一个例子来解释。\r\n比如我们想再画布上半部分区域，画一个图片，当我们期望正常比例画 canvas ,如果我们只给cavans标签加宽高，而不给画布设置宽高的时候。会按照原始画布的宽高比去绘制。期望结果，画布充满屏幕，图片按照正常比列展示。当我们不给 cavnas 画布设置画布宽高 以及缩放比的时候。会发生下面的情况。\r\n\r\n实际效果：\r\n\r\n所以我们初始化的时候要给canvas如下操作。这个在微信的官方文档中，都有说明。\r\nimport Taro, {\r\n    eventCenter,\r\n    getCurrentInstance\r\n} from '@tarojs/taro'\r\n\r\nexport default {\r\n    \r\n    name:'myPoster',\r\n    data(){\r\n        const {\r\n            windowHeight,\r\n            windowWidth,\r\n            pixelRatio\r\n        } = Taro.getSystemInfoSync() /* 动态获取设备的宽和高  */\r\n       return {\r\n            canvasStyle: {           /* cavnas 的宽高 */\r\n                width: windowWidth + 'px',\r\n                height: windowHeight + 'px',\r\n            },\r\n            windowWidth,\r\n            pixelRatio,   /* 屏幕缩放比 */\r\n            windowHeight,\r\n            scale:1       \r\n       }\r\n    },\r\n    mounted(){\r\n        Taro.nextTick(() => {\r\n            const query = Taro.createSelectorQuery()\r\n            query.select('#myPoster').fields({\r\n                node: true,\r\n                size: true\r\n            }).exec(res => {\r\n                let {\r\n                    node,\r\n                } = res[0]\r\n                if (!node) return\r\n                 /* 第一步: canvas 画布的宽高 和 元素的宽高 必须保持相同的长宽比列,否则会变形 */\r\n                const dpr = this.pixelRatio\r\n                const context = node.getContext('2d')\r\n                node.width = windowWidth * dpr\r\n                node.height = windowHeight * dpr\r\n                context.scale(dpr, dpr)\r\n                context.fillStyle = '#fff'\r\n                context.fillRect(0, 0, windowWidth, windowHeight)\r\n            })\r\n        })\r\n    }\r\n}\r\n复制代码\r\n当我们设置好画布宽高，以及缩放比之后，就能按照正常比列进行绘制了。让我们一起看看设置完缩放比之后的图片效果，变成了我们想要的效果。\r\n\r\n接下来就是绘制阶段。三 实战第二阶段： 虚拟点位绘制canvas阶段\r\n在讲解canvas如何生成海报，完美还原设计稿的问题之前，我们应该想一个问题，因为canvas画布，毕竟不是 dom模型，可以使用div或者view,通过自定义设置样式来进行布局。cavnas需要我们画出元素的布局效果，这里就要精确获取画布上每一个元素相对与画布的x，y值。那么首先想到的是如何获取每一个元素精确的x , y 值。1 虚拟点位还原实际设计稿\r\n解决问题： ⑥ 如何根据设计稿，精确还原海报各个元素位置问题。\r\n针对完美还原设计稿的问题，比较靠谱的方案就是,先1:1正常挂在dom元素，然后通过获取元素的位置，来绘制canvas画布的元素位置。我们用一幅图来表示其原理。\r\n\r\n注意事项\r\n注意事项1: 选择正确的元素获取点\r\n这里打一个比方，我们在dom元素中可能存在这样的结构。\r\n<view class=\"box\" >\r\n    <view class=\"parent\" >\r\n        <view class=\"son\" > 这里是将要绘制到canvas中的内容。 view>\r\n    view>\r\nview>\r\n复制代码\r\n对于上面的结构，我们只需要将 son中的内容绘制到 canvas 画布中，那么就有一个问题，我们要获取哪一层级的元素信息(left,top,width,height),答案应该都能猜到，应该是想要绘制的内容最近的一层，也就是面的son层级。如果我们选外层，可能收到父元素padding，margin等影响，导致真实的位置不准确。\r\n注意事项2: 尽量不要给获取信息的元素增加 padding marign，如果绘制文本内容，尽量容器高度等于文本高度\r\n还有一个问题，就是尽量不要给需要绘制的元素，增加 padding marign等属性，如果是绘制纯文本，不要设置lineHeight,如图下示例：\r\n\r\n我们期望在获取 a 点的位置信息， 但是最终却获取 b点的位置信息。如果用 b 点位置来绘制canvas,势必不能完美还原设计稿，所以我们在用这种方式绘制canvas的时候，应该注意这些细节问题。\r\n封装获取位置信息方法\r\n我们需要绘制海报上的每一个点位，首先想到的就是获取小程序元素位置方法，并封装该方法。我们用promise来防止深层次的回调,并且方便使用async await语法糖。废话不多说，一言不合上代码。\r\n    /* 获取元素位置 */\r\n    geDomPostion(dom, isAll) {\r\n        return new Promise((resolve) => {\r\n            Taro.createSelectorQuery().select(dom).boundingClientRect(rect => {\r\n                const {\r\n                    top,\r\n                    left\r\n                } = rect\r\n                /* isAll 是否获取设备宽高等信息 */\r\n                resolve(isAll ? rect : {\r\n                    top,\r\n                    left\r\n                })\r\n            }).exec()\r\n        })\r\n    },\r\n复制代码\r\n小提示：如果用wx原生,或者其他跨端框架mpvue wepy uniapp是的同学，把 Taro 换成 wx 即可。2 绘制网络图片\r\n绘制网络图片\r\n接下来我们要解决的问题： ⑨ 如何绘制网络的图片,两种通过canvas画布api，绘制图片有什么区别?\r\n我们在用canvas绘制图片的时候，对于本地图片可以直接通过canvas提供的drawImage进行绘制，但是对于网络图片是不能这么绘制的，我们首先需要通过getImageInfo来获取图片的临时路径。用getImageInfo绘制网络资源的时候请注意配置一下合法的下载域名，要不然我们是无法成功获取图片信息的。我们首先需要在小程序后台配置downloadFile合法域名。\r\n具体步骤如下：\r\n第一步：\r\n\r\n第二步：\r\n\r\n第三步：\r\n\r\n接下来我们要做的就是读取图片的临时路径，绘制到canvas画布上来。\r\n /* backGroundImageUrl 是我们要画的网络图片的地址  */\r\n this.getImageInfo(this.backGroundImageUrl).then(res=>{\r\n      const {\r\n        width,   /* 宽度 */\r\n        height,  \r\n        path     /* 临时路径 */\r\n      } = res1\r\n      /* 第二步: 绘制banner图 */\r\n    const bannerImage = await this.geDomPostion('#bannerImage')\r\n    this.startTop = bannerImage.top - 30\r\n    this.drawImage(context, node, path, 0, 0, width, height, 0, this.startTop, windowWidth, windowWidth)\r\n    context.save()\r\n })\r\n复制代码\r\nthis.drawImage 是我们封装好的方法，之前说过对于小程序获取 context两种接口方式，两种方式绘制canvas图片，有一些差别，我们马上道来。\r\n新老接口绘制图片的区别\r\n老版本绘制方法\r\n老版本api createCanvasContext可以直接使用 drawImage绘制图片。如下\r\n/* 绘制图片 */\r\ncontext.drawImage(url,x,y,width,height,dx,dy,dwidth,dheight)\r\n复制代码\r\n当时我们项目用的是第二种新api getContext当时获取上下文，所以在图片绘制方式上，会有所改变。\r\n新版本绘制方法\r\n  const image = node.createImage()\r\n  image.src = url\r\n  image.onload = () => {\r\n    context.drawImage(image,x,y,width,height,dx,dy,dwidth,dheight)\r\n  }\r\n复制代码\r\n用新版本的API 绘制图片的同学请注意，这个onload回调是在图片加载完成时候执行的，所以说明是异步的。还有一个注意的地方，相比老版本的 drawImage 第一个参数是图片的路径，而新版本的drawImage第一个参数是image元素。\r\n封装绘制图片方法\r\n刚才在绘制网络图片最后一步，我们调用了 this.drawImage 方法。因为整个海报生成过程中，内部会画入多张图片，所以我们单独封装了一个绘制图片的方法。\r\n/* 绘制图片 */\r\ndrawImage(context, node, url, ...arg) {\r\n    return new Promise((resolve) => {\r\n        const image = node.createImage()\r\n        image.src = url\r\n        image.onload = () => {\r\n            context.drawImage(image, ...arg)\r\n            resolve()\r\n        }\r\n    })\r\n},\r\n复制代码\r\n这样我们就可以通过,async,await判断图片是否加载完成。\r\n简介 context.drawImage\r\n我这里简单给大家介绍一下context.drawImage用法，\r\nCanvasContext.drawImage(imageResource / dom, sx,  sy,  sWidth,  sHeight,  dx,  dy,  dWidth,  dHeight)\r\n复制代码\r\n绘制图像到画布,第一个参数，在老api中代表路径，在新版本api中代表imagDom元素，\r\nsx\r\n需要绘制到画布中的，imageResource / dom 的矩形（裁剪）选择框的左上角 x 坐标\r\nsy\r\n需要绘制到画布中的，imageResource / dom  的矩形（裁剪）选择框的左上角 y 坐标\r\nsWidth\r\n需要绘制到画布中的，imageResource / dom  的矩形（裁剪）选择框的宽度\r\nsHeight\r\n需要绘制到画布中的，imageResource / dom  的矩形（裁剪）选择框的高度\r\ndx\r\nimageResource的左上角在目标 canvas 上 x 轴的位置\r\ndy\r\nimageResource的左上角在目标 canvas 上 y 轴的位置\r\ndWidth\r\n在目标画布上绘制imageResource的宽度，允许对绘制的imageResource进行缩放\r\ndHeight\r\n在目标画布上绘制imageResource的高度，允许对绘制的imageResource进行缩放\r\n我们用一幅图表示各个属性的对应什么。\r\n3 绘制层级图片\r\n解决问题： ④ canvas怎么绘制叠在一起的两张图片，并控制层级？\r\n如果我们绘制叠在一起的两张图片，需要我们做一些什么样的工作呢？首先想到的是层级问题，我们期望背景图片放在下面，例如头像之类的图片放在上面，但是在画布中没有控制zIndex层级的属性，那么怎么样处理这个问题呢 ？答案是实际在canvas中，绘制的先后顺序 就是画布层级顺序，后画的在先画的上层，那么对于这种层级问题呢，我们只要保证层级高的元素后画，层级低的元素先画就可以完美解决，接下来我们在海报中，画上头像，文字等信息。\r\n\r\n<image  class=\"userheadImage\"  id=\"userheadImage\"  :src=\"headImage\"  />\r\n\r\n复制代码\r\n    /*TODO: 绘制头像 */\r\n    const userheadImage = await this.geDomPostion('#userheadImage',true)\r\n    /* 圆形图片 */\r\n    let d = userheadImage.height / 2\r\n    const cx = userheadImage.left + userheadImage.width / 2\r\n    let cy = userheadImage.top + userheadImage.height / 2\r\n    context.arc(cx, cy, d, 0, 2 * Math.PI)\r\n    context.strokeStyle = '#FFFFFF'\r\n    context.stroke()\r\n    context.clip()\r\n    await this.drawImage(context, node, this.headImage, userheadImage.left, userheadImage.top, userheadImage.width, userheadImage.height)\r\n    context.restore()\r\n    this.drawText(context,{ top: userheadImage.top + userheadImage.height + 40 ,left : userheadImage.left - 70 },'我不是外星人「前端Sharing」',18,'normal 600 20px PingFangSC-Regular','#fff')\r\n复制代码\r\n在我们使用context.clip()之后，记得使用context.restore()重置，否则将无法绘制其他元素。\r\n效果：\r\n\r\n我们完美解决了片文本的层级问题，接下来，我们就要绘制海报的主要的内容了。在我们绘制海报的时候，可能会遇到多行文本的情况，那么多对多行文本，我们是怎么解决的呢？\r\n4 绘制多行文本\r\n解决问题：⑤ 如何用canvas绘制，多行文本？\r\ncanvas画的文本，并不能像我们的dom元素下的文本一样，可以自动换行，我们如何还原，多行文本的效果呢。这这里教大家一种方法，我们可以一个一个字的绘制到canvas中，然后把每个字的宽度相加，如果总宽度大于容器的宽度，那么就另外起一行，增加每一行的高度，从头开始画。，我们直接上代码。\r\n       /** 画多行文本\r\n         * @param ctx          canvas 上下文\r\n         * @param str          多行文本\r\n         * @param initHeight   容器初始 top值\r\n         * @param initWidth    容器初始 left值\r\n         * @param canvasWidth  容器宽度\r\n         */\r\n        drawRanksTexts(ctx, str, initHeight, initWidth, canvasWidth) {\r\n            let lineWidth = 0;\r\n            let lastSubStrIndex = 0;\r\n            /* 设置文字样式 */\r\n            ctx.fillStyle = \"#303133\"\r\n            ctx.font = 'normal 400 15px  PingFangSC-Regular'\r\n            for (let i = 0; i < str.length; i++) {\r\n                lineWidth += ctx.measureText(str[i]).width\r\n                if (lineWidth > canvasWidth) { /* 换行 */\r\n                    ctx.fillText(str.substring(lastSubStrIndex, i), initWidth, initHeight)\r\n                    initHeight += 20\r\n                    lineWidth = 0\r\n                    lastSubStrIndex = i\r\n                }\r\n                if (i == str.length - 1) {  /* 无需换行 */\r\n                    ctx.fillText(str.substring(lastSubStrIndex, i + 1), initWidth, initHeight)\r\n                }\r\n            }\r\n\r\n        },\r\n复制代码\r\n调用\r\n/* TODO: 复制多行文本 */\r\nconst rowsText = await this.geDomPostion('#context', true)\r\nthis.drawRanksTexts(context, this.skuName, rowsText.top, rowsText.left, rowsText.width)\r\n复制代码\r\n四 实战第三阶段： 生成二维码\r\n接下来我们做的是绘制二维码，绘制二维码过程，笔者踩了不少的坑，尤其taro-vue不支持createCanvasContext方式，希望我能用自己踩的坑，让大家避开相同的错误，避免大家少走很多弯路。绘制二维码实际并没有想象的复杂，实际就是将链接转换成二维码，让手机扫码或者长按可以识别即可，虽然原理很简单，但是还是有很多注意的细节。\r\n绘制二维码无异于二种方式，第一种方式就是用canvas画出来。第二种将链接转成base64的链接，然后让图片展示链接。 接下来我们针对这两种方式，进行二维码库的技术选型。1 关于二维码库选型\r\n解决问题 ⑨ 如何正确选型生成二维码工具？\r\n形成二维码的过程，我们肯定不能手撸算法，因为即便我们能手撸出来，也会占用大量时间，还会有很多bug,因为现在生成二维码的生态已经很健全了，比如 qrcode.js等等都是非常不错的，但是唯一不好的是不支持小程序端。我这里介绍几个二维码的库\r\nweapp-qrcode\r\n对于比如短链接，不必拼写很长的参数，这种情况用 weapp-qrcode 绰绰有余。这种方式是基于第一种用canvas绘制的。而且是采用老版本的api , 这样的话就有一个问题，如果像用新的 getContext 方式，就需要把源码下载下来，然后改动一下源码，让它支持  getContext 这种方式。我们来简介一下  weapp-qrcode的使用。\r\n使用\r\n//  将 dist 目录下，weapp.qrcode.esm.js 复制到项目目录中  如果用 taro uniapp 等框架 ，可以用  npm install \r\nimport drawQrcode from '../../utils/weapp.qrcode.esm.js'\r\n\r\ndrawQrcode({\r\n  width: 200,\r\n  height: 200,\r\n  canvasId: 'myQrcode',\r\n  // ctx: wx.createCanvasContext('myQrcode'),\r\n  text: 'https://juejin.cn/user/2418581313687390',\r\n  // v1.0.0+版本支持在二维码上绘制图片\r\n  image: {\r\n    imageResource: '../../images/icon.png',\r\n    dx: 70,\r\n    dy: 70,\r\n    dWidth: 60,\r\n    dHeight: 60\r\n  }\r\n})\r\n复制代码\r\n结果\r\n这种方式下，最后确实成功了，因为在做demo的时候，我用的是github短链接。但是一回归笔者公司的项目，很长的链接，奈何生成的二维码特别密集，手机根本识别不出来，无奈前功尽弃了，只能换其他的技术方案，所以笔者选择了第二种比较稳的方式，形成base64文件。\r\nqrcode-base64\r\nqrcode-base64 是将二维码的链接，转成base64的链接，并把这个链接作为src属性赋值给图片。我们先介绍一下基本用法。\r\n下载\r\nnpm install qrcode-base64\r\n复制代码\r\n使用\r\nimport QR from 'qrcode-base64'\r\n\r\nvar imgData = QR.drawImg(this.data.codeText, {\r\n    typeNumber: 4,\r\n    errorCorrectLevel: 'M',\r\n    size: 500\r\n})\r\n// 返回输出base64编码imgData\r\n复制代码\r\n如上述代码块所示，imgData就是生成的base64链接，我们可以直接把它作为图片的src，然后让canvas将图片绘制到我们的海报中去，但是又来了一个问题，canvas是不支持绘制base64的链接图片的，真机上没有任何效果，真实一步十个坑啊，我们还得想办法解决这个问题。2 canvas 绘制 base64图片\r\n解决问题 ⑦ canvas怎么绘制base64的图片\r\n对于上面说到的canvas不支持base64的图片，那么我们还要把二维码绘制到海报中，那么并不是没有办法，我们可以用小程序提供的文件系统来解决问题。\r\n小程序文件系统\r\nwx.getFileSystemManager 获取全局唯一的文件管理器,返回值 类似于node中的fs.\r\nwriteFile 写入文件，可以将图片写入系统中。\r\nconst fs = wx.getFileSystemManager()\r\n\r\nfs.writeFile(/* 写入文件 */)\r\n复制代码\r\n封装方法\r\n封装绘制二维码方法\r\n  /* 生成二维码 */\r\n        drawCode(ctx, node, x, y) {\r\n            return new Promise((resolve) => {\r\n                const codeImageWidth = 150   /* 绘制二维码宽度 */\r\n                const canvasImageWidth = 85 /* 二维码绘制到canvas的宽度 */\r\n                const left = x - 15          /* left 值 */\r\n                const top = y - 22           /* top 值 */\r\n                const LogoWidth = 15       /* 二维码logo宽度 */\r\n                const url = 'https://juejin.cn/user/2418581313687390'\r\n                \r\n                const base64 = QR.drawImg(url, {\r\n                    typeNumber: 4,\r\n                    errorCorrectLevel: 'L',\r\n                    size: codeImageWidth\r\n                })\r\n                /* 创建读写流 */\r\n                const fs = Taro.getFileSystemManager()\r\n                const times = new Date().getTime()\r\n                const codeimg = Taro.env.USER_DATA_PATH + '/' + times + '.png'\r\n\r\n                /* 将base64图片写入 */\r\n                fs.writeFile({\r\n                    filePath: codeimg,\r\n                    data: base64.slice(22),  /* 数据流 */\r\n                    encoding: 'base64',      \r\n                    success: async () => {\r\n                        const offset = (canvasImageWidth - LogoWidth) / 2 /* 偏移量 */\r\n                         /* 绘制图片 */\r\n                        await this.drawImage(ctx, node, codeimg, 0, 0, codeImageWidth, codeImageWidth, left, top, canvasImageWidth, canvasImageWidth)\r\n                        await this.drawImage(ctx, node, this.logoUrl, left + offset, top + offset, LogoWidth, LogoWidth)\r\n                        resolve()\r\n\r\n                    }\r\n                })\r\n            })\r\n\r\n        },\r\n复制代码\r\n如上所示我们完成了二维码的绘制。让我们来看一下如何使用。\r\n使用\r\n我们在wxml上写一个元素，作为占位，方便我们可以获取二维码的位置。\r\n<view id=\"qrCode\" class=\"store-uscode\" />\r\n复制代码\r\n/*TODO: 第四步：绘制二维码 */\r\nconst qrCode = await this.geDomPostion('#qrCode')\r\nawait this.drawCode(context, node, qrCode.left - 20, qrCode.top - this.cavnsOffsetop)\r\n复制代码3 调试二维码大小，如何让二维码可以识别，绘制二维码logo\r\n解决问题：⑩ 生成的二维码，识别不出来怎么办。\r\n有的时候我们展示的二维码比较小的时候，因为色块太密，手机也会有无法识别的情况。那么我们如何调整二维码，有能让页面尽量高保真的还原设计稿呢，这里教大家一个小技巧，可以去先去二维码生成网站，先适配手机可以识别的最佳比例，避免识别不出来的情况。推荐网站：草料二维码 ： https://cli.im/  我们可以在线调试二维码的像素，和 logo的大小，直到调整出，能够符合设计的最佳大小。\r\n在线调整二维码\r\n\r\n微调整\r\n有的时候，我们需要对二维码大小进行微调整，我这里建议在调试阶段，建立起常量控制，并调整写好调整方法或公式。这样做的好处是，每当我们作出微调整的时候，不会影响因为当前调整而再计算，如下。\r\nconst codeImageWidth = 150   /* 绘制二维码宽度 */\r\nconst canvasImageWidth = 85  /* 二维码绘制到canvas的宽度 */\r\nconst left = x - 15          /* left 值 */\r\nconst top = y - 22           /* top 值 */\r\nconst LogoWidth = 15         /* 二维码logo宽度 */\r\n\r\nconst offset = (canvasImageWidth - LogoWidth) / 2 /* 偏移量 */\r\n复制代码4 完事具备，生成海报图片，转发好友\r\n我们已经跑完整个流程。就剩下最后一步，生成海报图片，转发图片了。生成海报可以用微信小程序canvas中的canvasToTempFilePath生成图片路径，然后通过previewImage方法浏览图片，浏览图片时候就可以唤醒微信小程序的分享好友功能了。这里有一点我们应该注意，就是要截取canvas的有效高度。\r\n\r\n上代码：\r\n/* 生成海报 */\r\nmakePc(node) {\r\n    const {\r\n        startTop,    /* 截取canvas画布的顶部 */\r\n        endTop,      /* 截取canvas画布的底部 */\r\n        windowWidth  /* 屏幕宽度 */\r\n    } = this\r\n    const _this = this\r\n    Taro.canvasToTempFilePath({\r\n        x: 0,\r\n        y: startTop,\r\n        width: windowWidth,\r\n        height: endTop - startTop,\r\n        destWidth: windowWidth * 3,\r\n        destHeight: (endTop - startTop) * 3,\r\n        canvas: node,\r\n        success: function (res) {\r\n            Taro.hideLoading()\r\n            Taro.previewImage({\r\n                urls: [res.tempFilePath]\r\n            })\r\n\r\n        }\r\n    })\r\n}\r\n复制代码\r\ncanvasToTempFilePath 注意事项\r\n还是回到最初的那个问题，在调用 canvasToTempFilePath 方法的时候，新老 api 传递的参数不同。\r\n在老版本API中 ，通过createCanvasContext 方式绘制的canvas ，canvasToTempFilePath 的配置属性canvas， 微信开发者文档是这么解释的 canvas 画布标识，传入 canvas 组件实例 （canvas type=\"2d\" 时使用该属性）, 也就是canvas上下文context。\r\n但是我们用的是新版本 ,通过 getContext 方式绘制的canvas ,当我们传入的是context,竟然没有效果，what? 还有这种事，难道是微信开发者文档出现了问题吗？后来发现在这种方式下，传入的是通过 query.select获取的canvas 的node节点，真是坑不少啊～～～。一口老血都要喷出来了五 总结\r\n在做这个功能的时候，真是遇到了很多坑，甚至于有一种欲哭无泪的感觉，不过踩着坑一路走来，确实也收获蛮多。"}
{"title": "微信小程序web-view内嵌H5使用PHP完成支付功能 ", "author": "Rolan", "pub_time": "2021-2-19 11:06", "content": "在开发过程中，遇到使用微信小程序web-view内嵌H5完成支付的业务，我们该怎么去实现？一、设计思路1、使用PHP请求接口获取wx_data_package支付包数据2、使用jweixin.js把wx_data_package数据传到小程序3、小程序获取数据，调起支付界面完成支付，并返回支付是否成功4、后台根据返回的数据判断支付是否成功，然后进行相关业务处理二、前期准备1、创建PHP文件，index.php主界面，success.php支付成功，error.php支付失败2、新建WeChat项目，并创建下面目录三、实现代码1、index.php<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>支付测试</title>\r\n    <script type=\"text/javascript\" src=\"https://res.wx.qq.com/open/js/jweixin-1.3.2.js\"></script>\r\n    <style>\r\n        .btn {\r\n            padding: 10px 20px;\r\n            text-align: center;\r\n            background: #647357;\r\n            color: #fff;\r\n\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <?php\r\n    // 假设wx_data_package是请求接口返回的支付数据包\r\n    $wx_data_package = '{\"package\":\"prepay_id=wx164122404495953ff5f88672224070000\",\"appid\":\"wxa5dasdfasdf2231\",\"sign\":\"m8i6LKiu+adJJouVx6XasdaEOr+K5FIuV/luTEgrqE+APuO/oEVK6Fadfn4NiJMqGasdfhlgdj2FDasdf9oHSAnmHaPKiZgK37oCVe+3HyGGirDWZLOSdpI4hVvasdLpPBbmbvM6Xvg2TLwyO41Fg3fjIEasdrhkxCJss2B5uXa3BrRyL3LEC01CbJfC05uDwRRC+a8erHzRjoscB+Kjepnhcfp/PVO9v+N6b5oKmTUCdhaF85n3U2PSFS7yzp6473oEAPi8jNiwM/dtZZvo+y7z4urWoebeFfO/5l9Bx2EWaRstQqEXgh+lLsVxNiccHal3nfDcqNkw==\",\"signType\":\"RSA\",\"noncestr\":\"45bd4991f99048badew9528dqfca9b7\",\"timestamp\":\"1613488960\"}';\r\n    ?>\r\n    <div class=\"btn\" onclick=\"pay()\">支付</div>\r\n    <script>\r\n        // 把wx_data_package传到小程序\r\n        function pay() {\r\n            const url = `../wePay/wePay?wxPageData=<?php echo urlencode($wx_data_package); ?>`\r\n            wx.miniProgram.navigateTo({\r\n                url: url\r\n            })\r\n        }\r\n    </script>\r\n</body>\r\n\r\n</html>\r\n2、success.php和error.php两文件随便添加点东西进去做一个区别就可以了3、webview.wxml// pages/webview/webview.wxml\r\n<web-view src=\"{{src}}\"></web-view>\r\n4、webview.js// pages/webview/webview.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    src: \"http://php.com/\"\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n    if (options.payFlag !== undefined)\r\n      if (options.payFlag == \"true\") {\r\n        this.setData({\r\n          src: \"http://php.com/success.php\"\r\n        })\r\n      } else {\r\n        this.setData({\r\n          src: \"http://php.com/error.php\"\r\n        })\r\n      }\r\n  },\r\n})\r\n5、wePay.js// pages/wePay/wePay.js\r\nPage({\r\n\r\n  data: {\r\n\r\n  },\r\n  payment(data) {\r\n    wx.requestPayment({\r\n      'timeStamp': data.timestamp,\r\n      'nonceStr': data.noncestr,\r\n      'package': data.package,\r\n      'signType': data.signType,\r\n      'paySign': data.sign,\r\n      'success': function (res) {\r\n        wx.navigateTo({\r\n          url: '../webview/webview?payFlag=true',\r\n        })\r\n      },\r\n      'fail': function (res) {\r\n        wx.navigateTo({\r\n          url: '../webview/webview?payFlag=false',\r\n        })\r\n      }\r\n    })\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n    let wxPageData = JSON.parse(decodeURIComponent(options.wxPageData))\r\n    console.log(wxPageData)\r\n    this.payment(wxPageData)\r\n  },\r\n})\r\n四、实现效果1、主界面2、调起支付时3、支付成功或失败后"}
{"title": "开工啦-耗时4天写了一个小程序 ", "author": "Rolan", "pub_time": "2021-2-19 17:22", "content": "开工啦！新的一年新的气象;首先祝愿大家在新的一年财运滚滚。在过春节的这几天笔者花了大约 4 天 时间做了一个简易版本的【日程安排吧】微信小程序。做此程序的主要目的有两个：给女朋友情人节一个礼物;想记录一下自己每次出游的日程安排以及照片假如女朋友让你安排一下周末出去玩儿的攻略，我们可能会搜索一堆资料，然后大致的在微信里面回复她说，什么什么时间做什么；其实很多时候，我们做了一堆攻略，拍了一堆照片;照片和记录没有更好的关联起来，其次朋友找我们要起去某某地方的攻略时，我们不得不翻箱倒柜的去找自己之前的记录;在我们遇到手机损坏图片没有来得及存放在云端时，一部分珍贵的照片就会消失掉。诚然，现如今有一堆类似于【小红书】类型的 App 或者软件去做攻略分享的软件；此类App功能及广告比较多，无法集中精力去做指定的事情；还有就是想做一个自己的小程序记录一下自己/对象的出游。前言: 此小程序共计耗时 4 天初步完成，有诸多不足之处敬请谅解。首页主要功能:展示个人创建的日程安排以及别人公开的日程安排;查看个人相关的功能首页-个人创建的首页-公开个人信息页如何创建一个日程？日程创建主要分为三个步骤:填写日程名称;选择日程时间填写内容之所以如此设计的原因主要因为，想减少一下手机端编写列表；做成类似于 xmind 的形式，也许更加直观。创建-填写名称创建-选择时间创建-填写安排预览日程主要有一下几个特点:背景全屏自动播放自己上传的图片;背景图片点击进入图片预览模式，长按可以下载图片;可以查看日程安排详情，点击左侧按钮可以将详情收缩到 mini 模式;可以点赞或则编辑日程日程详情-全预览日程详情-mini 模式在我们已经创建日程之后，想要上传一些图片可以选择编辑日程;日程的编辑中您可以再次对名称，时间，内容等进行修改；也可以点击上传自己的图片。除了以上功能，还有一些简单的点:自定义首页和详情页展示顺序;给程序员小哥提需求自定义顺序程序员小哥提需求此公众号做了一个技术博文，且作为一个合格的程序员小哥肯定是要聊聊整个程序是什么做的？此小程序共计耗时 4 天初步完成，有诸多不足之处敬请谅解。微信 小程序端 主要使用了:微信原生小程序开发;(不要问我为啥，因为小程序原生开发真的不难);组件库部分使用 vant 组件；其余为自定义组件项目目录如下:后端程序的技术栈为: Koa2+mysql+sequlizejs+cls-hooked+redis+typescript功能点:cls-hooked\r\nsequlize\r\nkoa-static\r\nredis\r\n项目目录如下:"}
{"title": "微信小程序中使用Echarts和分包 ", "author": "Rolan", "pub_time": "2021-2-22 09:14", "content": "假期虽然结束了，但是它以另外一种形式展示我们身上（摸摸自己的小肚子）。在小程序上以图形化显示数据就是分给我的假期预研任务，查了一下网上大佬们的文章了解到了Ucharts，F2，Wx-charts和Echarts，只尝试了F2和Echarts，由于Echarts的最近更新最近和我对Echarts更为熟悉，所以我选择了Echarts，F2也试了下，虽然弄出来了，但是我不是太熟悉所以就放弃了。进入正题\r\n首先我是看到别人的文章写Echarts的，给了官网的传送门，然后就去官网顺着看了，比较简单。大体上的步骤\r\n1、下载官网例子。\r\n2、把官网例子中的ec-canvas文件夹复制到项目目录中。\r\n3、在具体的页面中像使用组件一样引入ec-canvas。\r\n4、在具体的页面的js中进行初始化。\r\n在下载完官网例子后，找到ec-canvas文件夹，里面有echarts.js,wx-canvas.js还有ec-canvas四件套。然后把这个文件夹复制到自己项目的目录下，一开始我是放到utils下的，后来分包之后就放别的地方，这里就当放在utils下了。然后项目就大了700+KiB。\r\n页面中\r\nxxx.json\r\n{\r\n  \"usingComponents\": {\r\n    \"ec-canvas\": \"xxx/xxx/xxx/ec-canvas/ec-canvas\"\r\n  }\r\n}\r\n复制代码\r\nxxx.wxml\r\n<view class=\"container-echarts margin-top-10\">\r\n  <ec-canvas class=\"mycharts\" id=\"mychart-dom-bar\" canvas-id=\"mychart-bar\" ec=\"{{ ec }}\">ec-canvas>\r\nview>\r\n复制代码\r\nxxx.js 首先要引入echarts然后才能用下面的initChart方法，所以根据放置的ec-canvas的路径引入echarts。\r\nimport * as echarts from 'xxx/xxx/xxx/ec-canvas/echarts'; // 根据放置的ec-canvas的路径引入echarts\r\nlet chart = null  // 用一个变量保存echarts的初始化\r\nlet options = {   // 图形配置，用过echarts的人都知道是嘛意思～ 这里给出官网线图的基础例子\r\n  xAxis: {\r\n        type: 'category',\r\n        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\r\n    },\r\n    yAxis: {\r\n        type: 'value'\r\n    },\r\n    series: [{\r\n        data: [150, 230, 224, 218, 135, 147, 260],\r\n        type: 'line'\r\n    }]\r\n}  \r\nfunction initChart(canvas, width, height, dpr) {  // 这里的canvas,width,height,dpr都可以不用管\r\n  const chart = echarts.init(canvas, null, {\r\n    width: width,\r\n    height: height,\r\n    devicePixelRatio: dpr // 像素\r\n  });\r\n  canvas.setChart(chart);\r\n  chart.setOption(options);\r\n  return chart;\r\n}\r\n\r\nPage({\r\n  data: {\r\n    ec: {\r\n      onInit: initChart  // 这里不要加括号哦！\r\n    }\r\n  }\r\n});\r\n复制代码\r\n保存运行，到这一步理论上echarts已经可以显示了，实际怎么样还要自己调试的。\r\n用一个chart变量保存echarts的初始化，官网上把options也写在方法里，我给拿出来了。那chart有什么用呢？因为大部分的数据都是异步获取的，所以要动态渲染echarts。当拿到数据后，这个chart就用上了。\r\nchart.setOption({\r\n  xAxis: {\r\n    data: newData.map(item => {\r\n      return item[0];\r\n    })\r\n  },\r\n  series: {\r\n    data: newData.map(item => {\r\n      return item[1];\r\n    })\r\n  }\r\n})\r\n复制代码\r\n这里关于data的数据格式，看每个人的options里面要渲染的是什么图吧。echarts的数据更新可以直接用setOption。\r\n在开发者工具中的放大缩小滚动没有用，但是上传到体验版上后在手机上是好的。微信对canvas有type=\"2d\"，在ec-canvas中想要使用type=\"2d\"的话，要改动ec-canvas.js\r\ndata: {\r\n  isUseNewCanvas: true // 这里改成true， 默认是false\r\n}\r\n复制代码\r\n因为：isUseNewCanvas默认是false，是旧版的canvas。\r\n\r\n<canvas wx:if=\"{{isUseNewCanvas}}\" type=\"2d\" class=\"ec-canvas\" canvas-id=\"{{ canvasId }}\" bindinit=\"init\" bindtouchstart=\"{{ ec.disableTouch ? '' : 'touchStart' }}\" bindtouchmove=\"{{ ec.disableTouch ? '' : 'touchMove' }}\" bindtouchend=\"{{ ec.disableTouch ? '' : 'touchEnd' }}\">canvas>\r\n\r\n<canvas wx:else class=\"ec-canvas\" canvas-id=\"{{ canvasId }}\" bindinit=\"init\" bindtouchstart=\"{{ ec.disableTouch ? '' : 'touchStart' }}\" bindtouchmove=\"{{ ec.disableTouch ? '' : 'touchMove' }}\" bindtouchend=\"{{ ec.disableTouch ? '' : 'touchEnd' }}\">canvas>\r\n\r\n复制代码echarts.js体积大的问题，上传项目2MiB限制问题\r\n就下载的ec-canvas里面的echarts.js有几百KiB，相对于2MiB的来说挺大的，当我上传项目的时候提示我超出限制，那能想到的就是减小echarts.js的体积和分包两个能即时见效的方法了。echarts.js体积大的问题\r\n在echarts的官网有按需构建的方法，进入下面的在线定制，选择自己需要图，我就选了折线图，坐标系选了直角坐标系，组件里除了刷选，工具栏和自定义图形外别的都选了，其它选项把svg也勾上了，然后点击下载进入building页面，这里等它构建完成会自动下载一个echarts.min.js文件，大小最后少了200来KiB。然后把它重命名成echarts.js替换进ec-canvas里。上传项目2MiB限制问题\r\necharts.js的体积减少了，但是上传的限制问题还在，那就是分包了。\r\n在app.json里面，有一个subpackages\r\n{\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"xxx/xxx\",\r\n      \"name\": \"xxx\",\r\n      \"independent\": false,\r\n      \"pages\": [\r\n        \"pages/xxx\",\r\n        \"pages/xxx\",\r\n        \"pages/xxx\"\r\n      ]\r\n    },\r\n    {\r\n      \"root\": \"baoziTask/\",\r\n      \"name\": \"baozi\",\r\n      \"pages\": [\r\n        \"pages/roubaozi/roubaozi\"\r\n      ]\r\n    }\r\n  ],\r\n}\r\n复制代码\r\n这个分包在官网上讲的挺简单的，但是在我使用时是这样理解的。\r\nroot是要分包的路径，我是放到根目录的。那么baoziTask下的所有文件都会被认为是一个包。那不在这个baoziTask路径下的文件都会被打包进app这个主包内。\r\nname就是分包的别名，预下载的时候会用，这个预下载就当在某个页面的时候，想主动下载这个可能被使用的分包，以提高访问速度。比如当我进入某个页面的时候，很大可能会点击某处跳转到某个分包里面，这个时候可以预下载这个分包，而不用跳转的时候才下载这个分包。\r\nindependent是分包是否独立，但是我没用过就没有直观的感觉。说是可以单独运行，不依赖app这个主包。这个需要配置，不是代码的下载，配置preloadRule，具体的话得看官网和自己尝试了。\r\npages就更好理解了啊，就是包内的页面呗。\r\n想要跳转到这些分包内的页面的时候给跳转的url写对路径就可以了，就比如跳转到roubaozi的时候url写⬇️面这样：\r\nurl: '/baoziTask/pages/roubaozi/roubaozi'\r\n复制代码\r\n那怎么查看分包成功呢？\r\n在开发者工具右上角有一个详情按钮，点击查看详情侧滑框，可以看到\"本地代码\"这一行，后面的大小可以点击，点击后可以看到主包和各个分包的大小。看到主包没有超过2MiB的话，那就可以上传成功了！\r\n群众：为什么你要在KB和MB中间加个 i ？小傲娇：因为要准确表达是1024"}
{"title": "简单实现个小程序计算属性 ", "author": "Rolan", "pub_time": "2021-2-22 09:29", "content": "本来之前技术栈一直是Vue，后来做小程序了，各种不习惯，尤其是少了计算属性和监听器，wxml里面又不能直接放函数，又没有Vue那种过滤器的写法。也许有人说直接uni-app就好了，但是平时做跨端的很少，所以我偏不用uni-app，我就要自己写一个。以下内容纯靠个人臆想，搞出来的computed属性虽然能用，但仅供参考。思路\r\n出于偶然发现了小程序能够自己重写生命周期钩子，听说很多的一些统计sdk也都是利用这样的机制做事件打点统计啥的，于是这么好玩的东西，我决定参一脚试一下好不好玩。computed属性的扩展就是在重写的生命周期里面做的。\r\n基本思路其实很简单，就是重写下setData用来监听修改的值，同步更新一下computed,为了让computed能够直接使用在wxml里就把computed上的属性全部挂在到data上去，更新也使用的setData更新。本人不善言辞，直接上，上再解释。\r\n// computed.js\r\nconst oldPage = Page\r\nPage = function (app) {\r\n    let oldOnLoad = app.onLoad;\r\n    app.onLoad = function (options) {\r\n        // 存一下原来的setData\r\n        let o_setData = this.setData\r\n        // 用于保存依赖\r\n        let dep = {}\r\n        // 重写setData\r\n        this.setData = function (o, fn) {\r\n            // 调用原生setData\r\n            o_setData.call(this, o, function () {\r\n                // 如果定义有computed属性则判断一下是不是改变了计算属性中所依赖的变量\r\n                if (app.computed) {\r\n                    // 循环遍历\r\n                    Object.keys(dep).map(c => {\r\n                        Object.keys(o).map(i => {\r\n                            // 找出需要触发更新的计算属性，兼容下几种写法\r\n                            if (dep[c].includes(i) || dep[c].includes(i.split('.')[0]) || dep[c].includes(i.split('[')[0])) {\r\n                                o_setData.call(this, {\r\n                                    [c]: app.computed[c].call(this, this.data)\r\n                                })\r\n                            }\r\n                        })\r\n                    })\r\n                }\r\n                // 触发setData回调\r\n                fn && fn.call(this)\r\n            })\r\n        }\r\n        // 收集依赖，并将computed值挂载到data上\r\n        if (app.computed) {\r\n            // 为了不污染原来的data，深拷贝一份\r\n            let _data = JSON.parse(JSON.stringify(this.data))\r\n            let bufferDep = []\r\n            Object.keys(_data).map(key => {\r\n                let val = _data[key]\r\n                Object.defineProperty(_data, key, {\r\n                    // 触发收集\r\n                    get: function () {\r\n                        bufferDep.push(key)\r\n                        return val\r\n                    }\r\n                })\r\n            })\r\n            Object.keys(app.computed).map(key => {\r\n                // 重置依赖\r\n                bufferDep = []\r\n                this.setData({\r\n                    // 下面这里调一下computed将值挂载到data上，并且同时会触发收集\r\n                    [key]: app.computed[key].call(this, _data)\r\n                }, function () {\r\n                    // 将每一个computed的依赖存好\r\n                    dep[key] = bufferDep\r\n                })\r\n            })\r\n        }\r\n        oldOnLoad.call(this, options)\r\n    }\r\n    return oldPage(app)\r\n}\r\n复制代码\r\n使用:\r\n// app.js\r\nrequire('./computed.js')\r\nApp({})\r\n复制代码\r\n// index.js\r\nPage({\r\n  data: {\r\n    a: 0,\r\n    k: [0, 0, 0, 1],\r\n    c: {\r\n      a: 9\r\n    }\r\n  },\r\n  computed: {\r\n    b(data) {\r\n      return data.c.a + data.a + data.k[0]\r\n    }\r\n  },\r\n  onLoad() {\r\n    this.setData({\r\n      a: 8,\r\n      'c.a': 10,\r\n      [`k[${0}]`]: 999\r\n    }, () => {\r\n      console.log(this.data.b)\r\n    })\r\n  },\r\n})\r\n复制代码\r\n\r\n{{a}}\r\n{{b}}\r\n复制代码\r\n显示结果如图：\r\n\r\n小启发\r\n其实小程序里面很多api都能重写或者使用defineProperty来监听，可以用来解决日常很多的开发问题，像啥页面栈问题，随手加个watch监听器，加个store全局数据管理啥的估计都不是啥大问题。重写页面各种生命周期啥的，只要不乱搞好像也没什么大问题。"}
{"title": "从微信小程序到鸿蒙js开发【08】——表单组件&注册登录模块 ... ... ", "author": "Rolan", "pub_time": "2021-2-22 09:33", "content": "在微信小程序中，提供了form组件，可以将input、picker、slider、button等全部放在form中，并设置name属性实现类似html的表单提交功能。鸿蒙js目前是没有form组件的，因此我们需要在提交时手动获取输入框、选择框等的值，自行构建数据对象。1、登录模块这里接着上一篇，通过dialog组件实现了模态登录和注册的窗口。登录窗口的效果如下：每一行中，放置图标和input输入框。input使用的是默认样式，看起来还是很清爽的。hml视图层：手机号的input设置type=\"number\"，在获取焦点后键盘自动弹出为数字键盘。密码框type=\"password\"，弹出普通键盘，且输入的字符会变为圆点，也可点击右侧眼睛图标查看密码内容。在最开始使用input时，尝试使用this.$element(\"id\").value获取，但这样是获取不到的。    // 登录\r\n    login() {\r\n        prompt.showToast({\r\n            message: \"手机号: \" + this.$element(\"phoneInput\").value +\r\n            \", 密码: \" + this.$element(\"pwdInput\").value,\r\n            duration: 5000\r\n        })\r\n    }因此需要使用input的onchange属性绑定值改变的事件，通过e.value取到改变后的值，并赋给data中的变量。顺便提一下，今天突然找到了console打印日志的查看方式。需在最下方打开\"HiLog\"视图，搜索\"app Log\"后即可查看。console.log()的内容需设置日志等级\"debug\"，console.info()则在\"info\"等级即可查看。     // 手机号输入框\r\n    inputPhone(e) {\r\n        this.phone = e.value;\r\n    },\r\n    // 密码输入框\r\n    inputPwd(e) {\r\n        this.pwd = e.value;\r\n    },\r\n    // 登录\r\n    login() {\r\n        console.log(\"手机号: \" + this.phone + \"密码: \" + this.pwd);\r\n    }这里能够正常获取输入框的值了，就可以在点击按钮后将值传给后台服务器，进行登录的校验。按钮的点击方法通过onclick进行绑定。    // 登录\r\n    login() {\r\n        fetch.fetch({\r\n            url: this.url + \"/litemall/user/login?phone=\" + this.phone + \"&pwd=\" + this.pwd,\r\n            responseType: \"json\",\r\n            success: res => {\r\n                let data = JSON.parse(res.data);\r\n                console.info(JSON.stringify(data));\r\n                if (0 != data.code) {\r\n                    prompt.showToast({\r\n                        message: data.msg,\r\n                        duration: 3000\r\n                    })\r\n                } else {\r\n                    let userInfo = data.data;\r\n                    userInfo.age = this.getAge(userInfo.birthday);\r\n                    this.userInfo = userInfo;\r\n                    this.$element(\"loginDialog\").close();\r\n                }\r\n            }\r\n        })\r\n    }登录失败，用提示框提示用户失败原因：登录成功，用户信息赋值给页面并关闭dialog：这里日志的打印需要使用JSON.stringify()，否则会打印\"object\"。input组件和button组件都提供了丰富的type可供选择，具体可参考官方文档。https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-input-0000000000611673css渲染层：.loginDialog {\r\n    width: 80%;\r\n    height: 400px;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n}\r\n.formItem {\r\n    width: 100%;\r\n    height: 100px;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n    margin-bottom: 20px;\r\n}\r\n.formItem>image {\r\n    width: 70px;\r\n    height: 70px;\r\n    margin: 0 10px 0 10px;\r\n}\r\ninput {\r\n    flex: 1;\r\n}\r\n.inputBtn {\r\n    width: 200px;\r\n    height: 70px;\r\n}2、注册模块注册模块同样使用dialog弹窗，内容比登录要更丰富一些：hml视图层：                \r\n                    \r\n                        \r\n                            \r\n                            \r\n                        \r\n                        \r\n                            \r\n                            \r\n                        \r\n                        \r\n                            \r\n                            \r\n                        \r\n                        \r\n                            \r\n                            \r\n                        \r\n                        \r\n                            \r\n                            {{ gender }}\r\n                        \r\n                        \r\n                            \r\n                            {{ birthday }}\r\n                        \r\n                        注册\r\n                    \r\n                上面四个依然是input输入框，随后两个使用了picker选择框组件。需注意，选择框组件标记中需放置文本内容，通过点击这里的文本在页面下方弹出选择框。type=\"text\"是文本选择框，通过range属性绑定一个字符串数组，效果如下：onchange属性绑定选择一项后的处理方法，e.newValue是选项值，e.newSelected是选项下标。性别选择框js逻辑层代码：export default {\r\n    data: {\r\n        ...\r\n        gender: \"点击选择性别\",\r\n        genderVal: \"\",\r\n        genders: ['保密', '男', '女'],\r\n        ...\r\n    },\r\n    ...\r\n    // 性别选择器\r\n    chooseGender(e) {\r\n        this.gender = e.newValue;\r\n        this.genderVal = e.newSelected;\r\n    },\r\n    ...\r\n}type=\"date\"是日期选择器，可以通过属性指定开始、结束、当前日期，通过onchange绑定选择后的处理方法。效果如下：e.year/month/day分别为选择的年/月/日，注意month比实际月份小1。生日选择框js逻辑层：export default {\r\n    data: {\r\n       ...\r\n        birthday: \"点击选择生日\",\r\n        birthdayVal: \"\"\r\n    },\r\n    ...\r\n    // 生日选择器\r\n    chooseBirthday(e) {\r\n        let month = (e.month + 1) + \"\";\r\n        if (month.length == 1) {\r\n            month = \"0\" + month;\r\n        }\r\n        let day = e.day + \"\";\r\n        if (day.length == 1) {\r\n            day = \"0\" + day;\r\n        }\r\n        let birthday = e.year + \"-\" + month + \"-\" + day;\r\n        this.birthday = birthday;\r\n        this.birthdayVal = birthday;\r\n    },\r\n    ...\r\n}这里开发者工具有一个bug，type=\"date\"在提示时错误拼写成了\"data\"。选择器还有time, datetime, multi-text三种，鸿蒙的封装确实很好看好用。注册的方法：    // 注册\r\n    register() {\r\n        fetch.fetch({\r\n            url: this.url + \"/litemall/user/register\",\r\n            method: \"POST\",\r\n            data: {\r\n                username: this.username,\r\n                password: this.pwd,\r\n                gender: this.genderVal,\r\n                birthday: this.birthdayVal,\r\n                nickname: this.nickname,\r\n                mobile: this.phone\r\n            },\r\n            header: {\r\n                \"Content-Type\": \"application/json;charset=UTF-8\"\r\n            },\r\n            responseType: \"json\",\r\n            success: res => {\r\n                let data = JSON.parse(res.data);\r\n                console.info(JSON.stringify(data));\r\n                if (0 != data.code) {\r\n                    prompt.showToast({\r\n                        message: data.msg,\r\n                        duration: 3000\r\n                    });\r\n                } else {\r\n                    prompt.showToast({\r\n                        message: \"注册成功\",\r\n                        duration: 3000\r\n                    });\r\n                    this.$element(\"registerDialog\").close();\r\n                }\r\n            }\r\n        })\r\n    }还需要注意，如果使用fetch发送请求，且data给的是一个对象时，请求头的Content-Type自动设置为application/x-www-form-urlencoded。如果服务器接收json数据，则需要设置请求头，否则会报如下错误。Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'application/x-www-form-urlencoded;charset=UTF-8' not supported]注册一下："}
{"title": "从微信小程序到鸿蒙js开发【10】——CSS3动画&JS动画&定时器 ... ... ", "author": "Rolan", "pub_time": "2021-2-22 14:51", "content": "在进入APP时，通常都会有一个欢迎界面，用于展示APP的名称、logo，并预先加载部分数据。既然是欢迎页面，自然少不了一些动画元素。简单运用了CSS3和JS的动画效果，progress组件以及倒计时撸了一个欢迎页面。直接上效果：\r\n\r\n1、基于CSS3的动画效果\r\n1.1 给动画元素设置animation属性。\r\n\r\nanimation-name：动画名\r\nanimation-duration：动画持续时间\r\nanimation-delay：动画开始前延迟时间\r\nanimation-iteration-count：动画重复次数\r\nanimation-timing-function：动画执行速度\r\nanimation-fill-mode：动画模式\r\n\r\n\r\n1.2 用\"@keyframes 动画名\"匹配设置动画规则。\r\n@keyframes an1 {\r\n        from {\r\n            transform: rotate(180deg);\r\n            opacity: 0.3;\r\n        }\r\n        to {\r\n            transform: rotate(360deg);\r\n            opacity: 1.0;\r\n        }\r\n}\r\n复制代码\r\n除from，to外，还可以使用百分比（如20%{...})方式设置动画途中的效果。\r\n以上两步，就实现了gif图中HUAWEI的logo旋转和逐渐清晰的动画效果。\r\n2、基于JS的动画效果\r\n2.1 动画元素给定id/ref等可以用于元素匹配的属性。\r\n\r\n复制代码\r\n2.2 在onShow()方法中获取元素实例，并用animate()方法给定动画规则和基本属性。注意这一步在onInit()和onReady()中执行是没有效果的。\r\nanimate()接受两个参数，第一个为数组，指定动画的关键帧效果。第二个为对象，指定动画的基本属性。\r\n2.3 调用play()方法开始动画执行。\r\n    onShow() {\r\n        // 设置动画\r\n        let textImg = this.$element(\"textImg\").animate([\r\n            {\r\n                transform: {translateY: '200px'}, opacity: 0.1\r\n            },\r\n            {\r\n                transform: {translateY: '0px'}, opacity: 1\r\n            }\r\n        ], {\r\n            duration: 5000,\r\n            easing: \"linear-out-slow-in\",\r\n            fill: \"forwards\",\r\n            iterations: 1\r\n        });\r\n        textImg.play();\r\n        ......\r\n    }\r\n复制代码\r\n这个方法在开发者文档中未找到说明，但证实可用，且IDE也是有提示的。\r\n\r\n\r\ntransform其中的key输入却是没有提示了。\r\n\r\n**这里写完后会有红线说缺少属性，但运行是没问题的，可以忽略。**如果看着难受可以把数组单独声明为一个变量，再作为animate()方法入参。\r\n以上三步，就实现了gif图中\"litemall\"字样从下方上移并逐渐清晰的动画效果。\r\n对比CSS3的动画技术，使用JS实现动画会更有灵活性。可以在onShow()中定义动画，在用户进行一定操作后再执行。CSS3的只能在页面显示后一定时间执行，但可以用百分比的形式定义更丰富的动画渐变效果。\r\n3、JS定时器\r\nsetTimeout()和setInterval()两个定时函数在鸿蒙中可以无缝对接使用。\r\ngif图中的倒计时使用setInterval()实现每1秒倒数一个数并改变省略号的个数，在倒数到0时清除定时器。为防止僵尸线程影响性能，切记调用clearTimeout()和clearInterval()清除掉定时器。\r\n倒计时部分，hml视图层：\r\n    \r\n        \r\n        \r\n            {{ loading }}\r\n        \r\n    \r\n    \r\n        {{ seconds }}\r\n    \r\n复制代码\r\ncss渲染层：\r\n.loading {\r\n    width: 100%;\r\n    height: 150px;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\nprogress {\r\n    width: 120px;\r\n    height: 120px;\r\n}\r\n.loading>text {\r\n    font-size: 40px;\r\n    color: #666666;\r\n}\r\n.count {\r\n    position: fixed;\r\n    bottom: 385px;\r\n    left: 225px;\r\n    font-size: 60px;\r\n    color: #666666;\r\n}\r\n复制代码\r\njs逻辑层：\r\n    onShow() {\r\n    ......\r\n        // 设置倒计时\r\n        let iv = setInterval(() => {\r\n            let suffix;\r\n            switch (this.seconds % 3) {\r\n                case 2:\r\n                suffix = \"...\";\r\n                break;\r\n                case 1:\r\n                suffix = \"..\";\r\n                break;\r\n                default:\r\n                suffix = \".\";\r\n                break;\r\n            }\r\n            this.loading = \"数据加载中\" + suffix;\r\n            this.seconds--;\r\n            if (this.seconds == 0) {\r\n                clearInterval(iv);\r\n            }\r\n        }, 1000);\r\n    }\r\n复制代码\r\n页面会在动画播放完成后跳转到商城首页，使用setTimeout()设置定时跳转即可。这里在播放动画时预加载了首页需要的数据，作为页面参数跳转，可以加快商城页的展示速度，提升用户体验。\r\n    onInit() {\r\n        // 首页数据预加载\r\n        // 获取广告图片\r\n        fetch.fetch({\r\n            ......\r\n        });\r\n        // 获取推荐商品\r\n        fetch.fetch({\r\n            ......\r\n        });\r\n        // 获取一级分类\r\n        fetch.fetch({\r\n            ......\r\n        });\r\n    },\r\n    onShow() {\r\n        // 设置定时跳转\r\n        let to = setTimeout(() => {\r\n            router.replace({\r\n                uri: \"pages/index/index\",\r\n                params: {\r\n                    ad: this.ad,\r\n                    newGoods: this.newGoods,\r\n                    hotGoods: this.hotGoods,\r\n                    types: this.types\r\n                }\r\n            });\r\n            clearTimeout(to);\r\n        }, 6000);\r\n    ......\r\n    }\r\n复制代码\r\n4、微信小程序的动画效果\r\n最后写一写微信小程序的动画实现，在wxss中同样支持CSS3的动画属性：\r\n.happy {\r\n  font-size: 50rpx;\r\n  color: #e20a0b;\r\n  animation-name: an1;\r\n  animation-duration: 5s;\r\n  animation-delay: 500ms;\r\n  animation-iteration-count: infinite;\r\n  animation-direction: normal;\r\n  animation-fill-mode: forwards;\r\n  animation-timing-function: linear;\r\n}\r\n@keyframes an1 {\r\n  from {\r\n    transform: translateX(0px);\r\n    opacity: 0.5;\r\n  }\r\n  to {\r\n    transform: translateX(300px);\r\n    opacity: 1;\r\n  }\r\n}\r\n复制代码\r\n需注意的是animation-name属性IDE的提示是带有双引号的，需要去除，否则不起效果。\r\n\r\n微信小程序的动画JS实现方式和鸿蒙有很大不同，是通过微信提供的API定义并实现动画。接口提供了丰富的方法，可在开发者文档查阅。\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    an2: null\r\n  },\r\n\r\n  onShow: function () {\r\n    let an2 = wx.createAnimation({\r\n      delay: 500,\r\n      duration: 5000,\r\n      timingFunction: 'ease-in-out'\r\n    });\r\n    an2.translate(100, 300).step();\r\n    an2.rotate(90).opacity(0.1).step();\r\n    this.setData({\r\n      an2: an2.export()\r\n    })\r\n  },\r\n}\r\n复制代码\r\n动画基本属性作为createAnimation()方法的入参，动画关键帧由一连串的方法流式操作给出，以step()结束。这里一个动画的执行的时间是duration给定的时间。动画对象需使用export()导出到data中，并和页面元素的animation属性绑定。\r\n\r\n  新年快乐\r\n\r\n复制代码\r\n作者：HarmonyOS技术社区来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "微信小程序订阅消息：我踩过的坑和解决办法都在这里！ ", "author": "Rolan", "pub_time": "2021-2-22 09:46", "content": "不同点与「模板消息」不同的是，其是在用户点击触发或者支付成功之后，开发者可在7天内推送1-3条服务通知。而「订阅消息」则需要用户主动订阅消息通知，开发者才可向用户推送，但不受时间限制，具体发送信息条数根据该能力的不同类型有不同标准。此外，值得注意的是，使用「订阅消息」后，原小程序模板消息接口于2020年1月10日下线，也就无法再使用原接口推送模板消息。但是，微信服务号模板消息暂不受影响。特点选择权回到用户手中。在小程序中，「订阅消息」像是一个开关，需要用户主动点击授权之后，小程序才能向其推送服务通知，当然，用户也可以随时拒收该小程序的服务通知。而此前，用户只能被动地接收消息。时长不受限制。「订阅消息」取消了7天内推送消息的时间限制，只要用户没有主动拒收消息推送，开发者就可以随时推送服务通知。对于服务周期超过7天的小程序而言，这就完美解决了此前的疑虑。好了那我们来看看如何使用这个订阅消息吧~1、简述大概流程小程序端发起的授权弹窗过程顺便说一下如何获取用户授权信息wx.getting，及当用户关闭授权如何跳到设置授权页一条龙服务，附上其他诸多问题授权后服务端下发订阅消息流程整理一下订阅发送各参数的具体意思，虽然文档有，但是有例子的话对着看更好理解小程序端发起的授权弹窗过程调起客户端小程序订阅消息界面，返回用户订阅消息的操作结果。当用户勾选了订阅面板中的“总是保持以上选择，不再询问”时，模板消息会被添加到用户的小程序设置页，通过 wx.getSetting 接口可获取用户对相关模板消息的订阅状态。留意文档中的这句话 → 如果用户之前设置过不在询问的话，其实是调不起授权弹窗的，那我们怎么获取用户的授权信息呢？wx.getSetting可以获取这些信息：对应的wx.getting文档文档后面有示例代码这边就不在贴出来了如果要获取 订阅消息的订阅状态 需要设置 withSubscriptions 为true即可（默认为false，不开不获取），成功获取后 authSetting 是有关于用户的一些权限，而 subscriptionsSetting 则是我们需要的订阅权限信息，里面有一个总开关 mainSwitch 就是你是否接受当前小程序的订阅信息，如果这个为false的话其实你根本调不起弹窗，那小伙伴就会问如果我要让他知道关闭了权限并且怎么引导他去开呢？先贴出代码：发送订阅消息逻辑处理const SUBSCRIBE_ID = 'RHPuVfEyGe0q0n7lZyzz4r-zyGe07lZyzz4r3' // 模板IDgoCollectSet() {    let that = this;    if (wx.requestSubscribeMessage) {      wx.requestSubscribeMessage({        tmplIds: [SUBSCRIBE_ID],        success(res) {          if (res[SUBSCRIBE_ID] === 'accept') {            // 用户主动点击同意...do something          } else if (res[SUBSCRIBE_ID] === 'reject') {            // 用户主动点击拒绝...do something          } else {            wx.showToast({              title: '授权订阅消息有误',              icon: 'none'            })          }        },        fail(res) {          // 20004:用户关闭了主开关，无法进行订阅,引导开启          if (res.errCode == 20004) {            // 显示引导设置弹窗            that.setData({              isShowSetModel: true            })          }else{            // 其他错误信息码，对应文档找出原因            wx.showModal({              title: '提示',              content: res.errMsg,              showCancel: false            })          }        }      });    } else {      wx.showModal({        title: '提示',        content: '请更新您微信版本，来获取订阅消息功能',        showCancel: false      })    }  }【wx.requestSubscribeMessage文档】简述一下上面的代码，goCollectSet 方法则是授权订阅消息权限执行的方法，由于 wx.requestSubscribeMessage 需要基础库 2.4.4 后才支持，因此我们要做个判断，如果发现用户当前微信没有此方法，则提示更新微信版本；然后 tmplIds Array字段里面是填对应的订阅模板ID【问】订阅模板ID哪里获取、哪里新建呢？·【答】微信公众号平台 登录后，如果有多个小程序，选择当前开发的小程序，成功进入界面后，在 功能 板块 -> 订阅消息，里面可以新建模板也可以使用公共订阅模板，有模板的话直接复制对应的ID即可然后如果此时用户开启了订阅消息通知权限的话，则会出现授权订阅消息的窗口啦，如图：如果此时用户点【允许】此时就会返回 accept 状态，反之点【取消】则返回 reject，具体的状态字段如图我们可以发现这个返回值，是用你的模板id作为键，所以获取的时候要根据模板ID获取，这边只说允许和拒绝的返回，对于 filter 的返回就是因为模板标题同名导致过滤的，所以新建的时候记得区分开已有的标题的模板禁止同名，success成功一般就这些，主要是用户自行的操作，【允许】后就会订阅一次，注意这里是说一次性订阅的订阅消息哦，关于区别可以看下面：【问】一次性订阅模板和永久性订阅有什么区别？如果我需要用永久性订阅怎么操作？【答】1、一次性订阅消息：用户订阅一次后，开发者可下发一条消息，不限时间。若用户勾选了“总是保持以上选择，不再询问”且点击了允许，那么以后都默认同意订阅这条消息。用户不再做多次选择，开发者也避免了更繁琐的提醒。2、长期性订阅消息：用户订阅一次后，可长期下发多条消息。目前长期性订阅消息向 政务、医疗、交通、金融、教育 等线下公共服务开放，后续将综合评估行业需求和用户体验持续完善。（长期订阅消息只针对特定行业开放，所以普通开发者并无法使用）好了回到正题，此时用户点击一次就相当于订阅了一次，相当于你拥有了一次获取系统通知的门票，理论上用户多次点击就相当于订阅了多次，此时是会将这些订阅次数储存起来，如果服务器下发通知时就会消耗一次订阅次数（理论上是这样的，文档也没有说，只要确保每次下发前触发一次订阅交互，所以想想还是长期性订阅香呀，一次授权终身使用~）其次说说弹窗下面的【总是保持以上选择，不再询问】如果没有勾选，每次订阅时都是会弹窗的，而如果用户勾选了，此时执行的逻辑是没有变的，你勾选后点【允许】其实就直接执行了 'accept' 里的逻辑反之如果你勾选了然后点了【取消】就是一直执行 reject 里的逻辑，所以有些小伙伴就会说，为什么每次授权时都没有弹窗还自动拒绝，其实【取消】就是拒绝的意思再加上勾选了不再询问就尴尬了…这个误操作成本就很高了，以后不再弹窗还直接拒绝，如果用户某天想订阅了就不知道哪里订阅了，知道哪里设置（设置页）开启还好，如果不知道就尴尬了，有小伙伴就说那我们再拒绝的逻辑上加上引导弹窗的话不就行了？但是从执行逻辑来看，有无勾选不再询问下点拒绝都是走 reject 的逻辑，如果这边就引导用户去设置页是不是有点奇怪，所以这边其实很蛋疼，只能祈求微信小程序开发大哥加个不再询问的拒绝返回标识多好，这样我们开发也可以根据对应标识返回来判断用户是普通的拒绝，还是不再询问的拒绝当然上面的问题并不是没有解决方法，只是需要自定义一个弹窗，这个下面细讲，我们慢慢来…我们先说 fail 失败的逻辑。能走到 fail 失败的逻辑直接查文档的错误代码表，这边就说几个常见的吧【问】返回错误代码 20001、20002、20003、20004什么意思，怎么解决？【答】20001 ：没有模板数据，一般是模板 ID 不存在 或者和模板类型不对应 导致的20001解决 ：一般要注意代码写入的模板id有没有在微信公众号中，如果没有就新建；还有注意 tmplIds: [‘订阅模板id1’, ‘订阅模板id2’] 这种格式不要写错20002 ：模板消息类型 既有一次性的又有永久的20002解决 ：文档已经说明不能混用，所以检查写入tmplIds中的id是否同一种类型20003 ：模板消息数量超过上限20003解决 ：需要订阅的消息模板的id的集合，一次调用最多可订阅3条消息（注意：iOS客户端7.0.6版本、Android客户端7.0.7版本之后的一次性订阅/长期订阅才支持多个模板消息，iOS客户端7.0.5版本、Android客户端7.0.6版本之前的一次订阅只支持一个模板消息）这个骚限制如果遇到的话，首先找产品开干，为什么这边要一下子搞那么多订阅一下让用户选择，能分开就分开；其次对于低版本的微信用户只支持一个模板消息的话，如果此时有必要两个一起订阅的话就直接提醒用户更新版本就行，否则会影响功能使用就行了·20004 ：用户关闭了主开关，无法进行订阅20004解决 ：这个就是用户设置页将订阅通知消息的总开关关闭了，这边就可以引导用户去设置页开启了好了，这边主要说 20004 的错误返回，也就是如何引导用户去设置页；不是网上那些用图案去引导操作，我们这边直接利用 微信中button标签 open-type=\"openSetting\" 直接直达，首先我们看看这个功能的基础库 2.0.7 ，丝毫不慌能用订阅模板消息 2.4.4 那这个功能也是可以用的，那我们看看wxml，对应的样式不贴出来了自定DIY引导跳授权设置wxml    <view class=\"jumpSetModel\" wx:if=\"{{isShowSetModel}}\">    <view class=\"jumpSetBox\">     <view class=\"m-title\">提示view>      <view class=\"m-content\">检测到您未开启订阅消息通知权限，是否去设置？view>      <view class=\"m-control\">        <button class=\"m-cancel\" catchtap=\"closeSetModel\">取消button>        <button class=\"m-confirm\" open-type=\"openSetting\" bindopensetting=\"openSetCallback\">去设置button>      view>    view>  view>如上图所示，如果返回 20004 的话我们就显示该弹窗，点去设置就会跳到设置页，舒服呀~有些小伙伴就会说，如果设置开启后，手势返回会不会监听到，这个你不用担心，自动刷新订阅通知总开关的状态的，不影响再次执行的逻辑好了，认真阅读的小伙伴是不是记得上面留了一个问题：如果用户点了不再询问并且取消的话，我们这样弹就行了（与普通拒绝一起使用）授权后服务端下发订阅消息流程调用消息订阅接口 wx.requestSubscribeMessage，获取下发权限后，接下来就是下发订阅消息啦~。通过文档我们可以知道有两种下发方式，一种是 HTTPS调用，另一种是使用 云函数小程序·云开发 – 云函数云调用是小程序·云开发提供的在云函数中调用微信开放接口的能力，需要在云函数中通过 wx-server-sdk 使用，云调用还可以免去了 access_token 的获取代码如下：const cloud = require('wx-server-sdk')cloud.init()exports.main = async (event, context) => {  try {    const result = await cloud.openapi.subscribeMessage.send({        touser: 'wx12345645645zawqead',  // 接受当前模板消息的用户openid        templateId: 'TEMPLATE_ID',   // 当前下发的模板ID，不可写多个，目前只支持一个        page: 'index?id=666',   // 定义用户点击该模板消息跳转的小程序路径        // 模板所需要的键值        data: {          thing1: {            value: '情感咨询课程'          },          amount1: {            value: '9.99'          },          date1: {            value: '2020-03-10 15:24:08'          }        }      })    return result  } catch (err) {    return err  }}这样就可以下发到对应的模板到制定的用户啦~后端服务器下发订阅消息 $data = json_decode(file_get_contents('php://input'), true); $post_data = array(  // 用户的 openID，可用过 wx.getUserInfo 获取  \"touser\"           => $data[\"touser\"],  // 小程序后台申添加的订阅消息模板 ID  \"template_id\"      => $data[\"template_id\"],  // 点击模板消息后跳转到的页面，可以传递参数  \"page\"             => $data[\"page\"],  // 发送给用户的数据  \"data\"             => $data[\"data\"] ); // 发送 POST 请求的函数function send_post($url, $post_data){  $options = array(    'http' => array(      'method'  => 'POST',      'header'  => 'Content-type:application/json',      'content' => $post_data,      'timeout' => 60    )  );   $context = stream_context_create($options);  $result = file_get_contents($url, false, $context);   return $result;} // 小程序 appID 和 appSecret 获取 tokenfunction getAccessToken($appid, $appsecret){  $url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=' . $appid . '&secret=' . $appsecret;  $html = file_get_contents($url);  $output = json_decode($html, true);  $access_token = $output['access_token'];   return $access_token;} // 这里替换为你的 appID 和 appSecret$url = \"https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=\" . getAccessToken($appid, $appsecret); $data = json_encode($post_data, true); $return = send_post($url, $data);var_dump($return);这里贴出的是php的demo代码下发小程序订阅消息，关于 appID 和 appSecret 的获取可以在对应的 小程序公众号 里的开发设置中获取【问】小程序云函数如何创建？【答】关于使用小程序云开发创建云步骤可以参考该文章：微信小程序云开发之云函数的创建与环境配置【问】下发时报错了怎么回事，怎么解决？【答】40003 touser字段openid为空或者不正确40003解决 ：注意这里的openid是接受该订阅消息用户的43101 用户拒绝接受消息，如果用户之前曾经订阅过，则表示用户取消了订阅关系43101解决 ：这个报错就要注意在 小程序端发起的授权弹窗过程 中获取用户订阅授权是否成功，如果没有成功请在获取授权操作中查找问题47003 模板参数不准确，可能为空或者不满足规则，errmsg会提示具体是哪个字段出错47003解决：订阅了一次性消息，但是发送时也有可能会失败，这个可能就跟内容有关了，模板 data 参数务必参考对应的模板id开放出来的模板字段进行填写( 订阅消息的模板内容参数非常严格，多一个字符或者与参数规定值不符都导致发送失败，记得对字数进行判断。 填写时对应参数时根据后台的模板填写，比如说 thing03、name05，后面都是带数字的 )41030 page路径不正确，需要保证在线上版本小程序中存在，与app.json保持一致41030解决：必须要填对，路径要小程序有的关于服务器下发订阅消息的流程大概说到这里~2、搜集解疑各种疑难杂症订阅消息算是个大功能了，免不了开发时出现各种各样的问题，上面讲述流程中已经贴出了一些问题及对应的解决方法，这里就不在重复上面写的，这里就补充一下没有提及到的1、开发者工具无法调试后来试了一下在真机上可以吊起授权弹窗，逛了下开发社区才发现这是一个普遍的问题不过现在的提示已经很直白了，这锅我们不背，记得要在真机上调试！2、如果我发起两个订阅模板消息，但用户只收到其中一个，怎么回事？首先 要确保 tmplIds 字段中写入两个相同类型的模板id ['模板id1','模板id2'] ，代码上没写错就会正常吊起授权窗口（前提是用户没有勾选 总是保持以上选择的选项），如果用户要接收两个的话必选勾选两个模板的，如果用户取消了其中一个的话当然是接受不到对应的模板消息的，所以可以在 wx.requestSubscribeMessage 中 success 逻辑中对应处理返回值，如果请求授权多个模板id的话对应的返回也是根据模板id作为键来返回的，所以对应处理即可好了上面是用户没有勾选 「总是保持以上选项，不在询问」的情况，如果勾选了那就不会提示出弹窗，只能在「设置」界面重新打开，因为此时是不会弹窗的，关于引导在上面已经提及过了，这里就不在多诉还有用户还可以再发送订阅通知的微信服务号中，进行取消订阅通知，这个也是直接会把设置里对应的通知接收关闭，同理引导也是跟上面一样success(res) {   // 模板id1的处理逻辑   if (res['模板id1'] === 'accept') {     // 用户主动点击同意...do something   } else if (res['模板id1'] === 'reject') {     // 用户主动点击拒绝...do something   }     // 模板id2的处理逻辑   if (res['模板id2'] === 'accept') {     // 用户主动点击同意...do something   } else if (res['模板id2'] === 'reject') {     // 用户主动点击拒绝...do something     wx.showModal({       title: '提示',       content: '你取消了xxx的通知',       showCancel: false     })  } }3、为什么我使用 wx.requestSubscribeMessage 调试时执行成功了也没吊起授权框？首先要确保能调用成功（基础库支持，代码无错误），这时一般就是之前勾选过「总是保持以上选项，不在询问」这个选项，其次就是你的模板id是属于长期性订阅类型，这种类型，只要你一确认后就不会再给你弹授权窗了，只能根据状态让用户去设置中自行打开4、我同时填写多个模板id字段，报了错：Templates count out of max bounds（注意：iOS客户端7.0.6版本、Android客户端7.0.7版本之后的一次性订阅/长期订阅才支持多个模板消息，iOS客户端7.0.5版本、Android客户端7.0.6版本之前的一次订阅只支持一个模板消息）消息模板id在[微信公众平台-功能-订阅消息]中配置。每个tmplId对应的模板标题需要不相同，否则会被过滤，所以也有小伙伴说为什么我填了三个模板id最后只显示两个，那就要去公众号平台看看是不是出现了标题相同的问题~5、对于一次性订阅授权弹窗，为什么我点允许后，在该小程序设置里面没有看到该订阅消息呢？对应一次性订阅消息来说，如果不勾选\"总是保持以上选择，不再提示\"的话，是不会加入小程序设置页里的，反之勾选了，小程序才会存储该用户在该小程序里的默认授权操作；同理对于长期性订阅消息来说，用户允许或拒绝后都会直接存入设置中（可在设置中看到该长期性订阅的订阅状态）并且我们可以通过 wx.getSetting 接口可获取用户相关模板消息的订阅状态。具体可以看官方文档： wx.getSetting6. 如何获取用户openid？首先对应openid的获取，有三种方法：1、前台小程序通过 wx.login() 获取到的 code 用户登录凭证（有效期五分钟）。然后需要在开发者服务器后台调用auth.code2Session，使用code 换取 openid 和 session_key 等信息；【该操作是不需要用户授权的】2、如果你是用云开发的话，可以调用云函数来获取这些信息，具体代码如下：用这个云函数就可以啦 cloud.getWXContext() （对于云部署之类的就不细讲，有疑问的可以参考上面提到的云函数部署文章）在getopenid云函数的index.js中写好后记得上传部署该云函数// 云函数入口文件const cloud = require('wx-server-sdk')cloud.init()// 云函数入口函数exports.main = async (event, context) => {  const wxContext = cloud.getWXContext()  return {    event,    openid: wxContext.OPENID,    appid: wxContext.APPID,    unionid: wxContext.UNIONID,  }}然后在需要的获取的界面调用该云即可page{  data{    openid:'',  },  onLuanch(){    this.getopenid()  }  // 定义调用云函数获取openid  getOpenid(){    let page = this;    wx.cloud.callFunction({      name:'getOpenid',      complete:res=>{        var openid = res.result.openid        page.setData({          openid:openid        })      }    })  },}【该操作也是不需要用户授权的】3、通过 wx.getUserInfo 接口获取用户信息调用这个方法是需要用户授权的（就是平时我们看到的抽屉式授权信息弹窗），而且如果要获取像openid及其他敏感信息的话还要该参数 withCredentials 为 true 时，并且要求此前有调用过 wx.login 且登录态尚未过期，此时返回的数据会包含 encryptedData, iv 等敏感信息，然而接口返回的 openid 并非明文传输，还需要进行通过 加密数据解密算法 才能拿到明文值；所以如果你只是单单获取 openid 的话，就不需要如此大费周章，用第一二中方法即可；此外该操作还需要用户授权同意才行，如果用户拒绝直接走 fail 逻辑；用户openid会变吗还是唯一值？这个问题要分情况诉说：同一个用户访问同一个小程序，他的openid是不会变的，第一次进来的是什么，之后进来该小程序都是同一个openid（唯一性）同一个用户访问不同小程序，他的openid在各个小程序中都是不一样的不同用户访问同一个小程序，各自用户的openid是不一样的总结：每个小程序都有一个身份值且唯一，他就是appid（就像人民币一样不可能有同一个码，出现就是假钱），而openid是跟appid关联管理的，所以openid其实也是唯一值暂且列出这些问题，如果有其他问题可以一起讨论解决~"}
{"title": "总结：小程序CANVAS遇到的坑 ", "author": "Rolan", "pub_time": "2021-2-2 17:58", "content": "项目需要从后台返回的二维码和背景图片返回到前端，前端把各个字段值画在canvas上生成海报，要在画布上添加二维码，可保存在本地。 第一个坑 这里从后台传过来的图片为网络图片需要先转化为本地的，看开发者工具文档用wx.getImageInfo 的方法可以转换，canvas 的draw方法默认为 false 也就是不保存之前所画的内容，因为我的文字和二维码都需要写在背景图上，所以改为 true 。注意绘制的顺序，先把背景图底图画上，然后是文字或者其他的，wx.getImageInfo({\r\n    //that.data.preImg是我后台返回过来的动态数据二维码\r\n    src: 'http://www域名.com'+that.data.preImg,\r\n    success: function (res) {\r\n        context.drawImage(res.path, 270, 560, 80,80);\r\n        that.creatText(context);//绘制文字的方法\r\n        context.draw(true);//保存之前绘制的\r\n    }\r\n})\r\n然后相应的在第二个坑 canvas 画布的绘制是不分先后的我的背景图片会把文字覆盖掉，在这里我把需要绘制的文字写在另外一个方法中，然后在 wx.getImageInfo 方法成功后调用这个方法，要把 context 传进去：var context = wx.createCanvasContext('mycanvas');\r\n第三个坑 就是后台的背景图片是从数据可拿过来的为image 类型，在后台转化为base64传到前端，我需要把base64转化为可以显示的图片，从网上找了好多方法都是直接显示在页面上，\"data:image/png;base64,{{img}}\"/>\r\n而这个不是我要的结果，又找到了这个方法： //将后台传过来的海报背景base64格式转化为图片\r\nbase64src:function(code,cb){\r\n    const fsm = wx.getFileSystemManager();\r\n    const timestamp = Date.parse(new Date())\r\n    // 自定义文件名\r\n    const FILE_BASE_NAME = 'tmp_base64src' + timestamp\r\n    // 文件系统中的用户目录路径 （本地路径）\r\n    const filePath = `${wx.env.USER_DATA_PATH}/${FILE_BASE_NAME}.png`;\r\n    // 将 base64 字符串转成 ArrayBuffer 对象\r\n    const buffer = wx.base64ToArrayBuffer(code)\r\n    //同步\r\n    fsm.writeFileSync(\r\n        filePath,\r\n        buffer,\r\n        'base64'\r\n    )\r\n    cb(filePath)\r\n    this.setData({\r\n        bgIMg:filePath\r\n    })\r\n    //异步\r\n \t// fsm.writeFile({\r\n    //   filePath: filePath,\r\n    //   data: buffer,\r\n    //   encoding: 'base64',\r\n    //   success: (res)=>{\r\n    //     cb(filePath)\r\n    //     this.setData({\r\n    //       bgIMg:filePath\r\n    //     })\r\n    //   }\r\n    // })\r\n}\r\n\r\n注意： 前端绘制的一个弊端就是图片生成时间太长，要base64转图片，还要绘制图画；后端绘制可能效果排版没有前端那么好。生成图片保存到本地并显示到页面上(因为绘制图画时间较长，保存时需要setTimeout延长一下)setTimeout(function () {\r\n    wx.canvasToTempFilePath({\r\n        canvasId: 'mycanvas',\r\n        success: function (res) {\r\n            var tempFilePath = res.tempFilePath;//图片地址\r\n            that.setData({\r\n                imagePath: tempFilePath,\r\n                canvasHidden:true\r\n            });\r\n        },\r\n        fail: function (res) {\r\n            console.log(res);\r\n        }\r\n    });\r\n},1000);\r\n小程序长按图片并不能保存，需要额外的写一个方法保存到本地相册-wxsaveimagetophotosalbum\" style=\"font-size: 11px; margin: 10px 0px; color: rgb(255, 255, 255); font-family: \" pingfang=\"\" sc\",=\"\" \"microsoft=\"\" yahei\",=\"\" \"helvetica=\"\" neue\",=\"\" helvetica,=\"\" arial,=\"\" sans-serif;=\"\" background-color:=\"\" rgba(3,=\"\" 3,=\"\" 0.8);\"=\"\">第四个坑 小程序长按图片并不能保存，需要额外的写一个方法保存到本地相册 wx.saveImageToPhotosAlbumvar that = this\r\nwx.saveImageToPhotosAlbum({\r\n    filePath: that.data.imagePath,\r\n    success(res) {\r\n        wx.showModal({\r\n            content: '图片已保存到相册，赶紧晒一下吧~',\r\n            showCancel: false,\r\n            confirmText: '好的',\r\n            confirmColor: '#333',\r\n            success: function (res) {\r\n                if (res.confirm) {\r\n                // console.log('用户点击确定');\r\n                /* 该隐藏的隐藏 */\r\n                    that.setData({\r\n                        maskHidden: false\r\n                    })\r\n                }\r\n            },fail:function(res){\r\n           \t\tconsole.log(res)\r\n            }\r\n        })\r\n    }\t\r\n})\r\n好了，绘制小程序海报到此为止了，有很多问题是可以在开发文档中找到方法解决的，微信开放社区 里边的大神还是挺多的可以问他们，期待微信小程序的完善。"}
{"title": "【实战】在微信小程序中获取用户所在城市信息 ", "author": "Rolan", "pub_time": "2021-2-3 09:49", "content": "背景在《看啥好呢》中有个本地好看 Tab，进去后会获取用户当前所在城市，然后显示该城市的数据，并且显示在导航栏和 Tab 上。微信小程序中，我们可以通过调用 wx.getLocation() 获取到设备当前的地理位置信息，这个信息是当前位置的经纬度。如果我们想获取当前位置是处于哪个国家，哪个城市等信息，该如何实现呢？微信小程序中并没有提供这样的 API，但是没关系，有 wx.getLocation() 得到的经纬度作为基础就够了，其他的，我们可以使用其他第三方地图服务可以来实现，比如腾讯地图或百度地图的 API。所以整个步骤就是：在小程序中获取当前的地理位置，涉及小程序 API 为wx.getLocation把第 1 步中获得的经纬度信息通过腾讯地图的接口逆地址解析，涉及腾讯地图接口为 reverseGeocoder(options:Object)在小程序中获取当前的地理位置在小程序中，调用 wx.getLocation，使用前需要用户授权 scope.userLocation，代码如下javascriptcheckAuth(callback) {\r\n  wx.getSetting({\r\n    success(res) {\r\n      if (!res.authSetting['scope.userLocation']) {\r\n        wx.authorize({\r\n          scope: 'scope.userLocation',\r\n          success() {\r\n            wx.getLocation({\r\n              type: 'wgs84',\r\n              success(res) {\r\n                callback(res.latitude, res.longitude)\r\n              }\r\n            })\r\n          }\r\n        })\r\n      }\r\n    }\r\n  })\r\n}\r\n其中 type 的取值可以为：wgs84 意思返回 gps 坐标gcj02 返回可用于 wx.openLocation 的坐标。运行后会提示如下信息，还需要在 app.json 中配置 permission 字段查询文档后得知，得知需要如下配置javascript\"permission\": {\r\n    \"scope.userLocation\": {\r\n      \"desc\": \"你的位置信息将用于小程序位置接口的效果展示\"\r\n    }\r\n}\r\ndesc 用于在弹出的授权提示框中展示，如下允许后即可获取接口返回的信息，此过程会在右上角胶囊按钮上显示箭头图标js{\r\n  accuracy: 65;\r\n  errMsg: \"getLocation:ok\";\r\n  horizontalAccuracy: 65;\r\n  latitude: 30.25961; // 纬度，范围为 -90~90，负数表示南纬\r\n  longitude: 120.13026; // 经度，范围为 -180~180，负数表示西经\r\n  speed: -1;\r\n  verticalAccuracy: 65;\r\n}\r\nlatitude 和 longitude 即是我们需要的两个字段腾讯地图接口逆地址解析以腾讯地图为例，我们可以去腾讯地图开放平台注册一个账号，然后在它的管理后台创建一个密钥(key)，以及进行 KEY 设置，按照微信小程序 JavaScript SDK入门及使用限制文档在 KEY 设置的启用产品中，勾选 WebServiceAPI，选择签名校验方式，因为我是使用云开发的方式，所以没有什么域名也没有授权 IP。这部分代码逻辑如下jsimport QQMapWX from '../../scripts/qqmap-wx-jssdk.min.js'\r\nlet qqmapsdk\r\nPage({\r\n    onLoad: function (options) {\r\n\r\n      // 实例化API核心类\r\n      qqmapsdk = new QQMapWX({\r\n         key: '开发密钥（key）'    // 必填\r\n      });\r\n      this.checkAuth((latitude, longitude) => {\r\n         // https://lbs.qq.com/qqmap_wx_jssdk/method-reverseGeocoder.html\r\n         qqmapsdk.reverseGeocoder({\r\n           sig: 'KEY设置中生成的SK字符串',    // 必填\r\n            location: {latitude, longitude},\r\n            success(res) {\r\n                wx.setStorageSync('loca_city', res.result.ad_info.city)\r\n\r\n            },\r\n            fail(err) {\r\n               console.log(err)\r\n               wx.showToast('获取城市失败')\r\n            },\r\n            complete() {\r\n               // 做点什么\r\n\r\n            }\r\n         })\r\n      })\r\n    }\r\n}）\r\nreverseGeocoder 接口返回的结果，这里面的字段比较多，详细可以看接口文档，里面好几个字段可以取到城市，其中 ad_info 是行政区划信息，我就取这里面的 city 了。【 全 文 完 】"}
{"title": "特约商户号中绑定小程序Appid，完成支付步骤操作 ", "author": "Rolan", "pub_time": "2021-2-3 11:18", "content": "1、申请注册商务号，需要的证件弄齐就可以了这里步骤比较简单，注册的时候注意超级管理员的信息用的是哪个手机号绑定的微信。后面用来登录操作的，我就跳过这一步。2、在商务平台“https://pay.weixin.qq.com/index.php/core/home/login”使用微信扫描二维码登录。这个微信必须是超级管理员才可以登录。3、标题点击提交后等待小程序后台确认授权小程序后台确定关联完成状态4、到这里基本上绑定完成了。可以使用统一下单接口进行支付。5、如果使用小程序云支付接口。还需要以下配置操作首先得开通小程序云开发。选用基础版是免费的就可以了。看下图授权状态需要在商务号的管理员微信中确认授权。以上步骤就是商务号跟小程序APPID绑定关联的过程。这个绑定关联不上，无法完成支付。剩下的就是代码部分了。APPID关联弄好后使用小程序云进行支付开发代码就简单很多了。云函数代码：// 云函数入口文件const cloud = require('wx-server-sdk') cloud.init() // 云函数入口函数exports.main = async (event, context) => {  const res = await cloud.cloudPay.unifiedOrder({        \"body\" : \"XXXX订单\",    \"outTradeNo\" : event.orderid,//订单号每次都不能一样    \"spbillCreateIp\" : \"127.0.0.1\",    \"sub_appid\":\"wx2ab7e27a3730f78e\",//小程序appid    \"subMchId\" : event.subMchId,    //\"totalFee\" : event.totalfee, //商品支付金额 单位（分） 100代表一块钱    \"totalFee\" : 1, //商品支付金额 单位（分） 100代表一块钱    \"envId\": \"wlXXXXX******944b9\",//云开发环境，在云开发设置中可以查看    \"functionName\": \"pay_cb\"  })  return res}遇到问题的小伙伴们可以私信我。\r\n温馨提示：注意大小写，如：appId（I大写），随机字符串nonce_str变成了nonceStr"}
{"title": "编程日历小程序，对小程序云开发和生成分享海报的实践 ", "author": "Rolan", "pub_time": "2021-2-3 09:28", "content": "1、起源\r\n朋友圈晒的很多的一本日历书《了不起的程序员 2021》，我也买了，很厚，纸质书嘛，现在已经很少看了，加上这是一本日历书，希望是每天都打开看。可实际上的情况是，要么忘记看今天的内容，要么一口气看了好几天的内容，然后剩下几天又不看了。\r\n\r\n后来《了不起的程序员 2021》在 Github 开源了。\r\n于是乎！我就想做一个小程序，因为手机每天打开的频率太高了，碎片时间也很多，加上小程序的不用安装用完即走的优点，使用方便，不会有压力感。\r\n再加上自己还没有一款正儿八经的小程序作品，对现在很火的云开发也没怎么用过，特别是小程序云开发，他他到底用起来爽不爽呢？（很爽！）\r\n于是乎！开干！\r\n2、产品设计\r\n这是最伤脑筋的部分，小程序到底要做成什么样，画个原型图？作为一个『资深』程序员，从来没正经画过原型和设计。手足无措，改用什么工具？虽然我知道有 Sketch 这个神器，还很多在线设计工具，比如磨刀，但从来没用过啊，最后硬着头皮用磨刀画了画原型，很简陋的原型，就是线框图级别。\r\n\r\n这个过程不断有新的想法，所以改来该去，产品设计花了好几天，学习怎么画原型，实现脑子里乱七八糟的各种想法。\r\n在这个过程中我不断的给自己家需求，一度增加了什么历史上的今天、知乎日历等等各种内容，最后还是被自己狠心一一毙掉了，只留下纯粹的编程日历内容。\r\n\r\n鉴于对产品和设计不擅长，在此诚邀 UI、产品小伙伴，一起租一个团队，有机会一起做一些产品，让我们的想法能落地，生根发芽。\r\n\r\n3、开发\r\n产品设计阶段和开发阶段占用的时间比大概是 8:2 左右，有了原型开发很快，毕竟也没什么复杂的东西。\r\n下面重点说一下分享海报功能的实现吧。\r\n3.1、选择海报分享方案\r\n在开发分享海报功能之前我也看了下网上大致的方案，最后我选择了微信小程序自己的扩展组件：wxml-to-canvas，小程序内通过静态模板和样式绘制 canvas ，导出图片，可用于生成分享图等场景。\r\n我为什么不用其他方案：\r\n\r\n手写 canvas，太麻烦\r\n后端生成前端获取，太麻烦，我这个小程序很简单没必要\r\n开源小程序海报组件，尝试过一个，感觉也不太好用，有些没文档用起来吃力\r\n\r\n上图，是骡子是马拉出来遛遛，下图的的海报就是通过 wxml-to-canvas 动态绘制的。\r\n\r\n3.2、引入 wxml-to-canvas 组件\r\nwxml-to-canvas 的限制很多，第一次没经验的话觉得很难用，如果再让我做一次，我就快很多了。\r\n官方的示例只单纯教你怎么生成海报，缺乏上下文和怎么整合进你的项目及逻辑，需要费一下脑子。\r\nStep1. npm 安装，参考 小程序 npm 支持\r\nnpm install --save wxml-to-canvas\r\n复制代码\r\nStep2. JSON 组件声明\r\n{\r\n  \"usingComponents\": {\r\n    \"wxml-to-canvas\": \"wxml-to-canvas\"\r\n  }\r\n}\r\n复制代码\r\nStep3. wxml 引入组件\r\n<view class=\"share-image-container\">\r\n  <wxml-to-canvas\r\n    id=\"canvas\"\r\n    width=\"{{canvasWidth}}\"\r\n    height=\"{{canvasHeight}}\"\r\n  ></wxml-to-canvas>\r\n</view>\r\n复制代码\r\n3.3、海报分享逻辑说明\r\n点击编程日历小程序底部的海报分享按钮，在当前页面生成 canvas 预览图，然后再生成图片跳转到海报图片预览和保存页面。\r\n上面的 .share-image-container 类如下：\r\n.share-image-container {\r\n  border: 1px solid red;\r\n  position: absolute;\r\n  transform: translateY(-1000%);\r\n  bottom: 0;\r\n  z-index: 0;\r\n}\r\n复制代码\r\n即在页面外生成 canvas，也是在这里调试 wxml-to-canvas 组件效果的地方，去掉该类的样子如下：\r\n3.4、js 获取实例\r\nStep4. js 获取实例\r\nimport RenderCodeToWXML from \"./renderCodeWXML.js\";\r\n\r\nPage({\r\n  data: {\r\n    canvasWidth: 373,\r\n    canvasHeight: 720,\r\n    bannerImgHeight: 240,\r\n    bannerImgWdith: 320,\r\n  },\r\n  renderToCanvas() {\r\n    wx.showLoading({\r\n      title: \"处理中...\",\r\n    });\r\n    this.canvas = this.selectComponent(\"#canvas\");\r\n    const {\r\n      canvasWidth,\r\n      canvasHeight,\r\n      bannerImgWdith,\r\n      bannerImgHeight,\r\n    } = this.data;\r\n    let renderToWXML = new RenderCodeToWXML(\r\n      canvasWidth,\r\n      canvasHeight,\r\n      bannerImgWdith,\r\n      bannerImgHeight\r\n    );\r\n\r\n    const wxml = renderToWXML.renderWXML();\r\n    const style = renderToWXML.renderStyle();\r\n    const p1 = this.canvas.renderToCanvas({ wxml, style });\r\n    p1.then((res) => {\r\n      // console.log('container', res.layoutBox)\r\n      app.globalData.container = res;\r\n      this.container = res;\r\n      this.extraImage();\r\n    }).catch((err) => {\r\n      wx.hideLoading();\r\n      console.log(\"err\", err);\r\n    });\r\n  },\r\n  extraImage() {\r\n    const p2 = this.canvas.canvasToTempFilePath();\r\n    p2.then((res) => {\r\n      wx.hideLoading();\r\n      // app.globalData.share = res\r\n      wx.navigateTo({\r\n        url: \"../shareImage/shareImage\",\r\n        success: function(res2) {\r\n          // 通过eventChannel向被打开页面传送数据\r\n          res2.eventChannel.emit(\r\n            \"acceptDataFromOpenerPage\",\r\n            {\r\n              share: res,\r\n              container: app.globalData.container,\r\n              tab: app.globalData.tab,\r\n              date: app.globalData.dateInfo.strings,\r\n            }\r\n          );\r\n        },\r\n      });\r\n    }).catch((err) => {\r\n      wx.hideLoading();\r\n      wx.showToast({\r\n        title: err,\r\n        icon: \"none\",\r\n      });\r\n    });\r\n  },\r\n});\r\n复制代码\r\n这里主要就是从 renderCodeWXML.js 中获取 WXML 和 Style，然后调用 canvas 的 renderToCanvas 方法进行渲染：\r\nconst wxml = renderToWXML.renderWXML();\r\nconst style = renderToWXML.renderStyle();\r\nconst p1 = this.canvas.renderToCanvas({ wxml, style });\r\n复制代码\r\n最后在 p1.then 里调用 this.extraImage(); 方法跳转到下一个页面，并通过 eventChannel.emit 方式传递参数。\r\n来看看 renderCodeWXML.js 里面有什么：\r\nconst app = getApp();\r\n\r\nexport default class RenderDataToWXML {\r\n  constructor(\r\n    canvasWidth,\r\n    canvasHeight,\r\n    imgWidth,\r\n    imgHeight\r\n  ) {\r\n    this.canvasWidth = canvasWidth;\r\n    this.canvasHeight = canvasHeight;\r\n    this.imgWidth = imgWidth;\r\n    this.imgHeight = imgHeight;\r\n  }\r\n\r\n  renderWXML() {\r\n    const { dateInfo, data, userInfo } = app.globalData;\r\n    const openId = wx.getStorageSync(\"openId\");\r\n    let pData = \"\";\r\n    let pMore = \"\";\r\n    let banner = \"\";\r\n\r\n    if (data.data.event) {\r\n      pData = data.data.event.join(\"\");\r\n    }\r\n    if (data.data.coding) {\r\n      pData = data.data.coding.join(\"\");\r\n    }\r\n    if (data.data.landmark) {\r\n      pData = data.data.landmark.join(\"\");\r\n    }\r\n\r\n    if (data.data.more) {\r\n      pMore = data.data.more[0];\r\n    } else if (data.data.people) {\r\n      pMore = data.data.people[0].split(\"：\").join(\"，\");\r\n    } else {\r\n      pMore = \"\";\r\n    }\r\n\r\n    if (data.data.img) {\r\n      banner = `\r\n      <view class=\"banner\">\r\n        <image class=\"banner-image\" mode=\"aspectFit\" src=\"${data.data.img.url}\" />\r\n      </view>`;\r\n    }\r\n\r\n    if (pData.length >= 156) {\r\n      pData = pData.substring(0, 152) + \"...\";\r\n    }\r\n    if (pMore.length >= 50) {\r\n      pMore = pMore.substring(0, 48) + \"...\";\r\n    }\r\n\r\n    let avatar = \"\";\r\n    if (userInfo && userInfo.avatarUrl) {\r\n      avatar = `<view class=\"avatar\">\r\n        <image class=\"avatar-image\" src=\"${userInfo.avatarUrl}\" />\r\n        <text class=\"avatar-nikename\">${userInfo.nickName}邀请你使用</text>\r\n      </view>`;\r\n    }\r\n\r\n    let wxmlMore = pMore;\r\n    if (wxmlMore) {\r\n      wxmlMore = `\r\n        <view>\r\n          <text class=\"p-more\">${pMore}</text>\r\n        </view>\r\n      `;\r\n    }\r\n\r\n    const wxml = `\r\n      <view class=\"container\">\r\n        <view class=\"top\">\r\n          <view class=\"top-left\">\r\n            <view><text class=\"en\">${dateInfo.date.monthEN}</text></view>\r\n            <view><text class=\"cn\">${dateInfo.lunarDate}</text></view>\r\n          </view>\r\n          <view><text class=\"top-center\">${dateInfo.date.day}</text></view>\r\n          <view class=\"top-right\">\r\n            <view><text class=\"en\">${dateInfo.date.weekEN}</text></view>\r\n            <view><text class=\"cn\">${dateInfo.date.weekCN}</text></view>\r\n          </view>\r\n        </view>\r\n        ${banner}\r\n        <view class=\"middle\">\r\n          <view>\r\n            <text class=\"p-data\">${pData}</text>\r\n          </view>\r\n          ${wxmlMore}\r\n        </view>\r\n        <view class=\"qrcode\">\r\n          <view class=\"appinfo\">\r\n            ${avatar}\r\n            <view><text class=\"appname\">编程日历</text></view>\r\n            <view><text class=\"appdesc\">程序员专属日历，最极客日历</text></view>\r\n          </view>\r\n          <view class=\"qrcode-image\">\r\n            <image class=\"image\" mode=\"aspectFit\" src=\"https://7072-programming-calendar-3b8b7a7d082-1304448256.tcb.qcloud.la/qr/${openId}-qr.png?sign=b5a610dc6ae15c9427720ab617a2f18a&t=1609438339\" />\r\n          </view>\r\n        </view>\r\n      </view>\r\n      `;\r\n    return wxml;\r\n  }\r\n\r\n  // canvas样式\r\n  renderStyle() {\r\n    const contentWidth = this.canvasWidth - 50;\r\n    const mainColor = \"#1296db\";\r\n    const style = {\r\n      container: {\r\n        width: this.canvasWidth,\r\n        height: this.canvasHeight,\r\n        backgroundColor: \"#fff\",\r\n      },\r\n      top: {\r\n        width: this.canvasWidth,\r\n        height: 82,\r\n        backgroundColor: mainColor,\r\n        flexDirection: \"row\",\r\n        justifyContent: \"space-around\",\r\n        alignItems: \"center\",\r\n      },\r\n      topLeft: {\r\n        width: this.canvasWidth / 3,\r\n        height: 82,\r\n        textAlign: \"center\",\r\n        alignItems: \"center\",\r\n      },\r\n      topCenter: {\r\n        width: this.canvasWidth / 3,\r\n        height: 82,\r\n        lineHeight: 82,\r\n        fontSize: 72,\r\n        textAlign: \"center\",\r\n        color: \"#ffffff\",\r\n      },\r\n      topRight: {\r\n        width: this.canvasWidth / 3,\r\n        height: 82,\r\n      },\r\n      en: {\r\n        width: this.canvasWidth / 3,\r\n        height: 30,\r\n        fontSize: 20,\r\n        textAlign: \"center\",\r\n        color: \"#ffffff\",\r\n        marginTop: 15,\r\n      },\r\n      cn: {\r\n        width: this.canvasWidth / 3,\r\n        height: 30,\r\n        textAlign: \"center\",\r\n        color: \"#ffffff\",\r\n      },\r\n      banner: {\r\n        width: this.canvasWidth,\r\n        flexDirection: \"row\",\r\n        justifyContent: \"center\",\r\n        marginTop: 20,\r\n      },\r\n      bannerImage: {\r\n        width: this.imgWidth,\r\n        height: this.imgHeight,\r\n      },\r\n      middle: {\r\n        flexDirection: \"column\",\r\n        justifyContent: \"center\",\r\n        alignItems: \"center\",\r\n        marginTop: 20,\r\n      },\r\n      pData: {\r\n        width: contentWidth,\r\n        height: 170,\r\n        lineHeight: \"1.8em\",\r\n      },\r\n      pMore: {\r\n        width: contentWidth,\r\n        height: 60,\r\n        lineHeight: \"1.8em\",\r\n      },\r\n      qrcode: {\r\n        height: 130,\r\n        flexDirection: \"row\",\r\n        justifyContent: \"space-between\",\r\n        backgroundColor: \"#CCE6FF\",\r\n        paddingLeft: 20,\r\n        paddingTop: 20,\r\n      },\r\n      qrcodeImage: {\r\n        width: 90,\r\n        height: 90,\r\n        marginRight: 20,\r\n        borderRadius: 45,\r\n        flexDirection: \"row\",\r\n        justifyContent: \"center\",\r\n        alignItems: \"center\",\r\n        backgroundColor: \"#fff\",\r\n      },\r\n      image: {\r\n        width: 90,\r\n        height: 90,\r\n        scale: 0.9,\r\n        borderRadius: 45,\r\n      },\r\n      appinfo: {\r\n        flexDirection: \"column\",\r\n        justifyContent: \"flex-start\",\r\n        alignItems: \"flex-start\",\r\n        height: 80,\r\n      },\r\n      avatar: {\r\n        flexDirection: \"row\",\r\n        justifyContent: \"flex-start\",\r\n        width: this.canvasWidth / 1.8,\r\n        height: 30,\r\n      },\r\n      avatarImage: {\r\n        width: 30,\r\n        height: 30,\r\n        borderRadius: 15,\r\n        marginRight: 5,\r\n      },\r\n      avatarNikename: {\r\n        width: this.canvasWidth / 1.8,\r\n        height: 22,\r\n        lineHeight: 22,\r\n        marginTop: 5,\r\n      },\r\n      appname: {\r\n        width: this.canvasWidth / 2,\r\n        height: 23,\r\n        fontSize: 16,\r\n        color: \"#0081FF\",\r\n        marginTop: 8,\r\n        marginLeft: 35,\r\n      },\r\n      appdesc: {\r\n        width: this.canvasWidth / 2,\r\n        height: 20,\r\n        fontSize: 14,\r\n        marginLeft: 35,\r\n      },\r\n    };\r\n    return style;\r\n  }\r\n\r\n  // 省略不相关代码\r\n}\r\n复制代码\r\n该文件就是我们画海报的地方，就是生成 WXML 和 Style 然后导出\r\n。\r\n3.5、wxml-to-canvas 组件的注意事项\r\nwxml-to-canvas 组件对 wxml 模板支持有限 :\r\n\r\n支持 <view>、<text>、<image> 三种标签，通过 class 匹配 style 对象中的样式。\r\n文字必须用 <text> 标签包含，否则不显示。并且必须设置宽高。文字宽度必须先确定，超出则会自动截断。所以动态文字可以根据字数，动态设置宽度。\r\n\r\n样式方面：\r\n\r\n对象属性值为对应 wxml 标签的 cass 驼峰形式。需为每个元素指定 width 和 height 属性，否则会导致布局错误。\r\n存在多个 className 时，位置靠后的优先级更高，子元素会继承父级元素的可继承属性。\r\n元素均为 flex 布局。left/top 等 仅在 absolute 定位下生效。\r\n\r\n因为文字必须用 <text> 标签包含，并且必须设置宽高，文字宽度必须先确定，超出则会自动截断。所以动态文字可以根据字数，动态设置宽度。所以写布局非常麻烦，我推荐大家为每一个元素设置背景，这样可以看到元素渲染的范围和宽高。如下所示：\r\n\r\nborderColor/marginBottom/marginTop 可使用，虽然微信文档中没写。\r\n3.6、海报预览和下载页面\r\n生成 canvas 并调用接口生成图片后，我们携带参数跳转到下一个页面，先来看看 WXML，非常简单：\r\n<view>\r\n  <view class=\"share-container\">\r\n    <image\r\n      src=\"{{src}}\"\r\n      mode=\"widthFix\"\r\n      class=\"image\"\r\n      style=\"height: {{height}}px;\"\r\n    ></image>\r\n  </view>\r\n  <view class=\"save-button\">\r\n    <van-button\r\n      bind:tap=\"saveImage\"\r\n      block\r\n      round\r\n      icon=\"down\"\r\n      size=\"large\"\r\n      type=\"info\"\r\n      >保存到手机</van-button\r\n    >\r\n  </view>\r\n</view>\r\n复制代码\r\njs 逻辑\r\nconst app = getApp();\r\nPage({\r\n  data: {\r\n    src: \"\",\r\n    date: \"\",\r\n    width: \"\",\r\n    height: \"\",\r\n  },\r\n  onLoad() {\r\n    const eventChannel = this.getOpenerEventChannel();\r\n    eventChannel.on(\"acceptDataFromOpenerPage\", (data) => {\r\n      // console.log(\"data\", data)\r\n      this.setData({\r\n        showPopup: true,\r\n        date: data.date,\r\n        src: data.share.tempFilePath,\r\n        width: data.container.layoutBox.width,\r\n        height: data.container.layoutBox.height,\r\n      });\r\n    });\r\n  },\r\n  getDatestr() {\r\n    const { strings } = app.globalData.dateInfo;\r\n    return strings;\r\n  },\r\n  saveImage() {\r\n    wx.showLoading({\r\n      title: \"处理中...\",\r\n    });\r\n    const _this = this;\r\n    wx.getSetting({\r\n      success(res) {\r\n        if (!res.authSetting[\"scope.writePhotosAlbum\"]) {\r\n          wx.authorize({\r\n            scope: \"scope.writePhotosAlbum\",\r\n            success() {\r\n              _this.save();\r\n            },\r\n            fail() {\r\n              wx.showToast({\r\n                title: \"授权失败\",\r\n                icon: \"none\",\r\n              });\r\n            },\r\n          });\r\n        } else {\r\n          _this.save();\r\n        }\r\n      },\r\n    });\r\n  },\r\n  save() {\r\n    wx.saveImageToPhotosAlbum({\r\n      filePath: this.data.src,\r\n      success() {\r\n        wx.showToast({\r\n          title: \"保存成功\",\r\n          icon: \"none\",\r\n        });\r\n      },\r\n      fail() {\r\n        wx.showToast({\r\n          title: \"保存失败\",\r\n          icon: \"none\",\r\n        });\r\n      },\r\n    });\r\n  },\r\n});\r\n复制代码\r\n以上就是我开发海报功能的逻辑和代码，仅供参考吧，如果你有相关经验欢迎讨论交流，留下你的真知灼见吧。\r\n4、编程日历小程序页面截图\r\n最后，分几张小程序的页面截图\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n预览预览\r\n5、后续迭代计划\r\n增加用户等级计划、对应等级可以换一些礼物，其余的。。。你有什么想法？欢迎交流！作者：杭州程序员张张来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "微信小程序之使用函数防抖与函数节流 ", "author": "Rolan", "pub_time": "2021-2-3 11:22", "content": "函数防抖和函数节流都是老生常谈的问题了。这两种方式都能优化 js 的性能。有些人可能会搞混两个的概念。所以，我以自己的理解，来解释这两个概念的含义。并且列举在小程序中这两个方法的使用。函数防抖： 英文 debounce 有防反跳的意思，大致就是指防止重复触发。那么，函数防抖，真正的含义是：延迟函数执行。即不管debounce函数触发了多久，只在最后一次触发debounce函数时，才定义setTimeout，到达间隔时间再执行 需要防抖的函数。用处：多用于 input 框 输入时，显示匹配的输入内容的情况。 函数节流： 英文 throttle 有节流阀的意思。大致意思也是 节约触发的频率那么，函数节流，真正的含义是：单位时间n秒内，第一次触发函数并执行，以后 n秒内不管触发多少次，都不执行。直到下一个单位时间n秒，第一次触发函数并执行，这个n秒内不管函数多少次都不执行。用处：多用于页面scroll滚动，或者窗口resize，或者防止按钮重复点击等情况 其实如果只根据 控制函数触发的频率是不好区分这两个概念的。我认为两个函数都能达到防止重复触发的功能。但是函数防抖是 n秒后延迟执行；而函数节流是立马执行，n秒后再立马执行。 在小程序中，函数防抖、函数节流的使用方式：一般都会把这两种方法封装在公用的 js 中：tool.js/*函数节流*/\r\nfunction throttle(fn, interval) {\r\n  var enterTime = 0;//触发的时间\r\n  var gapTime = interval || 300 ;//间隔时间，如果interval不传，则默认300ms\r\n  return function() {\r\n    var context = this;\r\n    var backTime = new Date();//第一次函数return即触发的时间\r\n    if (backTime - enterTime > gapTime) {\r\n      fn.call(context,arguments);\r\n      enterTime = backTime;//赋值给第一次触发的时间，这样就保存了第二次触发的时间\r\n    }\r\n  };\r\n}\r\n\r\n/*函数防抖*/\r\nfunction debounce(fn, interval) {\r\n  var timer;\r\n  var gapTime = interval || 1000;//间隔时间，如果interval不传，则默认1000ms\r\n  return function() {\r\n    clearTimeout(timer);\r\n    var context = this;\r\n    var args = arguments;//保存此处的arguments，因为setTimeout是全局的，arguments不是防抖函数需要的。\r\n    timer = setTimeout(function() {\r\n      fn.call(context,args);\r\n    }, gapTime);\r\n  };\r\n}\r\n\r\nexport default {\r\n  throttle,\r\n  debounce\r\n}; 使用：import tool from \"../../static/js/tool.js\";\r\nPage({\r\n   data:{\r\n    win_scrollTop:0\r\n   },\r\n   onPageScroll: tool.throttle(function(msg){\r\n      this.setData({\r\n        win_scrollTop: msg[0].scrollTop\r\n      });\r\n   }),\r\n   gotoUnlock: tool.debounce(function() {\r\n      this.saveUserInfo();\r\n   }),\r\n   saveUserInfo:function(){\r\n      console.log(111)\r\n   }\r\n}) 上面的两种方式只是精简版的，可能还有某些情况没考虑到，以后遇到了再优化。 函数节流的说明：（1） 第一次执行时，是一定能执行函数的。（2） 然后 n秒内第二次触发的时候，当第一次与第二次间隔不足 设置的间隔时间时，就不会执行。之后第三、第四次触发还是不执行。（3） 直到 n秒之后 有且仅有一次，并且是第一次再次触发函数。 函数防抖的说明：（1） 第一次触发函数时，定义了一个定时器。在 n秒后执行。（2） 然后 函数第二次触发的时候，由于闭包的特性，这时候的 timer已经是第一次触发时的 定时器的标识了。然后直接清除第一次的setTimeout，这时候第一次的setTimeout里面的内容就不会执行了。然后再定义第二次的setTimeout。（3） 然后重复第二个步骤，一直清除，又一直设置。直到函数最后一次触发，定义了最后的一个定时器，并且间隔 n秒 执行。（4） 如果在 最后一个定时器没执行时，函数又触发了，那么又重复第三步。相当于 设置的间隔时间，只是延迟函数执行的时间，而不是间隔多少秒再执行。 到这里，这两个方式的区别就很明显了。函数节流是减少函数的触发频率，而函数防抖则是延迟函数执行，并且不管触发多少次都只执行最后一次。"}
{"title": "小程序navigateTo和redirectTo跳转的区别与应用 ", "author": "Rolan", "pub_time": "2021-2-3 22:28", "content": "最近在做小程序的跳转，发现navigateTo的跳转无法满足业务需求，所以特地记录下业务需求类似一个淘宝的在订单界面选择地址的功能，从A页面点击跳转到B页面的地址列表页面，B页面可以选择已有的地址跳转到A也可以选择添加地址跳转到新的新增地址的表单提交页C。在新增完地址点确定按钮返回到地址列表页B，从B中选择企业返回到最初的A页面。选择地址页面由于很多地方要用到所以考虑把B页面作为一个通用模块页面，其他很多页面在选择地址都进入这个B，最终选择企业再到原页面A，所以B返回A用的是navaigateBack返回上一层。问题产生与解决　　一开始用的都是NavigateTo的跳转方式，后来发现在C页面跳转到B页面时，B页面在选择地址时会返回上一层也就是C，这和事先的需求不一样（选择地址返回到最初的A页面）。这个问题很快就能想到是因为B页面的navaigateBack返回上一层也就是C作为跳转的页面。那么如何既保留navaigateBack的返回上一层又能不跳回C页面呢？　　这里就涉及到一个页面堆栈的概念。NavigateTo的方式是将原始页面（跳转前的当前页面）和新页面入栈，在navaigateBack返回是从页面堆栈中查询到路径进行返回。而redirectTo是将原始页面（跳转前的当前页面）进行出栈，也就是说当前页面不放进页面堆栈中，新页面依旧入栈。　　那我现在的情景就适合用redirectTo来对C进行跳转，也就是说上图中的2和3的步骤都是用redirectTo来进行跳转，到最后返回到B页面的时候C是不在页面堆栈中的，此时堆栈中的只有A和B，就能通过navaigateBack顺利的返回到A页面了。总结redirectTo：当前页面不入栈，新页面入栈navigateTo：当前页面和新页面入栈小程序的页面栈最大能存放十个页面，当页面栈中的页面等于10时，在使用navigateTo这种方式是不能再跳页的，页面很多的情况下建议使用navigateTo。再放张图："}
{"title": "微信小程序弹窗组件 ", "author": "Rolan", "pub_time": "2021-2-3 14:07", "content": "一、前言 相信大家在开发小程序时会遇到某个功能多次使用的情况，比如弹出框。这个时候大家首先想到的是组件化开发，就是把弹出框封装成一个组件，然后哪里使用哪里就调用，对，看来大家都是有思路的人，但是要怎样实现呢。可能你会去看官方文档，但是微信的官方文档也是说的不太清楚，所以写起来也是非常痛苦。今天就带大家手摸手开发微信组件，坐稳了，马路杀手要开车了。\r\n二、具体实现 我们先实现个简单的弹窗组件，详情图如下：实现过程如下：1.新建component文件夹存放我们的组件，里边存放的就是我们所用的组件，我们今天要做的事弹出框，新建文件夹popup存放我们的组件模板，点击右键选择新建component，就会自动生成组件的模板wxss、wxml、json、js，如图2.我们可以写一些组件样式和布局，更页面写法类似，我就不多说了，直接把代码贴出 :popup.wxml12345678910<view class=\"wx-popup\" hidden=\"{{flag}}\">  <view class='popup-container'>    <view class=\"wx-popup-title\">{{title}}view>    <view class=\"wx-popup-con\">{{content}}view>    <view class=\"wx-popup-btn\">      <text class=\"btn-no\" bindtap='_error'>{{btn_no}}text>      <text class=\"btn-ok\" bindtap='_success'>{{btn_ok}}text>    view>  view>view>popup.wxss123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* component/popup.wxss */.wx-popup {  position: absolute;  left: 0;  top: 0;  width: 100%;  height: 100%;  background: rgba(0, 0, 0, .5);}.popup-container {  position: absolute;  left: 50%;  top: 50%;   width: 80%;  max-width: 600rpx;  border: 2rpx solid #ccc;  border-radius: 10rpx;  box-sizing: bordre-box;  transform: translate(-50%, -50%);   overflow: hidden;  background: #fff;}.wx-popup-title {  width: 100%;  padding: 20rpx;  text-align: center;  font-size: 40rpx;  border-bottom: 2rpx solid red;}.wx-popup-con {  margin: 60rpx 10rpx;  text-align: center;}.wx-popup-btn {  display: flex;  justify-content: space-around;  margin-bottom: 40rpx;}.wx-popup-btn text {  display: flex;  align-items: center;  justify-content: center;  width: 30%;  height: 88rpx;  border: 2rpx solid #ccc;  border-radius: 88rpx;}popup.js:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Component({  options: {    multipleSlots: true // 在组件定义时的选项中启用多slot支持  },  /**   * 组件的属性列表   */  properties: {    title: {            // 属性名      type: String,     // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）      value: '标题'     // 属性初始值（可选），如果未指定则会根据类型选择一个    },    // 弹窗内容    content: {      type: String,      value: '内容'    },    // 弹窗取消按钮文字    btn_no: {      type: String,      value: '取消'    },    // 弹窗确认按钮文字    btn_ok: {      type: String,      value: '确定'    }   },   /**   * 组件的初始数据   */  data: {    flag: true,  },   /**   * 组件的方法列表   */  methods: {    //隐藏弹框    hidePopup: function () {      this.setData({        flag: !this.data.flag      })    },    //展示弹框    showPopup () {      this.setData({        flag: !this.data.flag      })    },    /*    * 内部私有方法建议以下划线开头    * triggerEvent 用于触发事件    */    _error () {      //触发取消回调      this.triggerEvent(\"error\")    },    _success () {      //触发成功回调      this.triggerEvent(\"success\");    }  }})Component这个可以自己看微信官方文档锻炼一下自学能力^_^3.模板文件也建好了，在首页用这个组件需要配置一下，首先建一个名为index.json的文件，里边配置\"usingComponents\"，就是需要引入到首页，直接上代码：12345{  \"usingComponents\": {    \"popup\": \"/component/popup/popup\"  }}4.完成这些基本上大功告成了，还有最重要的一步也是最后一步，引入到首页，看代码1234567891011121314<view class=\"container\">  <view class=\"userinfo\">    <button bindtap=\"showPopup\"> 点我 button>  view>  <popup id='popup'       title='小组件'       content='学会了吗'       btn_no='没有'       btn_ok='学会了'      bind:error=\"_error\"        bind:success=\"_success\">  popup>view>5.配置index.js操作点击事件，这个更简单，上代码12345678910111213141516171819202122232425//index.js//获取应用实例const app = getApp() Page({  onReady: function () {    //获得popup组件    this.popup = this.selectComponent(\"#popup\");  },   showPopup() {    this.popup.showPopup();  },   //取消事件  _error() {    console.log('你点击了取消');    this.popup.hidePopup();  },  //确认事件  _success() {    console.log('你点击了确定');    this.popup.hidePopup();  }})到此就结束，一个简单的小插件封装好了 三、测试运行效果图："}
{"title": "微信小程序支付功能完整流程 ", "author": "Rolan", "pub_time": "2021-2-4 10:32", "content": "支付流程整个支付流程分为四个步骤：获取令牌token创建订单预支付，获取支付参数对象pay发起微信支付收尾工作。跳转到订单页面，删除购物车中已购买的商品请求方式：POST整个支付过程中用到的网络请求较多，并且有很多的共性，建议封装到request.js中整个支付过程都要用try-catch包裹(我没有用)[温馨提示]：支付流程中的url已失效获取令牌token获取令牌token// 点击支付\r\nasync handleOrderPay() {\r\n  // 从缓存中获取token\r\n  const token = wx.getStorageSync('token')\r\n  // 如果token不存在，跳转到授权页面获取token\r\n  if (!token) {\r\n    wx.navigateTo({\r\n      url: '/pages/auth/auth',\r\n    })\r\n }\r\n<!-- 点击按钮获取用户信息 -->\r\n<button type=\"primary\" plain open-type=\"getUserInfo\" bindgetuserinfo=\"handleGetUserInfo\">授权</button>\r\n缓存中不存在token，授权！// 授权操作\r\n// pages/auth/auth.js\r\nimport {request} from '../../request/index.js' //网络请求\r\nimport regeneratorRuntime from '../../lib/runtime/runtime' //使用es7语法\r\nimport {login} from '../../utils/asyncWx.js' //内部封装了wx.login()，通过该方法获取一个必须参数code\r\n\r\nPage({\r\n  // 获取用户信息\r\n  async handleGetUserInfo(e) {\r\n    try {\r\n      // 获取小程序登录成功后的五个必须参数\r\n      const {\r\n        encryptedData,\r\n        rawData,\r\n        iv,\r\n        signature\r\n      } = e.detail\r\n      const {\r\n        code\r\n      } = await login()\r\n      // 将这五个参数存入loginParams自定义对象中\r\n      const loginParams = {\r\n        encryptedData,\r\n        rawData,\r\n        iv,\r\n        signature,\r\n        code\r\n      }\r\n      // 获取token\r\n      const {\r\n        token\r\n      } = await request({\r\n        url: '/users/wxlogin',\r\n        // 传入这五个必须参数\r\n        data: loginParams,\r\n        method: 'POST'\r\n      })\r\n      // 将token存入缓存中，同时跳转到上一个页面\r\n      wx.setStorageSync('token', token)\r\n      wx.navigateBack({\r\n        // delta表示返回的层级，1表示返回上一层，2表示返回上两层\r\n        delta: 1,\r\n      })\r\n    } catch (error) {\r\n      console.log(error)\r\n    }\r\n  }\r\n})\r\n创建订单获取到5个必须参数// 创建订单\r\n    // 请求头参数，这个参数会贯穿整个支付过程中的网络请求\r\n    const header = {\r\n      // 授权参数即为token\r\n      Authorization: token\r\n    }\r\n    // 请求体参数\r\n    const order_price = this.data.totalPrice //总价格\r\n    const consignee_addr = this.data.address.all //详细收获地址\r\n    const cart = this.data.cart \r\n    let goods = [] //订单数组，从购物车中提取出几个所需要的属性组成的数组\r\n    goods = cart.forEach(v => {\r\n      goods_id: v.goods_id\r\n      goods_number: v.num\r\n      goods_price: v.goods_price\r\n    })\r\n\t// 将所需要的订单参数存入orderParams\r\n    const orderParams = {\r\n      order_price,\r\n      consignee_addr,\r\n      goods\r\n    }\r\n获取订单编号    // 获取订单编号\r\n    const {order_number} = await request({\r\n      url: '/my/orders/create',\r\n      method: 'POST',\r\n      // 将之前获得的订单参数传入\r\n      data: orderParams,\r\n      header\r\n    })\r\n    console.log(order_number)\r\n  }\r\n预支付根据订单编号获取到支付参数对象pay    const {pay} = await request({\r\n      url: '/my/orders/req_unifiedorder',\r\n      method: \"POST\",\r\n      header,\r\n      // 传入订单编号\r\n      data: {\r\n        order_number\r\n      }\r\n    })\r\n    console.log('pay')\r\n发起微信支付将支付参数pay传入到requestPayment中即可\tawait requestPayment(pay)\r\n收尾工作跳转到订单页面，同时删除购物车中以购买的商品await showToast('支付成功')\r\n      // 删除缓存中已经被选中的商品\r\n      let newCart = wx.getStorageSync('cart')\r\n      newCart = newCart.filter(v => !v.checked)\r\n      wx.setStorageSync('cart', newCart)\r\n      // 此时跳转到订单页面\r\n      wx.navigateTo({\r\n        url: '/pages/order/order',\r\n      })"}
{"title": "微信小程序中的常见弹框 ", "author": "Rolan", "pub_time": "2021-2-4 10:34", "content": "显示加载中的提示框wx.showLoading()当我们正在在进行网络请求时，常常就需要这个提示框手动调用wx.hideLoading()方法才能够关闭这个提示框，通常在数据请求完毕时就应该关闭如果一个页面中同时有多个请求，必须要等请求都完毕时才能关闭这个提示框通常我们可以设置一个变量axiosTimes=0，在每次请求数据时将这个变量加一，请求完毕时再减一，通过判断这个变量是否为0再来决定是否关闭这个提示框// 同步发送异步代码的次数\r\nlet axiosTimes = 0\r\nexport const request = (params) => {\r\n  axiosTimes++\r\n  // 显示加载中效果\r\n  wx.showLoading({\r\n    title: '加载中',//标题名\r\n    mask: true //遮蔽层\r\n  })\r\n  const baseUrl = 'https://api-hmugo-web.itheima.net/api/public/v1'\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      ...params,\r\n      url: baseUrl + params.url,\r\n      success: (result) => {\r\n        resolve(result.data.message)\r\n      },\r\n      fail: (err) => {\r\n        reject(err)\r\n      },\r\n      complete: () => {\r\n        axiosTimes--\r\n        if (axiosTimes === 0) {\r\n          wx.hideLoading()\r\n        }\r\n      }\r\n    })\r\n  })\r\n}\r\nshowLoading常用属性：属性类型默认值必填说明titlestring是提示的内容maskbooleanfalse否是否显示透明蒙层，防止触摸穿透successfunction否接口调用成功的回调函数failfunction否接口调用失败的回调函数completefunction否接口调用结束的回调函数（调用成功、失败都会执行）显示消息提示框wx.showToast()为了让用户在操作后得到及时的反馈，通常需要这个提示框showToast常见属性：属性类型默认值必填说明titlestring是提示的内容iconstring'success'否图标imagestring否自定义图标的本地路径，image 的优先级高于 icondurationnumber1500否提示的延迟时间maskbooleanfalse否是否显示透明蒙层，防止触摸穿透successfunction否接口调用成功的回调函数failfunction否接口调用失败的回调函数completefunction否接口调用结束的回调函数（调用成功、失败都会执行）showToast默认最大只能显示7个汉字长度，但是当属性icon设置为'none'时，最大可以显示两行文字wx.showToast({\r\n  title: '成功',\r\n  icon: 'success',\r\n  duration: 2000\r\n})\r\n显示模态对话框wx.showModal()在用户在完成某个操作时，为防止是误触，就可以弹出这个对话框让用于做一个二次确认。或者在用户做二选一时，也可以弹出这个对话框showModal常见属性：属性类型默认值必填说明titlestring否提示的标题contentstring否提示的内容showCancelbooleantrue否是否显示取消按钮cancelTextstring'取消'否取消按钮的文字，最多 4 个字符cancelColorstring#000000否取消按钮的文字颜色，必须是 16 进制格式的颜色字符串confirmTextstring'确定'否确认按钮的文字，最多 4 个字符confirmColorstring#576B95否确认按钮的文字颜色，必须是 16 进制格式的颜色字符串successfunction否接口调用成功的回调函数failfunction否接口调用失败的回调函数completefunction否接口调用结束的回调函数（调用成功、失败都会执行）当用户点击了确定后，这个回调结果的confirm属性就为true，点击了取消，这个回调结果的cancel就为true。因此就可以根据用户点击选项的不同来进行对应的操作wx.showModal({\r\n  title: '提示',\r\n  content: '这是一个模态弹窗',\r\n  success (res) {\r\n    if (res.confirm) {\r\n      console.log('用户点击确定')\r\n    } else if (res.cancel) {\r\n      console.log('用户点击取消')\r\n    }\r\n  }\r\n})"}
{"title": "小程序滚动及相关滚动事件 ", "author": "Rolan", "pub_time": "2021-2-4 10:36", "content": "scroll-viewscroll-view是可滚动的区域，在这个区域中如果内部的内容超出了这个区域，就可以通过滚动查看超出区域的内容，因此使用scroll-view时通常要为它设置一个具体高度<scroll-view scroll-y class=\"left_menu\" style=\"height: 300rpx;\">\r\n    <view class=\"menu_item\" bindtap=\"handleItemTab\" >{{item}}</view>\r\n</scroll-view>\r\nscroll-view的相关属性scroll-y 允许纵向滚动scroll-x 允许横向滚动相关滚动事件回到页面顶部wx.pageScrollTo()：自定义滚动到某位置wx.pageScrollTo({\r\n  scrollTop: 0,\r\n  duration: 300 //滚动到顶部所需要的事件\r\n})\r\n上拉加载更多上拉加载更多有两种实现方式1.监听scroll-view上的bindscrolltoupper事件<scroll-view scroll-y=\"true\" style=\"height: 300rpx;\" bindscrolltoupper=\"upper\"></scroll-view> \r\nupper(e) {\r\n    console.log('请求更多数据')\r\n},\r\n2.使用小程序的声明周期函数onReachBottom()onReachBottom(){\r\n    console.log('请求更多数据')\r\n}\r\n下拉刷新页面调用onPullDownRefresh()方法可刷新页面，默认刷新时间为2s，因此当成功请求到数据时，我们通过手动的调用wx.stopPullDownRefresh()关闭刷新可以带来更佳的用户体验onPullDownRefresh() {\r\n  // 重置商品数组\r\n  this.setData({\r\n    goodsList: [],\r\n  })\r\n  // 重置页码\r\n  this.QueryParams.pagenum = 1\r\n  // 重新请求商品\r\n  this.getGoodsList()\r\n}\r\ngetGoodsList() {\r\n    ...\r\n    console.log('成功请求到数据')\r\n    // 手动关闭刷新过程    \r\n    wx.stopPullDownRefresh()\r\n}\r\n下拉刷新不是简单调用一下onPullDownRefresh()方法就可以了的，还需要在全局配置.json文件中设置 \"enablePullDownRefresh\": true,用于开启页面下拉加载效果 \"window\": {\r\n    \"enablePullDownRefresh\": true //全局\r\n    \"backgroundTextStyle\": \"dark\" //顶部显示颜色为白色的三个点\r\n  }"}
{"title": "微信小程序隐藏时动画效果 ", "author": "Rolan", "pub_time": "2021-2-4 10:46", "content": "train.wxmltrain.jsvar interval = \"\";//周期执行函数的对象\r\nvar time = 0;//滑动时间\r\nvar touchDot = 0;//触摸时的原点\r\nvar flag_hd = true;//判定是否可以滑动\r\n\r\nlet animationShowHeight = 300;//动画偏移高度\r\n\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n\r\n    // 遮罩层变量\r\n    animationData: \"\",\r\n    showModalStatus: false,\r\n    imageHeight: 0,\r\n    imageWidth: 0,\r\n\r\n    // 评分变量\r\n    stars: [0, 1, 2, 3, 4],//评分数值数组\r\n    normalSrc: '../images/score.png',//空心星星图片路径\r\n    selectedSrc: '../images/fullstar.png',//选中星星图片路径\r\n    key: 0,//评分\r\n  },\r\n\r\n  //点击星星\r\n  selectRight: function (e) {\r\n    var key = e.currentTarget.dataset.key\r\n    console.log(\"得\" + key + \"分\")\r\n    this.setData({\r\n      key: key\r\n    })\r\n  },\r\n\r\n  // 确定评分\r\n  mark_click: function () {\r\n    this.hideModal()\r\n  },\r\n\r\n // 显示遮罩层  \r\n  showModal: function () {\r\n    //创建一个动画实例animation。调用实例的方法来描述动画。\r\n    var animation = wx.createAnimation({\r\n      duration: 500,         //动画持续时间500ms\r\n      timingFunction: \"ease\",//动画以低速开始，然后加快，在结束前变慢\r\n      delay: 0               //动画延迟时间0ms\r\n    })\r\n    this.animation = animation\r\n    //调用动画操作方法后要调用 step() 来表示一组动画完成\r\n    animation.translateY(animationShowHeight).step()//     在Y轴向上偏移300\r\n    this.setData({\r\n      //通过动画实例的export方法导出动画数据传递给组件的animation属性。\r\n      animationData: animation.export(),\r\n      showModalStatus: true  //显示遮罩层\r\n    })\r\n    setTimeout(function () {\r\n      animation.translateY(0).step()\r\n      this.setData({\r\n        animationData: animation.export()\r\n      })\r\n    }.bind(this), 1)\r\n  },\r\n\r\n  // 隐藏遮罩层  \r\n  hideModal: function () {\r\n    var animation = wx.createAnimation({\r\n      duration: 500,\r\n      timingFunction: \"ease\",\r\n      delay: 0\r\n    })\r\n    this.animation = animation;\r\n    animation.translateY(animationShowHeight).step()\r\n    this.setData({\r\n      animationData: animation.export(),\r\n    })\r\n    setTimeout(function () {\r\n      animation.translateY(0).step()\r\n      this.setData({\r\n        animationData: animation.export(),\r\n        showModalStatus: false\r\n      })\r\n    }.bind(this), 200)\r\n  },\r\n\r\n  // 评分按钮\r\n  score_click: function () {\r\n   \r\n  },\r\n\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n    \r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面初次渲染完成\r\n   */\r\n  onReady: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面显示\r\n   */\r\n  onShow: function () {\r\n    flag_hd = true;    //重新进入页面之后，可以再次执行滑动切换页面代码\r\n    clearInterval(interval); // 清除setInterval\r\n    time = 0;\r\n    let that = this;\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        animationShowHeight = res.windowHeight;\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面隐藏\r\n   */\r\n  onHide: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面卸载\r\n   */\r\n  onUnload: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 页面相关事件处理函数--监听用户下拉动作\r\n   */\r\n  onPullDownRefresh: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 页面上拉触底事件的处理函数\r\n   */\r\n  onReachBottom: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 用户点击右上角分享\r\n   */\r\n  onShareAppMessage: function () {\r\n\r\n  },\r\n\r\n})train.wxsspage {\r\n  background-color: #fff;\r\n}\r\n\r\n/* -----------------评分遮罩层----------------- */\r\n\r\n/* 分享按钮 */\r\n\r\n.share_btn::after {\r\n  border: none;\r\n}\r\n\r\n/* 整个评分遮罩层 */\r\n\r\n.buydes-dialog-container {\r\n  width: 100%;\r\n  height: 300rpx;\r\n  justify-content: space-between;\r\n  background-color: #fff;\r\n  position: fixed;\r\n  bottom: 101rpx;\r\n  /* z-index: 998;   */\r\n  border-top: 1rpx solid #e8e8e8;\r\n}\r\n\r\n/* 评分遮罩层顶部 */\r\n\r\n.buydes-dialog-container-top {\r\n  height: 100rpx;\r\n  padding-top: 20rpx;\r\n  display: flex;\r\n  justify-content: center;\r\n  flex-grow: 1;\r\n  font-size: 32rpx;\r\n  color: #737373;\r\n}\r\n\r\n/* 评分遮罩层底部 */\r\n\r\n.buydes-dialog-container-bottom {\r\n  height: 150rpx;\r\n  padding-top: 20rpx;\r\n  background-color: #fff;\r\n  display: flex;\r\n  justify-content: center;\r\n  flex-grow: 0;\r\n}\r\n\r\n/* 空心的星星图片 */\r\n\r\n.star-image {\r\n  position: absolute;\r\n  top: 100rpx;\r\n  width: 60rpx;\r\n  height: 60rpx;\r\n  src: \"../../images/score.png\";\r\n}\r\n\r\n/* 触发评分点击的区域 */\r\n\r\n.item {\r\n  position: absolute;\r\n  top: 0rpx;\r\n  width: 60rpx;\r\n  height: 60rpx;\r\n}\r\n\r\n/* 确认评分按钮 */\r\n\r\n.mark_btn {\r\n  width: 100%;\r\n  height: 100rpx;\r\n  background-color: #fff;\r\n  color: #55c5ac;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  border-top: 1rpx solid #eaeaea;\r\n  margin-top: 60rpx;\r\n  margin-bottom: 150rpx;\r\n  font-size: 32rpx;\r\n}\r\n\r\n/* 透明遮罩层（上） */\r\n\r\n.touming_top {\r\n  width: 100%;\r\n  height: 900rpx;\r\n  opacity: 0;\r\n  position: fixed;\r\n  bottom: 402rpx;\r\n  z-index: 998;\r\n}\r\n\r\n/* 透明遮罩层（下） */\r\n\r\n.touming {\r\n  width: 100%;\r\n  height: 101rpx;\r\n  opacity: 0;\r\n  position: fixed;\r\n  bottom: 0rpx;\r\n  z-index: 998;\r\n}"}
{"title": "小程序参数传递的几种方式 ", "author": "Rolan", "pub_time": "2021-2-4 10:31", "content": "在微信小程序的开发中，我们会经常遇到页面间数据传递或者相互影响的问题。在实际的开发过程中，可以通过以下几种方法来实现。方法一：使用全局变量全局变量实际上是定义了一个全局的对象，并在每个页面中引入。在初始化代码的时候，小程序会读取一个 app.js的文件，在这里我们可以定义我们所需要的全局变量。然后在页面中，可以通过 getApp()方法获取到全局应用对象，可以对全局变量进行读取并更改：由于 app.js在项目中是用来做基础配置的，因此不建议将很多变量放在这里配置。一般情况下会将一些持久化的常量配置在这里，对于经常需要变动的量不建议用这个方法。方法二：使用本地缓存本地缓存是微信小程序提供的一个功能， 可以将用户产生的数据做本地的持久化，类似于 NoSQL，可以进行读取和修改的操作。那么在不同的页面之间，如何利用它，进行数据的交互呢？假设我们在 A 页面保存了用户的信息。这样做，这个数据就存在了本地。当在 B 页面需要使用的时候，可以直接的获取到数据池中的数据，并进行 CRUD 操作：需要注意的是，在 回到 A 页面的时候，小程序需要重新读取数据。这时候，可以选择放在生命周期的 onShow中对数据重新加载方法三：父级往子级页面（模板）的数据传递我们通常会在页面之间进行跳转、重定向的操作。 这时候，我们可以选择将部分数据放在 url里面，并在新页面 的时候进行初始化。在 D 页面中，我们可以这样接收到到所传进来的参数：wx.navigateTo和 wx.redirectTo不允许跳转到 tab 所包含的页面，只能用 wx.switchTab跳转。需要注意的是， wx.switchTab中的 url不能传参数。微信新提供的 wx.reLaunch接口可以传入参数。另外，在页面中我们通常会用到一些组件模板，因此在父子之间也会有相应的数据传递。使用 name属性，作为模板的名字。然后在这里面使用 is属性，声明需要的使用的模板。然后将模板所需要的 data传入，如：传入模板的除了变量，还可以是事件方法对象。例如，模板中的点击事件，可以传递到使用模板的元素中。通过获取到页面对象进行数据操作这个方法的精髓，是通过获取到其他页面的对象原型， 然后通过原型方法 setData对当前对象管理的 data进行修改，示例如下：当跳转到下一个页面 F 之后，假定在 F 中有操作需要对 E 中的数据有修改，则可以使用以下方法：这个方法可以操作页面堆栈里面的页面的数据， 可以做到让后一级页面对上级页面群的数据管理。小结在微信小程序中有以上并且不局限于以上几种的方式进行页面间数据传递、交互， 在实际应用中可以组合使用。比如说：一些常量，可以交由 app.js 管理；需要持久化的量可以放在本地保存。涉及到下级页面或者模板元素的数据，可以通过传入参数的方式传入。后级页面可以通过获取堆栈里的页面对象快速修改上级的数据。在实际应用中结合使用，可以更好地管理小程序的数据。"}
{"title": "使用promise解决微信小程序中的request回调地狱 ", "author": "Rolan", "pub_time": "2021-2-4 11:18", "content": "wx.request原始用法 wx.request({\r\n     url: 'url', // 这里填写的接口地址\r\n\t data: { }, //这里填写需要传输的数据\r\n     method: 'POST',  // 这里也可以是'GET'\r\n\t  header: {\r\n\t    'content-type': 'application/json', // 默认值\r\n\t    'session': 'sessionid'  //这里一般可能用不到，通过session来确认用户身份，比较安全的用法\r\n\t  },\r\n  success:function(res) {\r\n    console.log(res.data)\r\n  }\r\n})\r\n123456789101112原生request的缺点首先wx.request是异步请求, JS不会等待 wx.request 执行完毕再往下执行，所以JS可能会按顺序会先执行别的方法。如果我们想要先获取一个数据，然后通过这个返回的数据再向服务器获取另外的数据我们一般的解决方法就是：在回调函数来再次发送请求，情况如下：   wx.request({\r\n     url: 'url', // 这里填写的接口地址\r\n\t data: { }, //这里填写需要传输的数据\r\n     method: 'POST',  // 这里也可以是'GET'\r\n\t header: {\r\n\t    'content-type': 'application/json', // 默认值\r\n\t    'session': ‘sessionid’  //这里一般可能用不到，通过session来确认用户身份，比较安全的用法\r\n\t  },\r\n     success:function(res) {\r\n\t\t console.log(res.data)\r\n\t\t //这里再次发送请求\r\n\t     wx.request({\r\n\t\t \turl: 'url', // 这里填写的接口地址\r\n\t\t\tdata: { }, //这里填写需要传输的数据\r\n\t\t    method: 'POST',  // 这里也可以是'GET'\r\n\t\t\theader: {\r\n\t\t\t    'content-type': 'application/json', // 默认值\r\n\t\t\t    'session': ‘sessionid’  //这里一般可能用不到，通过session来确认用户身份，比较安全的用法\r\n\t\t\t  },\r\n\t\t    success:function(res) {\r\n\t\t   \t console.log(res.data)\r\n\t\t  }\r\n\t\t})\r\n  }\r\n})   \r\n12345678910111213141516171819202122232425两个异步函数嵌套起来，似乎感觉还不是很乱，但如果4个5个呢？这就是所谓的回调地狱，这样的代码让人看了就头疼，而且难以维护。promise解决回调地狱promise是什么？promise翻译过来是承诺，它承诺会有一些数据会给我们；promise是一个对象，它代表了一个异步操作，从它可以获取异步操作的消息。promise有三种状态：pending(等待)，fulfiled(成功)，rejected(失败)，只有异步操作的结果可以决定它是什么状态；状态一旦改变，就不会再变，任何时候都可以得到这个结果。下面是通过promise封装的wx.request的案例 //封装request方法\r\nconst request = (url, method, data) => {\r\nvar promise = new Promise((resolve, reject) => {\r\n\t//提示一下\r\n\twx.showLoading({\r\n      title: '加载中'\r\n    })\r\n\t//网络请求\r\n\twx.request({\r\n\t\turl: url,\r\n\t\tdata: data,\r\n\t\tmethod: method,\r\n\t\theader: {\r\n\t\t\t'Content-Type': 'application/x-www-form-urlencoded',//这是python后台使用的\r\n  \t\t    'Cookie': 'sessionid=' + getApp().globalData.cookie //这是我保存在全局变量中的的sessionid\r\n\t\t},\r\n\t\tsuccess: function (res) {\r\n\t\t\twx.hideLoading()\r\n\t\t\t//服务器返回数据\r\n\t\t\tif (res.statusCode == 200) {\r\n\t\t\t\tresolve(res);\r\n\t\t\t} else {\r\n\t\t\t\t//返回错误提示信息\r\n\t\t\t\treject(res.data);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfail: function (e) {\r\n\t\t\twx.hideLoading()\r\n\t        wx.showToast({\r\n\t          title: '无法连接服务器',\r\n\t          icon: 'loading',\r\n\t          duration: 1000\r\n\t        })\r\n\t\t\treject('网络出错');\r\n\t\t}\r\n})\r\n});\r\n\treturn promise;\r\n}\r\n\r\nmodule.exports = {\r\n    request:request\r\n}\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243调用方法Const tools = require('../../utils/util')\r\n1使用方法tools.request (url,methods ,data).then(res => {\r\n  //服务器返回数据\r\n  console.log('success:',res );\r\n}).catch(res => {\r\n\t//报错\r\n    console.log('fail:',res);\r\n}).finally(()=>{\r\n\t//完成\r\n   console.log('finally:', \"结束\");\r\n})"}
{"title": "微信小程序之获取图片宽度和高度 ", "author": "Rolan", "pub_time": "2021-2-4 14:03", "content": "起源\r\n最近在做A需求, 其中有个小功能点描述如下: 从配置端返回张图片, 期望宽度不变(750)、高度根据图片自适应.\r\n我以为的\r\n// 为便于讲解, 将css作为style属性绑定[实际不推荐]&& src的值先写死[后期改成接口返回的即可]\r\n\r\n  \r\n\r\n复制代码\r\n我一开始想到的就是: 设置内容区的width: 100%会自动占满屏幕宽度, 高度就会自适应. 实际效果: image占据空间为: 屏幕宽度 x 0\r\n解决方案\r\n\r\n核心: 解决如何获取图片的高度\r\n\r\n初级方案\r\n重点: 在图片加载完成后获取对应的图片信息.\r\n经查小程序开发文档后发现, 有提供加载成功的回调, 如下:\r\n\r\n演示Demo如下:\r\n// wxml\r\n\r\n  \r\n\r\n\r\n//js\r\nPage({\r\n  data: {\r\n    imageHeight: 0,\r\n    imageWidth: 0\r\n  },\r\n  loadSuccess(e){\r\n    const { detail: {width, height} } = e\r\n    this.setData({\r\n      imageWidth: width,\r\n      imageHeight:height\r\n    })\r\n  }\r\n})\r\n复制代码\r\n先来看看效果:\r\n\r\n思考个问题:  假设我有100张图片都需要做自适应, 那么是不是多了很多繁琐的setData(), 同时也会导致性能问题.\r\n进阶方案\r\n经朋友提醒后发现, 小程序image还有个属性叫做mode, 可以去设置图片的裁剪&缩放等形式.\r\n\r\n关于mode属性的取值可选项如下图:\r\n\r\n话不多说, 我们看看实际效果如何:\r\n// 750x110的图片\r\n\r\n  \r\n\r\n\r\n// 750x480的图片\r\n\r\n  \r\n\r\n复制代码\r\n看看750x110的效果图:\r\n再看看750x480的效果图:  到了这里, 只需要把src的值改为接口返回的, 是不是就实现了宽度固定、高度自适应的需求了~\r\n最后\r\n该属性主要是为了实现图片的自适应、换个角度来讲, 主要是确保图片不失真。"}
{"title": "从零开始的微信小程序入门教程(三)，有趣且好玩的数据绑定 ", "author": "Rolan", "pub_time": "2021-2-5 09:31", "content": "在网页开发中，我们同样使用JS操作DOM，包括数据渲染，事件监听等，比如我现在要通过点击一个按钮后，替换段落中的本文信息，使用JS可以这么做：<p>我是谁？</p>\r\n<button>点我点我</button>\r\nlet btn = document.querySelector(\"button\"),\r\n    p = document.querySelector(\"p\");\r\nbtn.onclick = function () {\r\n    p.innerHTML = '我是听风是风啊！'\r\n};\r\n没问题，效果虽然实现了，但是类似的操作我们总是得获取并操作DOM，逻辑层与渲染层高度耦合，每一份数据我们似乎都得找到对应的DOM所在，并帮助它们相互关联，这很明显不太友好。伴随发展，angularjs，vue，react的出现，我们知道了MVVM模式的存在，在开发中逻辑层与渲染也得以分离，微信小程序在开发模式上也借鉴了这一点，比如还是上面的效果，用小程序就可以这么做，我们分别在index.wxml和index.js中添加如下代码：<text>{{myName}}</text>\r\n<button bindtap=\"setName\">点我点我</button>\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    myName:'我是谁？'\r\n  },\r\n  setName() {\r\n    this.setData({ myName: \"喷火龙\" })\r\n  }\r\n})\r\n接下来我们解释下小程序数据绑定到底怎么玩，以及其它几种常见的数据交互方式。数据交互数据绑定{{}}熟悉vue等相关框架的同学对于上述例子一定十分熟悉，对于第一次了解这种用法的同学也不用担心，并不复杂，我们来解释下到底什么是意思。首先看WXML，小程序使用{{}}表达式来绑定解析JS文件中定义的变量，而在JS文件的data对象中一般用于定义小程序初始化所需数据，比如例子中的变量myName有一个初始值。Page({\r\n  data: {\r\n    /* 页面初始数据写在这*/\r\n  }\r\n})\r\n接下来就是如何通过点击事件让myName发生变化，在组件button上我们通过点击事件bindtap绑定了一个setName方法，注意，这个方法同样定义在JS文件Page对象中，与data对象同级，以往我们绑定方法一般会给方法名后带括号，小程序的方法绑定并没有括号，比如上面的bindtap=\"setName\"。Page({\r\n  data: {\r\n    /* 页面初始数据写在这 */\r\n  },\r\n  方法名() {\r\n    /* do something */\r\n  }\r\n});\r\n数据绑定除了能用于解决组件文本内容的变更，还有一大作用就是支持组件属性动态变更，什么是组件属性？样式class是属性，组件内连样式style也是属性，比如我们可以有这样一个组件：<text class=\"name\" style=\"color:#fff;background:#e4393c\">{{myName}}</text>\r\n那么通过数据绑定表达式，我们可以让样式也动起来，比如下面这个例子：<text class=\"{{defaultClass}}\" style=\"color:#fff;background:{{backgroudColor}};display:block\">{{myName}}</text>\r\n<button bindtap=\"setName\">点我</button>\r\n.my-name {\r\n  height: 30px;\r\n  width: 100px;\r\n  text-align: center;\r\n  line-height: 30px;\r\n}\r\n\r\n.my-name-new{\r\n  height: 40px;\r\n  width: 200px;\r\n  text-align: center;\r\n  line-height: 40px;\r\n}\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    myName: '我是谁？',\r\n    defaultClass: 'my-name',\r\n    backgroudColor: '#e4393c'\r\n  },\r\n  setName() {\r\n    this.setData({\r\n      myName: \"喷火龙\",\r\n      defaultClass:'my-name-new',\r\n      backgroudColor:'#bbded6'\r\n    })\r\n  }\r\n})\r\n在这个例子中，我们定义了一个class变量，此class默认值由JS文件中提供，除此之外，在内联样式style中的background属性也是变量，当点击按钮，我们切换了class的值以及background的值，在为属性使用数据绑定时，唯一需要注意的是{{}}始终被包裹在一对双引号中，关于数据绑定先说到这里，也算是WXSS的一部分补充。基本逻辑语法{{}}中除了单纯的解析变量，还能做简单的逻辑运算，比如算术计算：<text>{{num1+num2}}</text>\r\nPage({\r\n  data: {\r\n    num1: 1,\r\n    num2: 2\r\n  },\r\n})\r\n我们还能用于字符串拼接，比如下面的例子：<text>听风是风{{str}}</text>\r\n<text>{{\"听风是风\"+str}}</text>\r\nPage({\r\n  data: {\r\n    str: '很酷'\r\n  },\r\n})\r\n这两种拼接方式都是可以的，因为在{{}}中解析的是变量，所以本身是字符时得加上引号。另外，{{}}中还能使用三元表达式，也就是根据条件决定使用不同的结果：<text>{{userName?userName:'登录'}}</text>\r\nPage({\r\n  data: {\r\n    userName: ''\r\n  },\r\n})\r\n比如上面这个例子就是一个简单的用户信息展示，如果有数据展示用户名，如果没有提示登录。三元的用途还很多，比如结合样式使用，通过条件判断来决定使用哪种样式，这在实际开发中都非常实用，待大家执行探索。条件逻辑控制模板是否显示方面，在vue中有v-if，在angular中有ng-if，而在小程序中我们可以使用wx:if来达到同样的效果，当然我们还是得结合{{}}使用，比如：<text wx:if=\"{{bool}}\">我叫听风是风</text>\r\n注意，wx:if与我们以往使用框架中的效果一样，一旦变量为false，整个组件不会加载，在小程序解析的wxml模板中你都找不到它，这和组件加载但display:none是有区别的。问题来了，假设我们希望wx:if不仅是控制一个组件，而是好几个组件的显示隐藏怎么办？这时候我们可以结合block组件使用，看下面的例子：<block wx:if=\"{{bool}}\">\r\n\t<text>我叫听风是风，</text>\r\n\t<text>听风是风你加点油好不好，真的是！</text>\r\n</block>\r\nblock虽然是个组件，但它本身并不会被渲染，只是单纯起到容器的作用，比如当bool为true可以看到wxml中并没有渲染block组件，所以大家不用担心会不会增加无用组件层级的问题。实际开发中有这样一种情况，比如购物车页面，如果当前用户能请求回购物车数据，我们自然是展示购物车信息，如果请求回来没数据，我们肯定得给出购物车为空的友好提示，以angualrjs为例，我一般是提供2个盒子，大致这么个意思：<div class=\"cart\">\r\n    <div ng-if=\"bool\"></div>\r\n    <div ng-if=\"!bool\"></div>\r\n</div>\r\n因为angularjs只提供了ng-if情况，这里通过 ! 取反值，模拟了if else的情况。值得庆幸的是小程序不仅提供了wx:if，还提供了wx:elif以及wx:else，所以条件情况再多，我们都能应对自如，比如：<text wx:if=\"{{num > 0}}\"> 大于0 </text>\r\n<text wx:elif=\"{{num < 0}}\"> 小于0 </text>\r\n<text wx:else> 等于0 </text>\r\n既然谈到了wx:if，用过vue的同学一定会想问小程序有没有类似v-show的指令呢？当然有，我们可以给组件添加hidden属性来达到v-show的效果，hidden接受一个Boolean值。wx:if与hidden的区别是，wx:if值为假时组件直接就不渲染，而hidden为真时组件还是会渲染，只是display为none。更新修改另外关于hidden有个小坑，比如下面这个例子：<text hidden=\"false\">1</text>\r\n你会发现这个组件并不会显示，而正确的写法是这样：<text hidden=\"{{false}}\">1</text>\r\n出于angularjs以及其它框架的习惯，我一直觉得{{}}中应该解析变量，没想到这里小程序居然要使用{{}}包裹一个明确的布尔值。感谢HZz.D.25'11"}
{"title": "从微信小程序到鸿蒙js开发【05】——tabs组件&每日新闻 ", "author": "Rolan", "pub_time": "2021-2-7 09:16", "content": "1、tabs, tab-bar, tab-content上章说到，鸿蒙的list组件仅能支持竖向滚动，无法实现横向滚动。如果需要作出可横向滚动的顶部菜单栏，鸿蒙提供了tabs组件。tabs配合两个子元素组件tab-bar和tab-content，即可很轻松地实现顶部菜单+内容切换效果。tab-bar的子元素为text，tab-content的子元素为div。css：.container {\r\n    width: 100%;\r\n    height: 1200px;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n.tabs{\r\n    width: 100%;\r\n    height: 100%;\r\n}js：export default {\r\n    data: {\r\n        tabBar: [{name: '推荐', color: '#1296db'},\r\n                 {name: '最新', color: '#e20a0b'},\r\n                 {name: '最热', color: '#cdcdcd'}]\r\n    }\r\n}由效果可看出，tab-bar组件是顶部的菜单栏，自带了动态样式。tab-content组件是下方的内容部分，会根据点击的菜单切换到对应的内容部分。tab-bar和tab-content是根据索引值一一对应的。这里还发现，哪怕tab-content给了height: 500px的样式，还是会占满整个tabs的高度。tabs的属性index用于指定默认选中的菜单索引项，vertical指定是否为竖向菜单栏。这里设置为竖向后可以看出，tab-bar变为占满一列，tab-content的height样式起作用，宽度则占满tabs。多放几个菜单项，并设置tab-bar的属性mode=\"fixed\"，则菜单项无法滑动，均布占满整行。mode=\"scrollable\"，就有横向滚动效果了，且点击菜单项后整个菜单栏会有适应移动效果。tab-content属性scrollable-\"true\"，菜单对应内容就可以竖向滚动了，和list效果类似。2、tabs的事件处理如想捕获菜单项变化的事件并进行处理，需在tabs标签中通过onchange进行绑定。在传入的事件对象中，index则为选中菜单项的索引值。这里使用prompt模块的showToast()进行调试。import prompt from '@system.prompt';\r\nexport default {\r\n    data: {\r\n        tabBar: [\r\n            ...\r\n        ]\r\n    },\r\n    changeTab(event) {\r\n        prompt.showToast({\r\n            message: '你点击了第' + event.index + '项。'\r\n        })\r\n    }\r\n}\r\n这个onchange事件捕获的条件比较苛刻，注意：tabs    tab-bar        text    tab-content        div以上组件都必须存在，且tab-bar中text的数量和tab-content中div的数量需一致。或者也可以在text上通过onclick绑定事件，就没有以上的严苛触发条件。import prompt from '@system.prompt';\r\nexport default {\r\n    data: {\r\n        tabBar: [......]\r\n    },\r\n    clickTab(idx) {\r\n        prompt.showToast({\r\n            message: '你点击了第' + idx + '项。'\r\n        })\r\n    }\r\n}当然，弊端也很明显。tab-bar文字下的蓝色线条并没有跟随移动，tab-content也没有随之改变，只是事件可以捕获到。这种用法适用于只希望保留tab-bar的部分，自定义动态样式，可以省略tab-content以及其中的div。哪一种方式更好，还得看需求。3、tabs实现的每日新闻这里运用了整套tabs组件，从聚合数据新闻头条接口请求数据，实现了一个简单的每日新闻模块。因为鸿蒙的页面布局如果高度超过手机总高度就会有滑动效果，tab-bar和自定义的底部菜单都是固定的，因此也用不着list组件了。代码如下：hml：    css：/*每日新闻*/\r\n.newsTabs {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n.newsView {\r\n    width: 100%;\r\n    height: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n.newsItem {\r\n    width: 100%;\r\n    height: 240px;\r\n    border-bottom: 1px solid #bbbbbb;\r\n    display: flex;\r\n    align-items: center;\r\n}\r\n.newsImg {\r\n    margin-left: 20px;\r\n    width: 200px;\r\n    height: 200px;\r\n}\r\n.newsContent {\r\n    display: flex;\r\n    flex-direction: column;\r\n    margin-right: 20px;\r\n    margin-left: 20px;\r\n}\r\n.newsContent>text {\r\n    margin-top: 20px;\r\n    height: 140px;\r\n    font-size: 34px;\r\n    color: #333333;\r\n}\r\n.newsDesc {\r\n    height: 60px;\r\n    line-height: 60px;\r\n    display: flex;\r\n    justify-content: space-between;\r\n}\r\n.newsDesc>text {\r\n    font-size: 28px;\r\n    color: #777777;\r\n}js：    data: {\r\n        newsTitles: [\r\n            {\r\n                name: '头条',\r\n                value: 'top'\r\n            },\r\n            {\r\n                name: '社会',\r\n                value: 'shehui'\r\n            },\r\n            {\r\n                name: '国内',\r\n                value: 'guonei'\r\n            },\r\n            {\r\n                name: '国际',\r\n                value: 'guoji'\r\n            },\r\n            {\r\n                name: '娱乐',\r\n                value: 'yule'\r\n            },\r\n            {\r\n                name: '体育',\r\n                value: 'tiyu'\r\n            },\r\n            {\r\n                name: '军事',\r\n                value: 'junshi'\r\n            },\r\n            {\r\n                name: '科技',\r\n                value: 'keji'\r\n            },\r\n            {\r\n                name: '财经',\r\n                value: 'caijing'\r\n            },\r\n            {\r\n                name: '时尚',\r\n                value: 'shishang'\r\n            }\r\n        ],\r\n        newsList: [],\r\n    },\r\n    changeNewsType(event) {\r\n        let type = this.newsTitles[event.index].value;\r\n        fetch.fetch({\r\n            url: 'http://v.juhe.cn/toutiao/index?key=xxxxx&type=' + type,\r\n            responseType: 'json',\r\n            success: res => {\r\n                let data = JSON.parse(res.data);\r\n                this.newsList = data.result.data;\r\n            }\r\n        })\r\n},"}
{"title": "从零开始的微信小程序入门教程(二)，初识WXML与WXSS ", "author": "Rolan", "pub_time": "2021-2-5 09:34", "content": "本文将围绕WXML与WXSS展开，那么本文开始。初识WXML对于每一位前端开发者而言，熟练的编写静态页面是入门的开始，在小程序中这一点也无法避免。在介绍微信小程序功能交互之前，我们先了解在小程序中如何实现页面布局与页面样式，这里先来介绍WXML。WXML全称WeiXin Markup Language（微信标记语言），与HTML有些不同的是，这是微信框架提供的一套标签语言。我们在写HTML页面时，总是习惯使用div进行整体布局，使用span描述文本信息，使用img装载图片等等，但在WXML中会有一些差异。WXML提供的每个标签都是一个组件，使用过vue，react或angular的同学对于组件概念一定不会陌生，鉴于刚入门的前端同学，这里做个简单解释。我们在编程时总会考虑代码复用性，比如一个页面有好几处的样式完全相同，那么我们可以将这一块样式定义在一个class中，接下来只要把这个class加在你需要展示的地方就可以了。.bth{\r\n    outline:none;\r\n    border:none;\r\n    background:#e4393c;\r\n    color:#fff;\r\n    text-align: center;\r\n    cursor: pointer;\r\n}\r\n<div>\r\n    <button class=\"btn\">按钮1</button>\r\n    <div>\r\n        <button class=\"btn\">按钮2</button>\r\n    </div>\r\n</div>\r\n组件的概念也是如此，比如提示类弹窗在整个网站中的多个页面都会使用，那我们为什么不把这个弹窗功能封装成一个组件呢，之后不管哪个页面需要此功能，只要添加这个组件就可以了。要实现这个组件我们都得先定义好组件模板（HTML，决定组件结构），组件默认样式（CSS，决定组件外观），组件功能（JS，决定组件负责做哪些事）等。而在小程序框架中，官方已经提前帮我们实现了大量的组件，比如基本视图组件中的view相当于HTML中的div可用来布局；基本内容组件中的text相当于span，可以用来装载多段行内文本，再如媒体组件中的image，它相当于img标签用来承载图片信息。除此之外，每个小程序组件都默认提供了一些非常nice的属性，这里以image组件为例。假设我们希望图片加载完成后做一件事情，比如获取图片的宽度，这里就可以利用image的bindload（图片加载完成后触发）属性，打开我们的小程序开发工具，在index.wxml中添加一个image组件：<view>\r\n  <!-- 图片直接拿了哔哩哔哩的，万一以后打不开了，大家自己随便找个图 -->\r\n  <image bindload='imgLoad' src='https://i0.hdslb.com/bfs/live/6c41e9f57094fae13728cd27e7d1c1379a3f1fcd.jpg@320w_330h_1c_100q.webp'></image>\r\n</view>\r\n对应的，在index.js添加如下代码：const app = getApp()\r\n\r\nPage({\r\n  //图片加载完成后执行的方法\r\n  imgLoad(image) {\r\n    console.log(image.detail.width);\r\n  }\r\n})\r\n保存，可以看到在编辑器console控制台输出了320，这是image组件默认的宽度样式。再例如图片懒加载在页面优化中也是需要考虑的一点，而image提供了lazy-load属性用于解决图片懒加载问题。小程序官方提供的组件数量较多，很遗憾没办法一一介绍，但官方已经做了明细的组件分类，我们要做的就是拿到一个页面清楚知道需要用到哪些组件，一个组件需要用到哪些属性，就像搭积木一样，用这些组件来组成小程序的页面，还记得最初学HTML时标签使用的陌生感吗？它并没有难度，只是需要多加练习而已。关于WXSS可以放心的是WXSS并没有对于样式高度拓展，之前CSS样式怎么玩，现在在小程序还是一样的玩。这点官方文档有点坑，比如官方说选择器目前只支持如下几种：项目例子含义#id#parent选择id='parent'的组件.class.child选择所有class='child'的组件elementview选择所有view组件element,elementview,text选择所有view组件和text组件::aftertext::after在text组件后面插入内容::beforetext::before在text组件前面插入内容但事实证明子代选择器，后代选择器以及伪类选择器大部分都支持，比如下面的例子：<view class=\"box\">\r\n\t<text>一往情深深几许，</text>\r\n\t<text>深山夕照深秋雨。</text>\r\n\t<input placeholder=\"输入作者名字\" />\r\n</view>\r\n.box>text:first-child {\r\n  color: #e4393c;\r\n}\r\n\r\ninput:active {\r\n  border: 1px solid #ddd;\r\n}\r\n但也有不支持的部分，比如在手机上大家是没办法使用:hover伪类，毕竟手机上没有鼠标悬浮。关于WXSS，小程序也做了亮点拓展，我们先说新增的尺寸单位rpx，官方描述如下：rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。并提供了如下几个手机型号的转换例子：设备型号rpx换算px (屏幕宽度/750)px换算rpx (750/屏幕宽度)iPhone51rpx = 0.42px1px = 2.34rpxiPhone61rpx = 0.5px1px = 2rpxiPhone6 Plus1rpx = 0.552px1px = 1.81rpx这里我提前查了下这三款手机的逻辑像素比：iPhone5：320px x 568pxiPhone6 : 375px x 667pxiPhone6 plus : 414px x 736px我们从UI设计师手上拿的图一般都是px单位的标注，如果在小程序上直接用px做单位会因为各类手机屏幕占宽比不同，导致一样的设计在不同设备上表现差异的问题，所以以往我们通常用rem或者vw来解决这个问题，而rpx只是小程序提供的另一解决方案。假设UI以iphone6机型为标准做的设计稿，设计稿上有一个盒子宽高各位200px，我们尝试切换设备型号，效果如下：可以看到在iphone5的情况下，盒子右边留白还挺多，切到iphoneX时，留白明显减少。现在我们试试改成rpx，怎么计算呢？上面例子已经给出，1px=rpx*(750/设备屏幕宽度)，因为我们假设的原型图是以iphone6为标准，所以这里就是1px=rpx*(750/375)，所以才有1px=2rpx这个结论。大家可以试试，在iphone6的情况下将200px改为400rpx，修改后可以看到盒子大小并不会改变。OK，现在我们再来修改设备型号：哎？经过修改，我们发现不管怎么切换设备型号，盒子所占宽度的比例，一直都是接近屏幕宽一半左右，这就是rpx的作用。官方推荐开发微信小程序时设计师用 iPhone6 作为视觉稿的标准，毕竟2倍好计算，万一设计师没用iphone6，大家也可以套上面的公式知道应该设置多少，那么关于rpx就说到这里。WXSS第二个拓展就是关于样式导入，以前我们写HTML都是通过link来引入样式，但大家发现没，小程序中WXML与WXSS都是放在一个文件下就会自动引入样式，跟没就没看到引入样式的标签，那我要引入别处的样式咋整，所以小程序提供了@import导入外联样式的方法，写过less的同学看到这个一定就特别熟悉了，我们来看个例子：我们现在index.wxml中添加一个标签：<!-- index.wxml -->\r\n<text class='box'>1</text>\r\n并在index.wxss添加如下样式：/* index.wxss */\r\n.box{\r\n  width: 400rpx;\r\n  height: 400rpx;\r\n  display: block;\r\n  background-color: antiquewhite;\r\n}\r\n现在，我们在全局环境新建一个common.wsxx样式表/* common.wxss */\r\n.box{\r\n  text-align: center;\r\n}\r\n在index.wxss表头添加如下代码@import \"../../common.wxss\";，添加完成后保存：@import \"../../common.wxss\";\r\n.box{\r\n  width: 400rpx;\r\n  height: 400rpx;\r\n  display: block;\r\n  background-color: antiquewhite;\r\n}\r\n界面刷新，我们发现common里面定义的文本居中样式就对index页面生效了，说明外联样式引入成功。注意，小程序根目录的app.wxss是指全局样式，只要在里面写的样式，会对所有页面生效，就相当于小程序默认为每个页面引入了这个样式表。所以当有一些样式可复用，而我们又想手动控制是否引入时，利用@import就是不错的方法。总忙忙碌碌，关于微信WXML与WXSS的介绍先说这里，较为遗憾的是，我确实没办法把小程序中的每个组件都说一遍，还得各位自行过一遍，大致知道哪个是做什么，在日后开发中，能立马想到该使用哪个组件。其实知道了这些，我们已经可以初步搭建静态的小程序页面了。"}
{"title": "小程序省市区选择器，对接公司的地址数据 ", "author": "Rolan", "pub_time": "2021-2-7 09:27", "content": "公司开始做小程序了，小程序的省市区三级联动picker组件mode=\"region\",之前也有接触过，这一次一上来先尝试了一下，发现不能和之前公司的地址库结合，因为之前项目都是和后端通过地区编码来交互的，这个自带的无法满足现有的情况。于是用小程序picker组件的多列选择器自制了一个。开始主题之前先说一下地址数据的问题，我司的数据也是我自己2020年8月从高德接口导出来的最新数据并同步给后端的：高德行政区查询接口文档通过这个接口可以获取全国的行政区数据，至于拿到数据以后组装成什么格式，这里不细说了，都是基本功，只要留意着点省直辖县，市直辖镇等特殊级别关系的情况。当然小程序省市区选择器数据咱们也是有办法弄到，只是，现有在用的数据库不宜大动，于是没有用，传送门也放在这里吧。小程序官方地区选择器数据当时我有这么两个格式：一个是树形的，拿到就可以用：然而一看大小，好家伙，440kb，太大了，用不了。另一个是平铺格式的：这个96kb，虽然还是有点大，压缩一下，勉强可以用了。只是这不是一个树形结构，所以前期还要准备几个方法备用。地区编码是有其规则的，比如，省级行政区是两位，后四位是“0000”，地市一级的是四位，后两位是“00”，到区县一级则是完整的6位。于是先把平铺的json，过滤出省市区三个级别的数组出来。// region.js\r\n// 这个data就是那个平铺格式的json\r\nconst data = require('./data.js');\r\n\r\nconst list = []\r\nconst province = []\r\nconst city = []\r\nconst area = []\r\n\r\nObject.entries(data).forEach(val => {\r\n  const key = Number.parseInt(val[0])\r\n  const model = { key: val[0], value: val[1] }\r\n  list.push(model)\r\n  if (!(key % 1e4)) {\r\n    province.push(model)\r\n  } else if (!(key % 100)) {\r\n    city.push(model)\r\n  } else {\r\n    const num = Number(val[0].substr(2))\r\n    if (num > 9000) {\r\n      city.push(model)\r\n    } else {\r\n      area.push(model)\r\n    }\r\n  }\r\n})\r\n\r\nmodule.exports = {\r\n  srcList: list,\r\n  srcProvince: province,\r\n  srcCity: city,\r\n  srcArea: area,\r\n}这样，省一级的行政区数组就拿到了，地市一级和区县一级的则是每次根据选择的上一级的地区编码，来过滤出其管辖的下一级行政区划的数组：// createTree.js\r\nconst region  = require('./region');\r\n\r\nmodule.exports = {\r\n  /**\r\n   * load city list by province data\r\n   *\r\n   * @param province: { key: 330000, value: '浙江省' }\r\n   * @returns {Array}\r\n   */\r\n  loadCity (province) {\r\n    if (province && Object.keys(province).length) {\r\n      const list = region.srcCity.filter(val => {\r\n        const num = Number.parseInt(province.key)\r\n        return (val.key - num) < 1e4 && (val.key % num) < 1e4\r\n      })\r\n      // Municipalities directly under the central government\r\n      return list.length ? list : [province]\r\n    } else return []\r\n  },\r\n\r\n  /**\r\n   * load area list by city data\r\n   *\r\n   * @param city: { key: 330100, value: '杭州市' }\r\n   * @returns {Array}\r\n   */\r\n  loadArea (city) {\r\n    if (city && Object.keys(city).length) {\r\n      const cityKey = Number.parseInt(city.key)\r\n      const isNotProvince = cityKey % 1e4\r\n      const calcNum = isNotProvince ? 100 : 1e4\r\n      const list = region.srcArea.filter(val => {\r\n        return (val.key - cityKey) < calcNum && val.key % cityKey < calcNum\r\n      })\r\n      // Prefecture-level city\r\n      return list.length ? list : [city]\r\n    } else return []\r\n  },\r\n}好了，准备工作完毕，进入小程序页面。<picker \r\n  class=\"picker\" \r\n  mode=\"multiSelector\" \r\n  bindchange=\"bindMultiPickerChange\" \r\n  bindcolumnchange=\"bindMultiPickerColumnChange\" \r\n  bindcancel=\"cancel\"\r\n  value=\"{{regionIndex}}\"\r\n  range=\"{{regionArray}}\"\r\n  range-key=\"value\">\r\n  <mp-cell ext-class=\"utils__item\">\r\n    <text class=\"text\">所在地区</text>\r\n    <input bindinput=\"inputChange\" \r\n    readonly \r\n    disabled \r\n    value=\"{{areaText}}\" \r\n    class=\"weui-input\" \r\n    placeholder=\"所在地区\"/>\r\n  </mp-cell>\r\n</picker>页面元素结构就是这样，没什么好说的，这个可以直接看小程序picker中多列选择器的文档。先看一下，页面用到的相关数据吧。data: {\r\n    areaText: '', // 显示的省市区文字\r\n    blockArray: [], // 显示的省市区三级数组，二维数组\r\n    blockIndex: [0, 0, 0], // 显示出来的选择下标，默认，[0,0,0]\r\n    regionArray: [], // 选择器当前的省市区三级数组，二维数组\r\n    regionIndex: [0, 0, 0], // 选择器当前选中的下标\r\n    provinceList: srcProvince, // 省级数组，\r\n    cityList: [], // 地市级数组，\r\n    areaList: [], // 区县数组\r\n}可以看到，我这里有两个array和index的数组，这是因为，其中一个保存的是已被选择的数据，另一个则是当前正在选择的数据，主要考虑到一个取消功能。你要把之前选中的保存起来，下面选择的是点击了取消按钮，才能还原为上次选择的数据。const  { srcProvince } = require('../../utils/region.js');\r\nconst { \r\n    loadCity, \r\n    loadArea, \r\n} =  require('../../utils/createTree.js');\r\n\r\nonLoad() { // 初始化数据，这里还涉及到一个数据回显，比较麻烦，放到后面再说\r\n  let cityList, areaList,\r\n  cityList = loadCity(srcProvince[0]);\r\n  areaList = loadArea(cityList[0]);\r\n  this.setData({\r\n    blockArray: [srcProvince, cityList, areaList],\r\n    regionArray: [srcProvince, cityList, areaList],\r\n    cityList,\r\n    areaList,\r\n  })\r\n},\r\n\r\nbindMultiPickerChange (e) { // 点击确定按钮的事件\r\n    const oldKey = this.data.blockArray[2][this.data.blockIndex[2]].key; // 这是留住上次选中的第三级区域代码\r\n    const newKey = this.data.regionArray[2][this.data.regionIndex[2]].key; // 本次选中的第三级区域代码\r\n    \r\n    if(oldKey !== newKey) { // 如果本次选择和之前的不一样，则修改数据\r\n      this.setData({\r\n        blockArray: this.data.regionArray,\r\n        regionIndex: e.detail.value,\r\n        blockIndex: e.detail.value,\r\n        areaText: `${this.data.regionArray[0][this.data.regionIndex[0]].value}${this.data.regionArray[1][this.data.regionIndex[1]].value}${this.data.regionArray[2][this.data.regionIndex[2]].value}`\r\n      })\r\n    }\r\n  },\r\n  \r\nbindMultiPickerColumnChange (e) { // 这是选择器列数据发生变化的时候，就是选择器滚动的时候\r\n    const regionIndex = this.data.regionIndex;\r\n    // 这个 column 就是发生变化的是第几列，0,1,2，value则是滚动下标\r\n    regionIndex[e.detail.column] = e.detail.value;\r\n    // 下面的处理是当选择上一级的时候，要把下一级下标设置为0，防止下一级下标越界\r\n    if(e.detail.column === 0) {\r\n      regionIndex[2] = 0;\r\n      regionIndex[1] = 0;\r\n    } else if(e.detail.column === 1) {\r\n      regionIndex[2] = 0;\r\n    }\r\n    const provinceItem = srcProvince[regionIndex[0]];\r\n    let cityList = [], areaList = [];\r\n    cityList = loadCity(provinceItem);\r\n    areaList = loadArea(cityList[regionIndex[1]]);\r\n\r\n    this.setData({\r\n      regionArray: [srcProvince, cityList, areaList],\r\n      regionIndex: regionIndex,\r\n      cityList,\r\n      areaList,\r\n    })\r\n  },\r\n  \r\n  cancel() { // 点击取消的时候需要把数据还原回选择之前的状态\r\n    this.setData({ \r\n      regionArray: this.data.blockArray,\r\n      regionIndex: this.data.blockIndex, \r\n    });\r\n  },这个选择器的逻辑就是以上这些，主要是选择器列变化的时候要把当前列下一级的行政区划数组找出来，并且留意用户取消的情况。最后再说说数据回显，现在是没有数据的时候，就是默认的[0,0,0]的情况，处理很简单，否则，就是有数据的情况，我们跟后端之间的交互都是通过最后一级的行政编码来的，就是我这边给后台就只有一个areaCode，后端返回也只有一个areaCode。因为这个在无论我们当前项目还是在这个小程序的后台项目上，逻辑上都不会存在只有省一级或者只有省市两级的情况，所以。只要有数据，这个areaCode必然是区县一级的代码。于是在createTree.js里增加一个方法：/*\r\n  * areaCodeToMap\r\n  * @param {string} code\r\n  * @param {array} list\r\n  */\r\n\r\n  areaCodeToMap(code, list) {\r\n    const result = {\r\n      map: {},\r\n      index: 0,\r\n    };\r\n    list.map((item, i) => {\r\n      if(item.key === code) {\r\n        result.map = item;\r\n        result.index = i;\r\n      }\r\n    })\r\n    return result;\r\n  },这是通过这个areaCode把上面两级的行政区对象及其下标找出来，只要有了上面两级的行政区对象，则又可以通过之前的loadCity和loadArea两个方法设置选择器数据了：setArea() { // 省市区数据回显\r\n    let index = 0;\r\n    let cityList = [], areaList = [], provinceIndex = 0, cityIndex = 0, areaIndex = 0;\r\n    const areaCode = this.data.form.areaCode;\r\n    if(areaCode) {\r\n      // 省级信息回显\r\n      const province = areaCodeToMap(`${areaCode.substring(0, 2)}0000`, srcProvince);\r\n      const provinceItem = province.map;\r\n      provinceIndex = province.index;\r\n\r\n      // 地市级信息回显\r\n      cityList = loadCity(provinceItem);\r\n      const city = areaCodeToMap(`${areaCode.substring(0, 4)}00`, cityList);\r\n      const cityItem = city.map;\r\n      cityIndex = city.index;\r\n\r\n      // 区县级信息回显\r\n      areaList = loadArea(cityItem);\r\n      const area = areaCodeToMap(areaCode, areaList);\r\n      const areaItem = area.map;\r\n      areaIndex = area.index;\r\n      \r\n      this.setData({\r\n        blockArray: [srcProvince, cityList, areaList],\r\n        regionArray: [srcProvince, cityList, areaList],\r\n        blockIndex: [provinceIndex, cityIndex, areaIndex],\r\n        regionIndex: [provinceIndex, cityIndex, areaIndex],\r\n        cityList,\r\n        areaList,\r\n      })\r\n      this.setData({\r\n        areaText: `${this.data.regionArray[0][this.data.regionIndex[0]].value}${this.data.regionArray[1][this.data.regionIndex[1]].value}${this.data.regionArray[2][this.data.regionIndex[2]].value}`\r\n      })\r\n}上真机效果图：其实这里还涉及到省市区选择器和地图选址组件的交互，比如选择完地区以后，将经纬度设置成该地区的经纬度，进入地图后定位到该地区，还有在地图定位完位置后根据地图返回的areaCode再调用一遍setArea方法直接回显省市区等等，这些不是本文探讨范围，不再细说了。"}
{"title": "微信小程序---自动化测试 ", "author": "Rolan", "pub_time": "2021-2-7 09:30", "content": "关于小程序的自动化测试，我是根据微信小程序官方文档来走的。没有做太深入，只点点点。\r\n总体流程是先安装测试环境，设置安全设置，然后项目目录中创建一个测试文件夹并在文件夹中创建测试代码文件，一步一步走\r\n安装环境\r\n安装小程序自动化JDK（miniprogram-automator），同时安装jest（前端测试框架） npm i miniprogram-automator jestnpm i jest -g\r\n复制代码\r\n接着打开\"安全设置 CLI/HTTP 调用功能\"（<—_—#>丫的找了老半天）\r\n\r\n进入里面，它现在长这个样子\r\n\r\n然后在项目中创建小程序自动化测试文件夹，和测试脚本index.spec.js\r\n\r\n\r\n写代码\r\n在index.spec.js中写测试代码，我不会只能先直接复制官网了，跟就要跟完。\r\nconst automator = require('miniprogram-automator')\r\n\r\ndescribe('index', () => {\r\n  let miniProgram\r\n  let page\r\n\r\n  beforeAll(async () => {\r\n    miniProgram = await automator.launch({\r\n      projectPath: '/Users/xxxxx/Desktop/company/xxxxx'\r\n    })\r\n    page = await miniProgram.reLaunch('/pages/index/index')\r\n    await page.waitFor(500)\r\n  }, 3000000)\r\n\r\n  afterAll(async () => {\r\n    await miniProgram.close()\r\n  })\r\n})\r\n复制代码\r\n上面这个就是一切的源头⬆️，我就按照我自己的理解来看这段了。\r\n首先是官网写的引入来：\r\n\r\n启动并连接工具\r\n重新启动小程序到首页\r\n断开连接并关闭工具\r\n\r\n我理解就是引入了自动化对象automator，然后固定方法describe，回调里面才是具体事件。beforeAll一切开始之前，连接项目，projectPath项目路径，我写的完整的路径，就是在terminal里面cd cd cd到我的项目里，然后pwd出来的路径。然后page对应的是项目被打开时进入的路径。page.waitFor(500)这个就是等待500毫秒，当然waitFor方法里面可以string number function三种值看下面⬇️\r\n// 如果条件是 string 类型，那么该参数会被当成选择器，当该选择器选中元素个数不为零时，结束等待。\r\n\r\n// 如果条件是 number 类型，那么该参数会被当成超时时长，当经过指定时间后，结束等待。\r\n\r\n// 如果条件是 Function 类型，那么该参数会被当成断言函数，当该函数返回真值时，结束等待。\r\n复制代码\r\nbeforeAll的第二个参数就很好理解，就等待时间3000000毫秒这个时间内作为初始化时间，设置短了有可能项目都还没有编译完它就可能结束了。\r\nafterAll就所有的方法什么的都结束了之后执行，有点类似生命周期。\r\n接着就是模拟鼠标了，作为一个0级测试我只会点点点。\r\nit('list action', async () => {\r\n  const listHead = await page.$('.kind-list-item-hd')\r\n  expect(await listHead.attribute('class')).toBe('kind-list-item-hd')\r\n  await listHead.tap()\r\n  await page.waitFor(200)\r\n  expect(await listHead.attribute('class')).toBe(\r\n    'kind-list-item-hd kind-list-item-hd-show',\r\n  )\r\n  await listHead.tap()\r\n  await page.waitFor(200)\r\n  expect(await listHead.attribute('class')).toBe('kind-list-item-hd')\r\n  await listHead.tap()\r\n  await page.waitFor(200)\r\n  const item = await page.$('.index-bd navigator')\r\n  await item.tap()\r\n  await page.waitFor(500)\r\n  expect((await miniProgram.currentPage()).path).toBe('page/component/pages/view/view')\r\n})\r\n\r\n复制代码\r\n讲一下我理解的，it就是一个固定方法，第一参数是这个it要做的事，第二个参数事具体执行，async就是同步啊。可以有很多个it，会从上到下顺序执行。\r\n首先获取页面节点，page.$() 看到这个请脑补JQuery，await等page的方法执行完，所以就是async...await，那page的方法应该是异步的。这里弄成同步，然后一步一步之行，expect就是断言，toBe就是预测expect里面的内容返回值，直接翻译就是期望它是它。听懂掌声～！！！piapiapia～，那么什么时候加这个await，只要是个方法，就加这个await。别漏了漏了就不是线性执行的感觉。那接下来就非常好懂啦。tap()就是咱在小程序里面写的bindtap，点击啦～。（await miniProgram.currentPage()).path这个就是获取当前页面的路径，去掉path就是当前页面了。如果切换的页面，一定要page = await miniProgram.currentPage()，写到这里忘记说了，这个it方法是放在describe里面的，在⬇️面。嘿嘿\r\nconst automator = require('miniprogram-automator')\r\n\r\ndescribe('index', () => {\r\n  let miniProgram\r\n  let page\r\n\r\n  beforeAll(async () => {\r\n    miniProgram = await automator.launch({\r\n      projectPath: '/Users/xxxxxxxxxx/Desktop/company/xxxxxxxx'\r\n    })\r\n    page = await miniProgram.reLaunch('/pages/index/index')\r\n    await page.waitFor(500)\r\n  }, 3000000)\r\n\r\n  afterAll(async () => {\r\n    await miniProgram.close()\r\n  })\r\n  it('xxxxxx', async() => {\r\n    page = await miniProgram.reLaunch('/xxxx/xxxx/xxxx?xxxx=/xxxxx/xxxxxx/xxxxx')\r\n    expect((await miniProgram.currentPage()).path).toBe('pages/index/index')\r\n  })\r\n})\r\n复制代码\r\n启动\r\n然后就是启动了，在terminal里面cdcdcd到写这个脚本的文件夹里面，然后jest index.spec.js就好了。现象就是，小程序会被关闭然后重新启动，然后执行脚本里面的it方法，执行完之后关闭小程序，在terminal里显示结果。不管是成功还是失败都会关闭，因为afterAll里面设置的是关闭哦，那个close方法。\r\n最后总结与更多尝试\r\n初步使用来看挺简单的，当然那些类啊什么的都是提前知道的，比如我是在页面里审查元素看的。那些方法是在官方文档一边查一边写，获取的到页面元素其实也是一种数据啦，循环什么的想怎么招呼就怎么招呼。两个美元符号是获取多个元素，返回数组。提示每个it方法不要执行超过5s，不然说是超时。下面都一些方法，用来打破大家不敢写心思。关于page有很多方法，由于名字起的简单明了我就不多介绍啦。大家自己看看就会，很简单的。在用的时候区分一下是方法还是属性就好了。比如input就是一个方法，我写的时候一直用等号，满脑子都是这个input为什么不能被赋值呢？？？仔细瞅瞅才看到它是个方法。很无奈脑袋不够用了。\r\nit('xxxxxxxx', async() => {\r\n    const meetingRes = await page.$$('.listBar');\r\n    for(let i = -1; ++i < meetingRes.length; ){\r\n      if (await meetingRes[i].text() === 'xxxxxx') {\r\n        await meetingRes[i].tap();\r\n      }\r\n    }\r\n    await page.waitFor();\r\n    page = await miniProgram.currentPage();\r\n  })\r\n复制代码\r\nit('xxxxxx', async () => {\r\n    const inputList = await page.$$('.weui-input')\r\n    expect(inputList.length).toBe(6);\r\n    let index = -1;\r\n    while(++index < inputList.length) {\r\n      switch(await inputList[index].attribute('data-field')) {\r\n        case 'xxxxx' || 'xxxx':\r\n          console.log(index)\r\n          await inputList[index].input('xxxx' + new Date().getTime())\r\n          break;\r\n        case 'xxxxxx':\r\n          await inputList[index].tap();\r\n          await page.waitFor(500);\r\n          expect((await miniProgram.currentPage()).path).toBe('pages/xxx/xxxx/xxxxx')\r\n          page = await miniProgram.currentPage();\r\n          const meetingRoomDetail = await page.$$('.xxxx')\r\n          await meetingRoomDetail[0].tap();\r\n          await page.waitFor(500);\r\n          expect((await miniProgram.currentPage()).path).toBe('pages/xxxx/xxxxx')\r\n          page = await miniProgram.currentPage();\r\n          break;\r\n        case 'xxxxxx':\r\n          await inputList[index].tap();\r\n          await page.waitFor(500);\r\n          const confirmdate = await page.$('.van-picker__confirm')\r\n          await confirmdate.tap();\r\n          break;\r\n        case 'xxxxxx':\r\n          await inputList[index].tap();\r\n          await page.waitFor(500)\r\n          const periodList = await page.$$('.van-checkbox__icon');\r\n          let i = periodList.length;\r\n          let count = 0;\r\n          while(--i >= 0) {\r\n            if (periodList[i].attribute('class') === 'van-checkbox__icon van-checkbox__icon--round' && count === 0) {\r\n              count++\r\n              await periodList[i].tap();\r\n              break;\r\n            }\r\n          }\r\n          const confirmperiod = await page.$('.van-picker__confirm')\r\n          await confirmperiod.tap();\r\n          break;\r\n        case 'xxxxxx':\r\n          await inputList[index].tap();\r\n          await page.waitFor(500);\r\n          expect((await miniProgram.currentPage()).path).toBe('pages/xxxx/xxxx/xxxxx')\r\n          page = await miniProgram.currentPage();\r\n          const nameinput = await page.$('.van-field__input')\r\n          await nameinput.input('xxxx')\r\n          await page.waitFor(1200);\r\n          const searchList = await page.$$('.xxxx');\r\n          await searchList[0].tap();\r\n          const closeSearch = await page.$('.xxxx')\r\n          await closeSearch.tap();\r\n          const confirm = await page.$('.xxxx')\r\n          await confirm.tap();\r\n          await page.waitFor(500);\r\n          expect((await miniProgram.currentPage()).path).toBe('pages/xxxx/xxxx')\r\n          page = await miniProgram.currentPage();\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n    const submit = await page.$('.weui-btn')\r\n    expect(submit.tagName).toBe('button')\r\n    expect(await submit.text()).toBe('确定')\r\n    await submit.tap();\r\n    await page.waitFor(500)\r\n    expect((await miniProgram.currentPage()).path).toBe('pages/xxxx/xxxxx')\r\n    page = await miniProgram.currentPage();\r\n  })\r\n复制代码\r\n尝试了一下，自己写了一个自动化脚本，别说还真的让我给测出来了问题。自动化脚本真的很有意义，就像我现在写的项目里，迭代很快。我也不能保证每次迭代都不会影响到其它功能，或者什么东西被无意间给改了功能造成了阻塞，同时也是一种主动发现问题的方法。用魔法打败魔法，用程序找程序的问题，嗯～大概就是这个意思。还有一个就是之前说的一切的源头的地方，那里是可以对进入小程序的初始页面做更改，所以如果有从公众号跳转到小程序中的某个页面的业务场景，可以在这里模拟一下试试。毕竟公众号不能跳体验版，每次提交审核又要很长时间"}
{"title": "微信小程序支付（服务商模式）解决 ", "author": "Rolan", "pub_time": "2021-2-7 09:44", "content": "前言微信支付官方文档： 小程序开发与支付、服务商的关系，参考这个文档1、第三方（服务商）自己申请账号，自己开发，生成指定内页给特约商户用，该模式简称中心化模式。2、以特约商户身份申请小程序appId，第三方完成开发，该模式简称外包模式。 3、通过开放平台第三方开发者代特约商户进行小程序的开发，该模式简称第三方模式。本文适用于中心化模式，服务商自己开发一个小程序，但是收款是直接受到对应的特约商户账户中，不收到服务商自己账户中。基本流程服务商再微信后台申请微信小程序小程序开通微信支付或绑定已开通微信支付的商户号特约商户需要操作的流程服务商再微信支付商户后台，为特约商户开通微信服务商模式下的微信支付账户特约商户在收到微信邮件发送的登录账号和密码，登录自己的微信支付商户后台，绑定小程序的appId提交审核，被拒绝的话再次提交审核，直到审核通过服务商管理后台中找到\"待关联商户号\"并确认登录微信支付服务商商户后台，手动为特约商户绑定与服务商主体或特约商户主体一致的公众号，APP或小程序的appId。最多配置5个，手工配置路径：\"服务商商户平台-服务商功能-子商户管理-开发配置-特约商户APPID配置\"。支付部分appid：注意这里是服务号的appid，不是小程序的mch_id：这里是用服务商的id 在我的账号一栏可以找到sub_appid： 这里才是小程序的appidsub_mch_id： 这里对应特约商户号id 付款到对应商户的凭证就是这个 在注册特约商户的时候邮件里可以找到 这里建议配置到数据库动态传递nonce_str： 随机字符串body： 这里随意填写，也可以填写商品名称out_trade_no： 订单号total_fee： 这里必须是整数，单位是分trade_type： 公众平台支付或小程序支付填写：JSAPI，如果是APP的填写：APPsub_openid： 此参数是在发起支付前在小程序内调起wx.login 方法获得code 然后后台通过置换 获得用户openidspbill_create_ip：这里可以随意填写notify_url： 支付回调的地址sign： 此参数为签名参数 需要将需要传递的参数进行排序并且进行md5签名，需要注意的是需添加参数key 即之前修改的服务商api密钥好了 参数分析完毕 在后台调用统一下单方法 不出意外是成功的，下单代码如下：Controller部分@RestController\r\n@RequestMapping(\"/payment\")\r\npublic class WxPayController {\r\n\r\n    private Logger logger = LoggerFactory.getLogger(WxLoginController.class);\r\n\r\n    @Autowired\r\n    private AppletOrderService appletOrderService;\r\n\r\n    @Autowired\r\n    private WxPayProperties wxPayProperties;\r\n\r\n    @ResponseBody\r\n    @PostMapping(value = \"/appletWxPay\", produces = \"application/json;charset=UTF-8\")\r\n    public Map appletWxPay(@RequestParam String openId, String totalFee) throws Exception {\r\n        logger.info(\"[WxPayController].appletWxPay...openId:{}\", openId);\r\n        SortedMap resultMap = new TreeMap();\r\n        String body = \"测试\";\r\n        String out_trade_no = String.valueOf(IdWorker.getInstance().nextId());\r\n        PreOrderResult preOrderResult = appletOrderService.placeOrder(body, out_trade_no, totalFee, openId);\r\n        System.out.println(preOrderResult);\r\n\r\n        if(WxContants.SUCCESS.equals(preOrderResult.getReturn_code()) && WxContants.SUCCESS.equals(preOrderResult.getResult_code())){\r\n            resultMap.put(\"appId\", wxPayProperties.getApp_id());\r\n            resultMap.put(\"timeStamp\", Long.toString(System.currentTimeMillis()/1000));\r\n            resultMap.put(\"nonceStr\", UUID.randomUUID().toString().replaceAll(\"-\", \"\").toUpperCase());\r\n            resultMap.put(\"package\", \"prepay_id=\"+preOrderResult.getPrepay_id());\r\n            resultMap.put(\"signType\", \"MD5\");\r\n            resultMap.put(\"sign\", SignUtils.createSignByMd5(resultMap, wxPayProperties.getKey()));\r\n            resultMap.put(\"returnCode\", \"SUCCESS\");\r\n            resultMap.put(\"returnMsg\", \"OK\");\r\n            logger.info(\"【小程序支付】统一下单成功，返回参数:\"+resultMap);\r\n        }else{\r\n            resultMap.put(\"returnCode\", preOrderResult.getReturn_code());\r\n            resultMap.put(\"returnMsg\", preOrderResult.getReturn_msg());\r\n            logger.info(\"【小程序支付】统一下单失败，失败原因:{}\" + preOrderResult.getReturn_msg());\r\n        }\r\n        logger.info(\"[WxPayController].appletWxPay...CodeUrl:{}\", preOrderResult.getCode_url());\r\n        return resultMap;\r\n    }\r\n\r\n}\r\nSerivice部分@Service\r\npublic class AppletOrderServiceImpl implements AppletOrderService{\r\n\r\n    @Autowired\r\n    private WxPayProperties wxPayProperties;\r\n\r\n    @Override\r\n    public PreOrderResult placeOrder(String body, String out_trade_no, String total_fee, String openId) throws Exception {\r\n        // 生成预付单对象\r\n        PreOrder preOrder = new PreOrder();\r\n        preOrder.setAppid(wxPayProperties.getApp_id());\r\n        preOrder.setMch_id(wxPayProperties.getMch_id());\r\n        preOrder.setSub_appid(wxPayProperties.getSub_app_id());\r\n        preOrder.setSub_mch_id(wxPayProperties.getSub_mch_id());\r\n        String nonce_str = UUID.randomUUID().toString().replaceAll(\"-\", \"\").toUpperCase();\r\n        preOrder.setNonce_str(nonce_str);\r\n\r\n        preOrder.setBody(body);\r\n        preOrder.setOut_trade_no(out_trade_no);\r\n\r\n        preOrder.setTotal_fee(new BigDecimal(total_fee));\r\n        preOrder.setSpbill_create_ip(wxPayProperties.getSpbill_create_ip());\r\n        preOrder.setNotify_url(wxPayProperties.getNotify_url());\r\n        preOrder.setTrade_type(WxContants.TRADE_TYPE);\r\n        preOrder.setSub_openid(openId);\r\n        SortedMap p = new TreeMap();\r\n        p.put(\"appid\", wxPayProperties.getApp_id());\r\n        p.put(\"mch_id\", wxPayProperties.getMch_id());\r\n        p.put(\"sub_appid\", wxPayProperties.getSub_app_id());\r\n        p.put(\"sub_mch_id\", wxPayProperties.getSub_mch_id());\r\n        p.put(\"body\", body);\r\n        p.put(\"nonce_str\", nonce_str);\r\n        p.put(\"out_trade_no\", out_trade_no);\r\n        p.put(\"total_fee\", total_fee);\r\n        p.put(\"spbill_create_ip\", wxPayProperties.getSpbill_create_ip());\r\n        p.put(\"notify_url\", wxPayProperties.getNotify_url());\r\n        p.put(\"trade_type\", WxContants.TRADE_TYPE);\r\n        p.put(\"sub_openid\", openId);\r\n        // 签名\r\n        String sign = SignUtils.createSignByMd5(p, wxPayProperties.getKey());\r\n        preOrder.setSign(sign);\r\n        String xml = XmlUtil.object2Xml(preOrder, PreOrder.class);\r\n        // 调用下单地址\r\n        String returnXml = HttpUtil.sendPost(WxContants.pay_url, xml);\r\n        System.out.println(returnXml);\r\n        // XML转换为Object\r\n        PreOrderResult preOrderResult = (PreOrderResult) XmlUtil.xml2Object(returnXml, PreOrderResult.class);\r\n        // XML转换为Object\r\n        // 一般企业开发中支付流水入库，支付状态更新这些都需要做，此出省略\r\n        return preOrderResult;\r\n    }\r\n\r\n    @Override\r\n    public PayResult getWxPayResult(HttpServletRequest request) throws Exception {\r\n        InputStream inStream = request.getInputStream();\r\n        BufferedReader in = null;\r\n        String result = \"\";\r\n        in = new BufferedReader(\r\n                new InputStreamReader(inStream));\r\n        String line;\r\n        while ((line = in.readLine()) != null) {\r\n            result += line;\r\n        }\r\n        PayResult pr = (PayResult)XmlUtil.xml2Object(result, PayResult.class);\r\n        System.out.println(pr.toString());\r\n        return pr;\r\n    }\r\n\r\n}\r\n小程序配置部分@Component\r\npublic class WxPayProperties {\r\n\r\n    @Value(\"${wxpay.app_id}\")\r\n    private String app_id;\r\n\r\n    @Value(\"${wxpay.sub_app_id}\")\r\n    private String sub_app_id;\r\n\r\n    @Value(\"${wxpay.spbill_create_ip}\")\r\n    private String spbill_create_ip;\r\n\r\n    @Value(\"${wxpay.key}\")\r\n    private String key;\r\n\r\n    @Value(\"${wxpay.mch_id}\")\r\n    private String mch_id;\r\n\r\n    @Value(\"${wxpay.sub_mch_id}\")\r\n    private String sub_mch_id;\r\n\r\n    @Value(\"${wxpay.notify_url}\")\r\n    private String notify_url;\r\n\r\n    // 此处省略get/set方法\r\n    ...\r\n        \r\n}\r\n返回数据{\r\n    \"appId\": \"wxe670bb9ea4775345\",\r\n    \"nonceStr\": \"536D9056202D4292A909392320E2E5BB\",\r\n    \"package\": \"prepay_id=wx13143641616855cfa3275610dd2a070000\",\r\n    \"returnCode\": \"SUCCESS\",\r\n    \"returnMsg\": \"OK\",\r\n    \"sign\": \"C512D4025134C356BFA58A2F5699E198\",\r\n    \"signType\": \"MD5\",\r\n    \"timeStamp\": \"1610519802\"\r\n}\r\n小程序端根据后台返回的参数，拉起支付，代码如下：wx.requestPayment({\r\n\t'timeStamp': res.data.timeStamp,\r\n\t'nonceStr': res.data.nonceStr,\r\n\t'package': res.data.package,\r\n\t'signType': res.data.signType,\r\n\t'paySign': res.data.sign,\r\n\t'success':function(res){},\r\n\t'fail':function(res){},\r\n\t'complete':function(res){}\r\n})\r\n点击支付，总算是来到了这一步：过程中，可能会遇到如下问题：出现这个错误的原因是签名不正确，多检查检查是哪一步出现了问题。最后一路踩了不少坑，总算还是成功了，因此将解决方法记录下来，后面做小程序支付功能的小伙伴可以避免踩坑。"}
{"title": "【微信小程序】自定义导航栏 ", "author": "Rolan", "pub_time": "2021-2-7 10:33", "content": "一、隐藏官方导航栏隐藏导航栏可以全局配置，也可以单独页面配置，具体根据业务需求来。{\r\n    \"path\" : \"pages/public/login\",\r\n    \"style\": {\r\n        \"navigationBarTitleText\": \"\",\r\n        \"navigationStyle\": \"custom\",\r\n        \"app-plus\": {\r\n            \"titleNView\": false\r\n        }\r\n    }\r\n}\r\n二、计算相关值因为在不同的手机型号头部那条栏目高度可能不一致，所以为了我们适配更多型号，我们需要计算3个值：如下图：整个导航栏的高度；胶囊按钮与顶部的距离；胶囊按钮与右侧的距离。小程序可以通过 wx.getMenuButtonBoundingClientRect() 获取胶囊按钮的信息 和 wx.getSystemInfo() 获取设备信息。如下图：通过这些信息我们可以计算出上面说的3个值：1、整个导航栏高度 = statausBarHeight + height + (top-statausBarHeight )2；注：状态栏到胶囊的间距 = 胶囊到下边界距离。所以这里需要2(或： 导航栏高度 = bottom + ( top- statausBarHeight ) )2、胶囊按钮与顶部的距离 = top；3、胶囊按钮与右侧的距离 = windowWidth - right。实例一般情况下，我们需要在运用启动的初始化生命周期钩子进行计算相关的数据，也就是入口文件 app.js 的 onLaunch 生命周期钩子//app.js\r\nApp({\r\n onLaunch: function () {\r\n this.setNavBarInfo()\r\n },\r\n \r\n globalData: {\r\n //全局数据管理\r\n navBarHeight: 0, // 导航栏高度\r\n menuBotton: 0, // 胶囊距底部间距（保持底部间距一致）\r\n menuRight: 0, // 胶囊距右方间距（方保持左、右间距一致）\r\n menuHeight: 0, // 胶囊高度（自定义内容可与胶囊高度保证一致）\r\n },\r\n\r\n /**\r\n * @description 设置导航栏信息\r\n */\r\n setNavBarInfo () {\r\n // 获取系统信息\r\n const systemInfo = wx.getSystemInfoSync();\r\n // 胶囊按钮位置信息\r\n const menuButtonInfo = wx.getMenuButtonBoundingClientRect();\r\n // 导航栏高度 = 状态栏到胶囊的间距（胶囊距上距离-状态栏高度） * 2 + 胶囊高度 + 状态栏高度\r\n this.globalData.navBarHeight = (menuButtonInfo.top - systemInfo.statusBarHeight) * 2 + menuButtonInfo.height + systemInfo.statusBarHeight;\r\n this.globalData.menuBotton = menuButtonInfo.top - systemInfo.statusBarHeight;\r\n this.globalData.menuRight = systemInfo.screenWidth - menuButtonInfo.right;\r\n this.globalData.menuHeight = menuButtonInfo.height;\r\n }\r\n})\r\n页面引用自定义导航栏//page.wxml\r\n<view class=\"nav\" style=\"height:{{navBarHeight}}px;\">\r\n <!-- 胶囊区域 -->\r\n <view class=\"capsule-box\" style=\"height:{{menuHeight}}px; min-height:{{menuHeight}}px; line-height:{{menuHeight}}px; bottom:{{menuBotton}}px;\">\r\n <view class=\"nav-handle\">\r\n  <image class=\"nav-back-icon\" src=\"/images/nav_back.png\" bind:tap=\"navToBackLastPage\"></image>\r\n  <image class=\"nav-home-icon\" src=\"/images/nav_home.png\" bind:tap=\"navToHomePage\"></image>\r\n </view>\r\n <view class=\"nav-title\">导航标题</view>\r\n </view>\r\n</view>\r\n// page.js\r\nconst app = getApp()\r\nPage({\r\n\r\n /**\r\n * 页面的初始数据\r\n */\r\n data: {\r\n navBarHeight: app.globalData.navBarHeight,//导航栏高度\r\n menuBotton: app.globalData.menuBotton,//导航栏距离顶部距离\r\n menuHeight: app.globalData.menuHeight //导航栏高度\r\n }\r\n封装成组件我们可能在各自的页面实现不一样的效果，比如在导航栏添加搜索框，日期等，这个时候我们就可以封装一个自定义组件，大大提高我们的开发效率。新建component// components/navigation/index.wxml\r\n<view class=\"nav\" style=\"height:{{navBarHeight}}px;\">\r\n <view class=\"nav-main\">\r\n <!-- 胶囊区域 -->\r\n <view \r\n  class=\"capsule-box\" \r\n  style=\"height:{{menuHeight}}px; min-height:{{menuHeight}}px; line-height:{{menuHeight}}px; bottom:{{menuBotton}}px;left:{{menuRight}}px;\"\r\n >\r\n <!-- 导航内容区域 -->\r\n  <slot></slot>\r\n </view>\r\n </view>\r\n</view>\r\n\r\n// components/navigation/index.wxss\r\n.nav {\r\n position: fixed;\r\n top: 0;\r\n left: 0;\r\n width: 100vw;\r\n}\r\n.nav-main {\r\n width: 100%;\r\n height: 100%;\r\n position: relative;\r\n}\r\n.nav .capsule-box {\r\n position: absolute;\r\n box-sizing: border-box;\r\n width: 100%;\r\n}\r\n\r\n// components/navigation/index.js\r\nconst app = getApp()\r\nComponent({\r\n /**\r\n * 组件的初始数据\r\n */\r\n data: {\r\n navBarHeight: app.globalData.navBarHeight, //导航栏高度\r\n menuRight: app.globalData.menuRight, // 胶囊距右方间距（方保持左、右间距一致）\r\n menuBotton: app.globalData.menuBotton,\r\n menuHeight: app.globalData.menuHeight\r\n }\r\n})\r\n\r\n页面引用页面配置引入该自定义组件//index.json\r\n{\r\n \"navigationStyle\": \"custom\",\r\n \"navigationBarTextStyle\": \"white\",\r\n \"usingComponents\": {\r\n \"navigation\": \"/components/Navigation/index\"\r\n }\r\n}\r\n页面中使用<!-- 自定义导航 -->\r\n<navigation>\r\n <view class=\"current-date\">\r\n  <text>4月24日</text>\r\n </view>\r\n</navigation>"}
{"title": "极速入门微信小程序 之 生命周期篇(2-页面) ", "author": "Rolan", "pub_time": "2021-2-8 09:39", "content": "页面生命周期\r\n\r\n页面的生命周期相对于应用来是要多出不少\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n属性说明onLoad生命周期回调—监听页面加载onShow生命周期回调—监听页面显示onReady生命周期回调—监听页面初次渲染完成onHide生命周期回调—监听页面隐藏onUnload生命周期回调—监听页面卸载onPullDownRefresh监听用户下拉动作onReachBottom页面上拉触底事件的处理函数onShareAppMessage用户点击右上角转发onShareTimeline用户点击右上角转发到朋友圈onAddToFavorites用户点击右上角收藏onPageScroll页面滚动触发事件的处理函数onResize页面尺寸改变时触发，详见 响应显示区域变化onTabItemTap当前是 tab 页时，点击 tab 时触发\r\nonLoad\r\n\r\n页面开始加载的时候触发\r\n\r\n触发时机\r\n当页面开始加载的时候触发\r\n作用\r\n当页面开始加载时，用来发送异步请求获取数据 渲染页面\r\n代码\r\nPage({\r\n  /**\r\n   * 页面开始加载时触发\r\n   */\r\n  onLoad(){\r\n    console.log(\"onLoad 页面开始加载时触发\");\r\n  }\r\n})\r\n复制代码\r\n效果\r\n\r\nonHide\r\n\r\n页面被隐藏时触发\r\n\r\n触发时机\r\n当页面被隐藏时触发，如 使用 navigator配合 open-type为 redirect 或 navigate时 ，注意 如果关闭了页面 那么该函数是不会触发的。（open-type 为  其他时则为关闭 ）\r\n作用\r\n在当前页面被隐藏时可以暂停或者终止一些任务，如定时器或播放音乐等\r\n代码\r\nPage({\r\n  /**\r\n   * 当页面被隐藏时显示\r\n   */\r\n  onHide(){\r\n    console.log(\"onHide 当页面被隐藏时显示\");\r\n  }\r\n})\r\n复制代码\r\nonShow\r\n\r\n当页面第一次打开或者重新显示时触发\r\n\r\n触发时机\r\n当页面打一次打开时会触发，又或者小程序由另外一个页面重新返回和跳转到当前页面时也会触发\r\n作用\r\n可以重新发送请求获取数据如\r\n\r\n\r\nA 页面为个人信息页面 需要发送请求或者用户信息数据\r\n\r\n\r\nB 页面为修改信息页面\r\n\r\n\r\n业务\r\n\r\n打开A页面时 发送请求获取 用户信息\r\n此时点击修改头像 跳转到B页面\r\nB页面完成了修改功能 并重新返回A页面\r\n那么A页面就需要重新发送请求获取数据 也就是利用了 onShow 来实现重新发送请求\r\n\r\n\r\n\r\n图解\r\n\r\n\r\n\r\n代码\r\nPage({\r\n  /**\r\n   * 当页面第一次打开或者重新被显示时触发\r\n   */\r\n  onShow() {\r\n    console.log(\"onShow 当页面第一次打开或者重新被显示时触发\");\r\n  }\r\n})\r\n复制代码\r\nonReady\r\n\r\n当页面渲染完毕 标签元素都生成时 可以获取到页面的标签\r\n\r\n作用\r\n比较少用  一般用在操作和页面标签相关的功能\r\nonUnload\r\n\r\n和onHide类似 但是该生命周期表示的是 页面被关闭或者页面被卸载触发\r\n\r\n触发时机\r\n当页面被关闭时触发，如 使用 navigator 跳转页面时  选择的 open-type  为 switchTab  或  reLaunch  则为关闭\r\n作用\r\n和 onHide 功能类似  可以取消或者终止一些任务\r\n代码\r\nPage({\r\n  /**\r\n   * 页面被关闭或者页面被卸载触发\r\n   */\r\n  onUnload() {\r\n    console.log(\"onUnload 页面被关闭或者页面被卸载触发\");\r\n  }\r\n})\r\n复制代码\r\nonPullDownRefresh\r\n\r\n当下拉页面时触发，一一般用在下拉页面 执行刷新操作\r\n\r\n触发时机\r\n当用户手动下拉页面时触发\r\n作用\r\n可以执行 下拉刷新  在该函数内发送请求 获取新的数据 模拟 web端的刷新操作\r\n代码\r\n该功能需要主动的在 json文件中开启配置。如\r\nindex.json\r\n\r\n添加 backgroundColor 是为了让我们看到更加清楚\r\n\r\n{\r\n  \"backgroundColor\": \"#0054ff\",\r\n  \"enablePullDownRefresh\": true\r\n}\r\n复制代码\r\nindex.js\r\nPage({\r\n  /**\r\n   * 当用户下拉页面时触发\r\n   */\r\n  onPullDownRefresh(){\r\n    console.log(\"onPullDownRefresh 当用户下拉页面时触发\");\r\n  }\r\n})\r\n复制代码\r\n效果\r\n\r\nonReachBottom\r\n\r\n理解为和上一个生命周期相对应 页面上拉 也可以理解为滚动条触底的时候就 触发\r\n\r\n触发时机\r\n当页面的滚动条(需要构造出内容高度大于屏幕高度的结构)触底的时候就触发\r\n作用\r\n我们一般用做上拉加载下一页数据 ，也就是做分页使用\r\n代码\r\nPage({\r\n  /**\r\n   * 当滚动体触碰到底部的时候触发\r\n   */\r\n  onReachBottom() {\r\n    console.log(\"onReachBottom 当滚动体触碰到底部的时候触发\");\r\n  }\r\n})\r\n复制代码\r\n效果\r\n\r\nonShareAppMessage\r\n\r\n当用户点击 转发 小程序到微信好友或者微信群时触发\r\n需要注意的是 转发  和 分享 是两种操作 转发是发送到好友或者好友群，而 分享 是分享到朋友圈。下面会马上讲解到 分享\r\n\r\n触发时机\r\n触发的入口有两个\r\n\r\n点击小程序的自带的右上角的转发按钮  ···\r\n设置 button  标签的  open-type=\"share\"\r\n\r\n作用\r\n方便了小程序的裂变\r\n代码\r\n需要注意的是 如何是通过点击右上角的 按钮进行转发，那么必须先定义该生命周期，否则是不会出现以下界面的\r\n\r\n\r\n\r\nPage({\r\n  /**\r\n   * 当用户点击 转发 小程序时触发\r\n   */\r\n  onShareAppMessage(){\r\n    console.log(\"onShareAppMessage 当用户点击 转发 小程序时触发\");\r\n  }\r\n})\r\n复制代码\r\n效果\r\n\r\nonShareTimeline\r\n\r\n当小程序被分享到朋友圈时触发\r\n\r\n触发时机\r\n当用户点击 分享到朋友圈 按钮时触发\r\n作用\r\n方便了小程序的裂变\r\n代码\r\n需要注意的是，想要出现以下按钮，那么也是必须要先定义该生命周期。\r\n\r\n\r\n\r\nPage({\r\n  /**\r\n   * 当用户点击分享到朋友圈时触发\r\n   */\r\n  onShareTimeline(){\r\n    console.log(\"onShareTimeline 当用户点击分享到朋友圈时触发\");\r\n  }\r\n})\r\n复制代码\r\n效果\r\n\r\nonAddToFavorites\r\n\r\n当小程序被用户收藏时触发\r\n\r\n触发时机\r\n当用户点击 收藏按钮时触发\r\n作用\r\n方便用户主动找到小程序\r\n代码\r\nPage({\r\n  /**\r\n   * 当用户收藏小程序时触发\r\n   */\r\n  onAddToFavorites(){\r\n    console.log(\"onAddToFavorites 当用户收藏小程序时触发\");\r\n  }\r\n})\r\n\r\n复制代码\r\n效果\r\n\r\nonPageScroll\r\n\r\n当页面滚动时触发\r\n\r\n触发时机\r\n当页面滚动时触发\r\n作用\r\n可以配合滚动的高度做一些业务如 背景颜色实时变化等\r\n代码\r\nPage({\r\n  /**\r\n   * 当页面产生滚动时触发\r\n   */\r\n  onPageScroll(){\r\n    console.log(\"onPageScroll 当页面产生滚动时触发\");\r\n  }\r\n})\r\n复制代码\r\n效果\r\n\r\nonResize\r\n\r\n当屏幕大小发生调整的时候触发\r\n有小伙伴发现不对劲，移动端上怎么会出现屏幕大小改变的情况。所以正确的描述应该是 横屏竖屏发现切换时触发\r\n\r\n触发时机\r\n手机屏幕发现横屏竖屏切换时触发\r\n作用\r\n让页面跟随屏幕切换做对相应反应，如横屏播放视频时控制播放按钮的位置\r\n代码\r\n想要该生命周期生效，我们需要在页面的json文件中加入该配置 作用是让其自动切换。\r\n如果不加入该代码 我们是无法在模拟器中演示的\r\nindex.json\r\n{\r\n  \"pageOrientation\": \"auto\"\r\n}\r\n复制代码\r\n\r\n\r\nindex.js\r\nPage({\r\n  /**\r\n   * 当屏幕发生横屏竖屏切换时触发\r\n   */\r\n  onResize(){\r\n    console.log(\"onResize 当屏幕发生横屏竖屏切换时触发\");\r\n  }\r\n})\r\n复制代码\r\n效果\r\n\r\nonTabItemTab\r\n\r\n当用户点击 小程序的tabbar上的选项时触发\r\n\r\n触发时机\r\n当用户点击 小程序的tabbar上的选项时触发\r\n作用\r\n可以实现点击tabbar时附带的功能，如跳转页面携带参数\r\n代码\r\nPage({\r\n  /**\r\n   * 当屏幕发生横屏竖屏切换时触发\r\n   */\r\n  onResize(){\r\n    console.log(\"onTabItemTab 当用户点击 小程序的tabbar上的选项时触发\");\r\n  }\r\n})\r\n复制代码\r\n效果\r\n无\r\n技术交流群\r\n947593379\r\n最后\r\n码字不容易 你的点击关注点赞留言就是我最好的驱动力作者：赤兔工作室链接：https://juejin.cn/post/6926445811681378311来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "聊一聊小程序如何换肤 ", "author": "Rolan", "pub_time": "2021-2-8 09:59", "content": "换肤需求一般来说换肤需求分两种：一种是静态换肤，提供几种可选择的颜色/主题样式，进行选择切换，一般可供选择的主题样式不会太多；另一种是动态换肤，可自定义色值，可通过取色板取色或者后端接口下发，可选择的范围比较大；传统前端换肤方案在聊小程序的换肤方案之前，我们大概看一下一般前端项目常见的换肤方案以及优缺点：1、class 命名空间这个应该是最简单的换肤方案，利用class 名称准备两个主题：根据所选皮肤，给标签添加对应的类：<body class=\"red-theme\">    <p>红色主题 </p>    ...</body>优缺点：优点： 简单，好理解，好实现缺点： CSS中需多写主题的class，代码容易混乱；需手动编写2. 生成多套CSS皮肤利用CSS预处理语言（如：Less，stylus 或 sass）以及 Webpack、gulp等工具输出多套主题样式。/** default-theme.css **/.text {    color: #333;}/** red-theme.css **/.text {    color: red;}/** blue-theme.css **/.text {    color: blue;}页面加载后，根据用户需求通过js动态的link对应的皮肤样式。// js动态处理 var theme = /\\bt=(\\w+)/.exec(location.search); theme = theme ? theme[1] : \"light\"; changeTheme(theme);function changeTheme(theme) {    var head = document.getElementsByTagName(\"head\")[0];    var link = document.createElement(\"link\");    link.dataset.type = \"theme\";    link.href = \"assets/css/theme-\" + theme + \"/pages/home/home.css\";    link.rel = \"stylesheet\";    link.type = \"text/css\";    head.appendChild(link);}如果需要保存用户使用的主题，可以通过如下方式：利用路由标记利用cookie标记利用localstorage保存到后端服务器优缺点：优点： 简单，好理解，好实现缺点： 需要手写两份以上CSS配色样式； 切换样式需要下载CSS的时间Tips: 动态加载CSS文件可能需求一定的等待时间，可根据HTML 的 rel 属性下的 alternate配合 link 的 disabled 实现一定优化。3. CSS变量换肤利用CSS变量设置颜色， 用js动态修改CSS变量，进而换色。如果不考虑兼容性，这是最佳换肤方案。// variable.less:root {  --fill-1: #fff;  --text: #3c3c3c;  --text-1: #757575;  --text-2: #222;  --font-size-large: 18px;  --font-size-large-x: 22px;  --font-size-medium: 14px;  --font-size-medium-x: 16px;  --font-size-small-s: 10px;  --font-size-small: 12px;}在页面对css变量做引入使用:// 页面使用@import \"../../assets/less/variable.less\";.header {  position: relative;  height: 70px;  text-align: center;  font-size: 0;   .text {    display: inline-block;    vertical-align: top;    line-height: 70px;    font-size: var(--font-size-large);    color: var(--text-2);  }}然后在页面中可以直接通过JavaScript修改变量的值function changeColor(color = 'blue') {    document.documentElement.style.setProperty(\"--theme-color\",color);}优缺点：优点：只需一套CSS文件； 换肤不需要延迟等候；对浏览器性能要求低；可自动适配多种主题色；缺点： 不支持IE， 2016年前的chrome，safari; 兼容性参见 Can I Use CSS VariablesCSS变量兼容性4. Less 在线编译使用 modifyVars()方法, 基于 less 在浏览器中的编译来实现。在引入less文件的时候需要通过link方式引入，然后基于less.js中的方法来进行修改less变量:less.modifyVars({  '@themeColor': 'blue'});link方式引入主题色文件:<link rel=\"stylesheet/less\" type=\"text/css\" href=\"./src/less/public.less\" />小程序换肤方案本文方案均以 less、gulp 为基本框架。背景在开发小程序的时候，尤其是开发第三方小程序，我们作为开发者，只需要开发一套模板即可，但是个别客户的小程序需要做定制化配色方案，也就是说，不同的小程序个体需要对页面的元素（比如：按钮，字体等）进行不同的配色设置。方案以及问题由于小程序它自身的技术特点，传统方案的 CSS变量以及Less 在线编译 换肤方案无法使用，所以小程序换肤方案主要是：如果没有线上存在多套皮肤的需求，可以抽取颜色变量通过线下编译修改主题色。如果有线上多套皮肤的需求，则采用传统前端的多套CSS皮肤方案加更改类名的方式。针对动态换肤，后端接口返回色值字段，前端通过 内联 方式对页面元素进行色值设置。这几种方案都有一些问题无法避免：方案1、2 比较死板，每次更改主题样式都需要发版小程序，如果主题样式变动不大，可以考虑这种；方案3 对于前端的改动非常的大，内联也就是通过 style 的方式内嵌到 wxml 代码中，代码的阅读性会变差，但是可以解决主题样式变动不用发版小程序的问题。方案一针对方案一，我们只需要抽取相关的变量色值到独立的文件中，约定项目在使用色值的地方统一引用该文件的变量。当需要修改主题色的时候修改对应变量即可。/** variable.less **/@theme-color: #FD7622;@txt-default: #333;@txt-body: #666;@txt-info: #999;@txt-muted: #ccc;@txt-warning: #FF0500;@txt-highlight: @theme-color;@txt-link: #00a5e0;@txt-feeds: #314c83;@txt-white: #fff;在编译阶段，通过 gulp-less的 modifyVars属性修改相关变量即可：// gulpfile.jsvar gulp = require('gulp');var less = require('gulp-less');var rename = require('gulp-rename');function lessTask() {  return gulp.src('./less/**/*.less')             .pipe(less({                  modifyVars: {                     '@theme-color': '#757575',                     '@txt-default': '#212121',                 }                }))             .pipe(rename(function(path) {               path.extname = '.wxss'             }))             .pipe(gulp.dest('./wxss'))}function autosTask() {  gulp.watch('./less/**/*.less', lessTask)}exports.default = gulp.series(gulp.parallel(lessTask, autosTask))方案二这个方案我们需要定制多套主题变量，并编译出多套皮肤样式。主题色变量配置文件/** variable.less **/#theme() {  .colors(dark) {    @theme-color: #000;  }  .colors(light) {    @theme-color: #fff;  }}页面样式文件@import 'variable.less'.dark {  @colors: #theme.colors(dark);  .btn {      .btnMixin;  }}.light {  @colors: #theme.colors(light);  .btn {    .btnMixin;  }}.btnMixin() {  background: @colors[@theme-color];}/** 输出 .dark .btn {  background: #000;}.light .btn {  background: #fff;}**/页面中使用的方式页面的 wxml 引入主题变量 theme <view class=\"index-layout {{theme}}\">     <button class=\"btn\">按钮</button> </view>通过页面中的 this.data.theme 来控制主题page({data: { theme: ''},themeChange(e) { const { theme } = e.target.dataset this.setData({ theme })}})上面两个方案到目前为止也只是解决了在less文件中的换色问题，而实际的项目中我们很多时候并不能避免一些色值是内联写在 wxml 上以及写死在 javascript 文件中的。比如，下面的 radio 组件：<radio value=\"light\" checked=\"true\" color=\"#fd7622\" />这种情况下同样抽取出一个颜色变量的wxs文件在wxml 使用，如：// variable.wxsvar themeColor = {  dark: {    '@theme-color': '#333',  },  light: {    '@theme-color': '#fd7622',  },};function getVariable(theme) {    return themeColor[theme]}module.exports = getVariable;<!--index.wxml--><wxs src=\"@wxsVar\" module=\"getVariable\" /><radio value=\"light\" checked=\"true\" color=\"{{getVariable(theme)['@theme-color']}}\" />js 文件同理，这里不再复诉。方案三小程序中要实现动态换肤，目前能想到的办法就是在涉及到颜色设置时通过 内联（设置 style） 方式对页面元素进行色值设置。这种方法目前来说成本较高，对于已经成型的项目来说风险过大。在wxml设置颜色时我们同样可以通过wxs来实现。function getStyle(style, theme) {    return style + ':' + theme;}function setStyle(styles = [], theme) {    if (!styles || !styles.length) return '';    var styleArr = []    styles.forEach(function(style) {        styleArr.push(getStyle(style, theme))    })    return styleArr.join(';');}module.exports = setStyle;wxml 中使用<wxs src=\"@dynamic\" module=\"setStyle\" /><view class=\"container\">  <view class=\"box\" style=\"{{ setStyle(['color', 'border-color'], theme) }}\">    setStyle(['color', 'border-color'])  </view>  <input type=\"text\" placeholder=\"输入一个色值\" style=\"{{ setStyle(['border-color'], theme) }}\" bindconfirm=\"onChange\"/></view>Page({  data: {    theme: '#222',  },  onChange(e:{detail: {value: string}}) {    this.setData({      theme: e.detail.value,    })  }})示例这里给一个简单的示例。一个简单的Demo最后  由于小程序的特殊性，在换肤这种需求中局限性还是很大的。以上只是给大家提供一下一些解决思路，如果大家有更好的方案的话欢迎留言。"}
